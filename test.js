// Generated by Haxe 4.3.0-rc.1+5f599ba
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var cornerContour_Contour = function(pen_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.count = 0;
	this.pointsAnti = [];
	this.pointsClock = [];
	this.pen = pen_;
	this.endLine = endLine_;
};
cornerContour_Contour.__name__ = true;
cornerContour_Contour.prototype = {
	reset: function() {
		this.angleA = 0;
		this.count = 0;
		this.kax = 0;
		this.kay = 0;
		this.kbx = 0;
		this.kby = 0;
		this.kcx = 0;
		this.kcy = 0;
		this.ncx = 0;
		this.ncy = 0;
		this.ax = 0;
		this.ay = 0;
		this.bx = 0;
		this.by = 0;
		this.cx = 0;
		this.cy = 0;
		this.dx = null;
		this.dy = null;
		this.ex = null;
		this.ey = null;
		this.pointsClock.length = 0;
		this.pointsAnti.length = 0;
	}
	,triangleJoin: function(ax_,ay_,bx_,by_,width_,curveEnds,overlap) {
		if(overlap == null) {
			overlap = false;
		}
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = this.dx != null ? this.angle1 : null;
		this.halfA = Math.PI / 2;
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var x = this.dxOld - bx_;
		var y = this.dyOld - by_;
		var x1 = this.exOld - bx_;
		var y1 = this.eyOld - by_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(this.ay - this.dyOld,this.ax - this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.eyPrev,this.ax - this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(this.ay - this.eyOld,this.ax - this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.dyPrev,this.ax - this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(fracs_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		if(!overlap && this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f = theta0;
			} else {
				var a = (theta0 + Math.PI) % (2 * Math.PI);
				f = a >= 0 ? a - Math.PI : a + Math.PI;
			}
			var this1 = f;
			var start = this1;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			this.jx = this.ax + h * Math.sin(delta);
			this.jy = this.ay + h * Math.cos(delta);
		}
		if(this.count == 0 && (this.endLine == 1 || this.endLine == 3)) {
			var ax = this.ax;
			var ay = this.ay;
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif1;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 > 0 ? dif2 : 2 * Math.PI + dif2;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = smallest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = largest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif1 >= 0;
			var totalSteps = Math.ceil(Math.abs(dif1) / step);
			var step = dif1 / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[i * 2 + len + 1];
				this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(overlap) {
			this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,-1);
			this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
		} else {
			if(this.count != 0) {
				this.addQuads(clockWise,width_);
			}
			this.quadIndex = this.pen.get_pos();
			if(this.count == 0) {
				this.penultimateAX = this.dxPrev;
				this.penultimateAY = this.dyPrev;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.penultimateCX = this.dx;
				this.penultimateCY = this.dy;
				this.lastClockX = this.exPrev;
				this.lastClockY = this.eyPrev;
				this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,-1);
				this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
			} else {
				if(clockWise && !this.lastClock) {
					this.penultimateAX = this.jx;
					this.penultimateAY = this.jy;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.exPrev;
					this.lastClockY = this.eyPrev;
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,-1);
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
				}
				if(clockWise && this.lastClock) {
					this.penultimateAX = this.jx;
					this.penultimateAY = this.jy;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.exPrev;
					this.lastClockY = this.eyPrev;
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,-1);
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
				}
				if(!clockWise && !this.lastClock) {
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.jx;
					this.lastClockY = this.jy;
					this.penultimateAX = this.dxPrev;
					this.penultimateAY = this.dyPrev;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.jx,this.jy,-1);
					this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,-1);
				}
				if(!clockWise && this.lastClock) {
					this.penultimateAX = this.dxPrev;
					this.penultimateAY = this.dyPrev;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.jx;
					this.penultimateCY = this.jy;
					this.lastClockX = this.dx;
					this.lastClockY = this.dy;
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,-1);
					this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.jx,this.jy,this.ex,this.ey,-1);
				}
			}
		}
		if(curveEnds) {
			if(clockWise) {
				var radius = width_ / 2;
				var edgePoly = this.pointsClock;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						var color_ = -1;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
					}
					angle += step;
					bx = cx;
					by = cy;
				}
			} else {
				var radius = width_ / 2;
				var edgePoly = this.pointsAnti;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						var color_ = -1;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
					}
					angle += step;
					bx = cx;
					by = cy;
				}
			}
		} else if(this.count != 0) {
			if(overlap) {
				if(clockWise) {
					this.pen.triangle2DFill(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.ax,this.ay,-1);
				} else {
					this.pen.triangle2DFill(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.ax,this.ay,-1);
				}
			} else if(clockWise) {
				this.pen.triangle2DFill(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.jx,this.jy,-1);
			} else {
				this.pen.triangle2DFill(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.jx,this.jy,-1);
			}
		}
		this.kax = this.dxPrev;
		this.kay = this.dyPrev;
		this.kbx = this.dx;
		this.kby = this.dy;
		this.ncx = this.exPrev;
		this.ncy = this.eyPrev;
		this.kcx = this.ex;
		this.kcy = this.ey;
		if(curveEnds && !overlap && this.count != 0) {
			if(clockWise) {
				this.pen.triangle2DFill(this.ax,this.ay,this.dxOld,this.dyOld,this.jx,this.jy,-1);
				this.pen.triangle2DFill(this.ax,this.ay,this.exPrev,this.eyPrev,this.jx,this.jy,-1);
			} else {
				this.pen.triangle2DFill(this.ax,this.ay,this.exOld,this.eyOld,this.jx,this.jy,-1);
				this.pen.triangle2DFill(this.ax,this.ay,this.dxPrev,this.dyPrev,this.jx,this.jy,-1);
			}
		}
		this.jxOld = this.jx;
		this.jyOld = this.jy;
		this.lastClock = clockWise;
		this.count++;
	}
	,end: function(width_) {
		this.endEdges();
		if(this.count != 0) {
			var ax = this.bx;
			var ay = this.by;
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var temp = [];
			var color = 0;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var _g = 0;
			var _g1 = len + 2;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[i];
			}
			var pC = this.pointsClock.length;
			var _g = 1;
			var _g1 = len / 2 + 1 | 0;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[temp.length - 2 * i];
				this.pointsClock[pC++] = temp[temp.length - 2 * i - 1];
			}
		}
	}
	,endEdges: function() {
		var pC = this.pointsClock.length;
		var pA = this.pointsAnti.length;
		this.pointsClock[pC++] = this.penultimateCX;
		this.pointsClock[pC++] = this.penultimateCY;
		this.pointsClock[pC++] = this.lastClockX;
		this.pointsClock[pC++] = this.lastClockY;
		this.pointsAnti[pA++] = this.penultimateAX;
		this.pointsAnti[pA++] = this.penultimateAY;
		this.pointsAnti[pA++] = this.lastAntiX;
		this.pointsAnti[pA++] = this.lastAntiY;
	}
	,addQuads: function(clockWise,width_) {
		var currQuadIndex = this.pen.get_pos();
		var pC = 0;
		var pA = 0;
		if(clockWise && !this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.jxOld,this.jyOld,-1);
			}
			this.pen.set_pos(this.quadIndex);
			this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.jx,this.jy,-1);
		}
		if(clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				this.pointsAnti[pA++] = this.kbx;
				this.pointsAnti[pA++] = this.kby;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kax;
				this.pointsClock[pC++] = this.kay;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.jx,this.jy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.kbx,this.kby,this.jx,this.jy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.kbx,this.kby,this.ncx,this.ncy,-1);
			}
		}
		if(!clockWise && !this.lastClock) {
			this.pen.set_pos(this.quadIndex);
			this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.kcx,this.kcy,-1);
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.jxOld,this.jyOld,-1);
			}
		}
		if(!clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.kcx,this.kcy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.jx,this.jy,this.kcx,this.kcy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.jx,this.jy,this.ncx,this.ncy,-1);
			}
		}
		this.pen.set_pos(currQuadIndex);
	}
	,line: function(ax_,ay_,bx_,by_,width_,endLineCurve) {
		if(endLineCurve == null) {
			endLineCurve = 0;
		}
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.halfA = Math.PI / 2;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var dxPrev_ = this.dx;
		var dyPrev_ = this.dy;
		var exPrev_ = this.ex;
		var eyPrev_ = this.ey;
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		switch(endLineCurve) {
		case 0:
			break;
		case 1:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = 0;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 2:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = 0;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 3:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = 0;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = 0;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		}
		this.pen.triangle2DFill(dxPrev_,dyPrev_,this.dx,this.dy,exPrev_,eyPrev_,-1);
		this.pen.triangle2DFill(dxPrev_,dyPrev_,this.dx,this.dy,this.ex,this.ey,-1);
	}
};
var cornerContour_Pen2D = function(col) {
	var this1 = [];
	this1[0] = 0.;
	this.arr = this1;
	this.currentColor = col;
};
cornerContour_Pen2D.__name__ = true;
cornerContour_Pen2D.prototype = {
	get_pos: function() {
		return this.arr[0];
	}
	,set_pos: function(val) {
		this.arr[0] = val;
		return val;
	}
	,triangle2DFill: function(ax,ay,bx,by,cx,cy,color) {
		if(color == null || color == -1) {
			color = this.currentColor;
		}
		var this1 = this.arr;
		cornerContour_io_Array2DTriangles.triangle(this1,ax,ay,bx,by,cx,cy);
		if(color == null) {
			cornerContour_io_Array2DTriangles.set_colorInt(this1,16711680);
		} else {
			cornerContour_io_Array2DTriangles.set_colorInt(this1,color);
		}
		var pos_ = this.arr[0] + 1;
		this.arr[0] = pos_;
		return 1;
	}
};
var cornerContour_Sketcher = function(pen_,sketchForm_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.turtleParameters = [];
	this.turtleCommands = [];
	this.repeatCommands = false;
	this.repeatCount = 0;
	this.width = 0.01;
	this.rotation = 0.;
	this.y = 0.;
	this.x = 0.;
	this.penIsDown = true;
	this.rotation = -Math.PI / 2;
	this.pen = pen_;
	this.endLine = endLine_;
	this.contour = this.createContour();
	this.sketchForm = sketchForm_;
	switch(sketchForm_) {
	case 0:
		this.line = $bind(this,this.tracerLine);
		break;
	case 1:
		this.line = $bind(this,this.baseLine);
		break;
	case 2:
		this.line = $bind(this,this.crudeLine);
		break;
	case 3:
		this.line = $bind(this,this.fillOnlyLine);
		break;
	case 4:
		this.line = $bind(this,this.fineLine);
		break;
	case 5:
		this.line = $bind(this,this.fineOverlapLine);
		break;
	case 6:
		this.line = $bind(this,this.mediumLine);
		break;
	case 7:
		this.line = $bind(this,this.mediumOverlapLine);
		break;
	case 8:
		this.line = $bind(this,this.roundEndLine);
		break;
	}
	this.points = [];
	this.pointsClock = [];
	this.pointsAnti = [];
	this.points[0] = [];
	this.dim = [];
};
cornerContour_Sketcher.__name__ = true;
cornerContour_Sketcher.prototype = {
	tracerLine: function(x_,y_) {
		haxe_Log.trace("lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )",{ fileName : "cornerContour/Sketcher.hx", lineNumber : 32, className : "cornerContour.Sketcher", methodName : "tracerLine"});
	}
	,fillOnlyLine: function(x_,y_) {
	}
	,baseLine: function(x_,y_) {
		haxe_Log.trace("lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )",{ fileName : "cornerContour/Sketcher.hx", lineNumber : 32, className : "cornerContour.Sketcher", methodName : "tracerLine"});
		this.contour.line(this.x,this.y,x_,y_,this.width);
	}
	,crudeLine: function(x_,y_) {
		this.contour.line(this.x,this.y,x_,y_,this.width);
	}
	,roundEndLine: function(x_,y_) {
		this.contour.line(this.x,this.y,x_,y_,this.width,3);
	}
	,mediumLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,false);
	}
	,mediumOverlapLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,false,true);
	}
	,fineLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,true);
	}
	,fineOverlapLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,true,true);
	}
	,createContour: function() {
		return new cornerContour_Contour(this.pen,this.endLine);
	}
	,lineTo: function(x_,y_) {
		var repeat = this.x == x_ && this.y == y_;
		if(!repeat) {
			if(this.widthFunction != null) {
				this.width = this.widthFunction(this.width,this.x,this.y,x_,y_);
			}
			if(this.colourFunction != null) {
				this.pen.currentColor = this.colourFunction(this.pen.currentColor,this.x,this.y,x_,y_);
			}
			this.line(x_,y_);
			var l = this.points.length;
			var p = this.points[l - 1];
			var l2 = p.length;
			p[l2] = x_;
			p[l2 + 1] = y_;
			var d = this.dim[this.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			this.x = x_;
			this.y = y_;
		}
	}
	,orange: function() {
		if(this.repeatCommands) {
			this.turtleCommands.push("ORANGE");
		} else {
			this.pen.currentColor = -23808;
		}
		return this;
	}
	,grey: function() {
		if(this.repeatCommands) {
			this.turtleCommands.push("GREY");
		} else {
			this.pen.currentColor = -4737097;
		}
		return this;
	}
};
var cornerContour_io_Array2DTriangles = {};
cornerContour_io_Array2DTriangles.get_ax = function(this1) {
	return this1[(this1[0] | 0) * 7 + 1];
};
cornerContour_io_Array2DTriangles.set_ax = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_ay = function(this1) {
	return this1[(this1[0] | 0) * 7 + 1 + 1];
};
cornerContour_io_Array2DTriangles.set_ay = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 1 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_bx = function(this1) {
	return this1[(this1[0] | 0) * 7 + 2 + 1];
};
cornerContour_io_Array2DTriangles.set_bx = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 2 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_by = function(this1) {
	return this1[(this1[0] | 0) * 7 + 3 + 1];
};
cornerContour_io_Array2DTriangles.set_by = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 3 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_cx = function(this1) {
	return this1[(this1[0] | 0) * 7 + 4 + 1];
};
cornerContour_io_Array2DTriangles.set_cx = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 4 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_cy = function(this1) {
	return this1[(this1[0] | 0) * 7 + 5 + 1];
};
cornerContour_io_Array2DTriangles.set_cy = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 5 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_color = function(this1) {
	return this1[(this1[0] | 0) * 7 + 6 + 1];
};
cornerContour_io_Array2DTriangles.set_colorInt = function(this1,v) {
	var v1 = v | 0;
	this1[(this1[0] | 0) * 7 + 6 + 1] = v1;
	return v;
};
cornerContour_io_Array2DTriangles.triangle = function(this1,ax_,ay_,bx_,by_,cx_,cy_) {
	cornerContour_io_Array2DTriangles.set_ax(this1,ax_);
	cornerContour_io_Array2DTriangles.set_ay(this1,ay_);
	cornerContour_io_Array2DTriangles.set_bx(this1,bx_);
	cornerContour_io_Array2DTriangles.set_by(this1,by_);
	cornerContour_io_Array2DTriangles.set_cx(this1,cx_);
	cornerContour_io_Array2DTriangles.set_cy(this1,cy_);
	var windingAdjusted = cornerContour_io_Array2DTriangles.adjustWinding(this1);
	if(windingAdjusted) {
		cornerContour_io_Array2DTriangles.set_ax(this1,ax_);
		cornerContour_io_Array2DTriangles.set_ay(this1,ay_);
		cornerContour_io_Array2DTriangles.set_bx(this1,cx_);
		cornerContour_io_Array2DTriangles.set_by(this1,cy_);
		cornerContour_io_Array2DTriangles.set_cx(this1,bx_);
		cornerContour_io_Array2DTriangles.set_cy(this1,by_);
	}
	return windingAdjusted;
};
cornerContour_io_Array2DTriangles.adjustWinding = function(this1) {
	return cornerContour_io_Array2DTriangles.get_ax(this1) * cornerContour_io_Array2DTriangles.get_by(this1) - cornerContour_io_Array2DTriangles.get_bx(this1) * cornerContour_io_Array2DTriangles.get_ay(this1) + (cornerContour_io_Array2DTriangles.get_bx(this1) * cornerContour_io_Array2DTriangles.get_cy(this1) - cornerContour_io_Array2DTriangles.get_cx(this1) * cornerContour_io_Array2DTriangles.get_by(this1)) + (cornerContour_io_Array2DTriangles.get_cx(this1) * cornerContour_io_Array2DTriangles.get_ay(this1) - cornerContour_io_Array2DTriangles.get_ax(this1) * cornerContour_io_Array2DTriangles.get_cy(this1)) > 0;
};
var cornerContourWebGLTest_CornerContourWebGLTurtle = function() {
	this.vertexColor = "vertexColor";
	this.vertexPosition = "vertexPosition";
	this.divertTrace = new cornerContourWebGLTest_DivertTrace();
	haxe_Log.trace("Contour Test of Turtle",{ fileName : "src/cornerContourWebGLTest/CornerContourWebGLTurtle.js.hx", lineNumber : 62, className : "cornerContourWebGLTest.CornerContourWebGLTurtle", methodName : "new"});
	this.width = 1024;
	this.height = 768;
	this.drawContours();
	this.rearrageDrawData();
	this.renderOnce();
};
cornerContourWebGLTest_CornerContourWebGLTurtle.__name__ = true;
cornerContourWebGLTest_CornerContourWebGLTurtle.prototype = {
	rearrageDrawData: function() {
		haxe_Log.trace("rearrangeDrawData",{ fileName : "src/cornerContourWebGLTest/CornerContourWebGLTurtle.js.hx", lineNumber : 73, className : "cornerContourWebGLTest.CornerContourWebGLTurtle", methodName : "rearrageDrawData"});
		var pen = this.pen2D;
		var data = pen.arr;
		var red = 0.;
		var green = 0.;
		var blue = 0.;
		var alpha = 0.;
		var color = 0;
		this.totalTriangles = (data.length - 1) / 7 | 0;
		this.bufferLength = this.totalTriangles * 3;
		this.len = this.totalTriangles * 6 * 3 | 0;
		var j = 0;
		var this1 = new Float32Array(this.len);
		this.arr32 = this1;
		var _g = 0;
		var _g1 = this.totalTriangles;
		while(_g < _g1) {
			var i = _g++;
			pen.arr[0] = i;
			color = cornerContour_io_Array2DTriangles.get_color(data) | 0;
			alpha = (color >> 24 & 255) / 255;
			red = (color >> 16 & 255) / 255;
			green = (color >> 8 & 255) / 255;
			blue = (color & 255) / 255;
			this.arr32[j] = -(1 - 2 * cornerContour_io_Array2DTriangles.get_ax(data) / this.width);
			++j;
			this.arr32[j] = 1 - 2 * cornerContour_io_Array2DTriangles.get_ay(data) / this.height;
			++j;
			this.arr32[j] = red;
			++j;
			this.arr32[j] = green;
			++j;
			this.arr32[j] = blue;
			++j;
			this.arr32[j] = alpha;
			++j;
			this.arr32[j] = -(1 - 2 * cornerContour_io_Array2DTriangles.get_bx(data) / this.width);
			++j;
			this.arr32[j] = 1 - 2 * cornerContour_io_Array2DTriangles.get_by(data) / this.height;
			++j;
			this.arr32[j] = red;
			++j;
			this.arr32[j] = green;
			++j;
			this.arr32[j] = blue;
			++j;
			this.arr32[j] = alpha;
			++j;
			this.arr32[j] = -(1 - 2 * cornerContour_io_Array2DTriangles.get_cx(data) / this.width);
			++j;
			this.arr32[j] = 1 - 2 * cornerContour_io_Array2DTriangles.get_cy(data) / this.height;
			++j;
			this.arr32[j] = red;
			++j;
			this.arr32[j] = green;
			++j;
			this.arr32[j] = blue;
			++j;
			this.arr32[j] = alpha;
			++j;
		}
	}
	,drawContours: function() {
		haxe_Log.trace("drawContours",{ fileName : "src/cornerContourWebGLTest/CornerContourWebGLTurtle.js.hx", lineNumber : 136, className : "cornerContourWebGLTest.CornerContourWebGLTurtle", methodName : "drawContours"});
		this.pen2D = new cornerContour_Pen2D(-16776961);
		this.pen2D.currentColor = -16776961;
		this.turtleStar();
	}
	,renderOnce: function() {
		haxe_Log.trace("renderOnce",{ fileName : "src/cornerContourWebGLTest/CornerContourWebGLTurtle.js.hx", lineNumber : 144, className : "cornerContourWebGLTest.CornerContourWebGLTurtle", methodName : "renderOnce"});
		this.mainSheet = new cornerContourWebGLTest_Sheet();
		this.mainSheet.create(this.width,this.height,true);
		this.gl = this.mainSheet.gl;
		var gl = this.gl;
		var width = this.width;
		var height = this.height;
		var r = 0.;
		var g = 0.;
		var b = 0.;
		var a = 1.;
		if(a == null) {
			a = 0.;
		}
		if(b == null) {
			b = 0.;
		}
		if(g == null) {
			g = 0.;
		}
		if(r == null) {
			r = 0.;
		}
		gl.clearColor(r,g,b,a);
		gl.enable(2929);
		gl.clear(16384);
		gl.viewport(0,0,width,height);
		gl.enable(3042);
		gl.blendFunc(1,771);
		gl.enable(2929);
		var gl = this.gl;
		var program = gl.createProgram();
		var shader = gl.createShader(35633);
		gl.shaderSource(shader,"attribute vec2 vertexPosition;" + "attribute vec4 vertexColor;" + "varying vec4 vcol;" + "void main(void) {" + " gl_Position = vec4(vertexPosition, .0, 1.0);" + " vcol = vertexColor;" + "}");
		gl.compileShader(shader);
		var tmp;
		if(!gl.getShaderParameter(shader,35713)) {
			throw haxe_Exception.thrown("Error compiling shader. " + gl.getShaderInfoLog(shader));
		} else {
			tmp = shader;
		}
		gl.attachShader(program,tmp);
		var shader = gl.createShader(35632);
		gl.shaderSource(shader,"precision mediump float;" + "varying vec4 vcol;" + "void main(void) {" + "vec4 color = vec4(vcol.rgb, 1. );" + "color *= vcol.a; " + "gl_FragColor = color;" + "}");
		gl.compileShader(shader);
		var tmp;
		if(!gl.getShaderParameter(shader,35713)) {
			throw haxe_Exception.thrown("Error compiling shader. " + gl.getShaderInfoLog(shader));
		} else {
			tmp = shader;
		}
		gl.attachShader(program,tmp);
		gl.linkProgram(program);
		var tmp;
		if(!gl.getProgramParameter(program,35714)) {
			throw haxe_Exception.thrown("Error linking program. " + gl.getProgramInfoLog(program));
		} else {
			gl.validateProgram(program);
			if(!gl.getProgramParameter(program,35715)) {
				throw haxe_Exception.thrown("Error validating program. " + gl.getProgramInfoLog(program));
			} else {
				gl.useProgram(program);
				tmp = program;
			}
		}
		this.programColor = tmp;
		this.gl.bindBuffer(34962,null);
		this.gl.useProgram(this.programColor);
		var gl = this.gl;
		var program = this.programColor;
		var data = this.arr32;
		var xyName = this.vertexPosition;
		var rgbaName = this.vertexColor;
		var isDynamic = true;
		if(isDynamic == null) {
			isDynamic = false;
		}
		var isDynamic1 = isDynamic;
		if(isDynamic1 == null) {
			isDynamic1 = false;
		}
		var buf = gl.createBuffer();
		var staticDraw = 35044;
		var dynamicDraw = 35048;
		var arrayBuffer = 34962;
		gl.bindBuffer(arrayBuffer,buf);
		if(isDynamic1) {
			var arrayBuffer = 34962;
			gl.bufferData(arrayBuffer,data,dynamicDraw);
		} else {
			var arrayBuffer = 34962;
			gl.bufferData(arrayBuffer,data,staticDraw);
		}
		var vbo = buf;
		var inp = gl.getAttribLocation(program,xyName);
		var elementBytes = 4;
		var fp = 5126;
		var strideBytes = 6 * elementBytes;
		var offBytes = 0 * elementBytes;
		gl.vertexAttribPointer(inp,2,fp,false,strideBytes,offBytes);
		gl.enableVertexAttribArray(inp);
		var inp = gl.getAttribLocation(program,rgbaName);
		var elementBytes = 4;
		var fp = 5126;
		var strideBytes = 6 * elementBytes;
		var offBytes = 2 * elementBytes;
		gl.vertexAttribPointer(inp,4,fp,false,strideBytes,offBytes);
		gl.enableVertexAttribArray(inp);
		this.bufColor = vbo;
		this.gl.bindBuffer(34962,this.bufColor);
		this.gl.useProgram(this.programColor);
		this.gl.drawArrays(4,0,this.bufferLength);
	}
	,turtleStar: function() {
		var sketcher = new cornerContour_Sketcher(this.pen2D,4,0);
		if(sketcher.repeatCommands) {
			sketcher.turtleCommands.push("SET_POSITION");
			sketcher.turtleParameters.push(100);
			sketcher.turtleParameters.push(200);
		} else {
			if(sketcher.endLine == 2 || sketcher.endLine == 3) {
				sketcher.contour.end(sketcher.width);
			}
			sketcher.x = 100;
			sketcher.y = 200;
			var l = sketcher.points.length;
			sketcher.points[l] = [];
			sketcher.points[l][0] = 100;
			sketcher.points[l][1] = 200;
			sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
			sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
			sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = sketcher.dim[sketcher.dim.length - 1];
			if(100 < d.minX) {
				d.minX = 100;
			}
			if(100 > d.maxX) {
				d.maxX = 100;
			}
			if(200 < d.minY) {
				d.minY = 200;
			}
			if(200 > d.maxY) {
				d.maxY = 200;
			}
			sketcher.contour.reset();
		}
		var _this = sketcher;
		_this.width = 10;
		var _this1 = _this;
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("BLACK");
		} else {
			_this1.pen.currentColor = -16776961;
		}
		var _this = _this1;
		if(_this.repeatCommands) {
			_this.turtleCommands.push("WEST");
			_this.turtleParameters.push(_this.x);
			_this.turtleParameters.push(_this.y);
		} else {
			_this.rotation = 0;
		}
		var _this1 = _this;
		_this1.repeatCount = 6;
		_this1.repeatCommands = true;
		_this1.turtleCommands.length = 0;
		_this1.turtleParameters.length = 0;
		var _this = _this1;
		if(_this.repeatCommands) {
			_this.turtleCommands.push("FORWARD");
			_this.turtleParameters.push(300);
		} else {
			var nx = _this.x + 300 * Math.cos(_this.rotation);
			var ny = _this.y + 300 * Math.sin(_this.rotation);
			if(_this.penIsDown) {
				_this.lineTo(nx,ny);
			} else {
				if(_this.endLine == 2 || _this.endLine == 3) {
					_this.contour.end(_this.width);
				}
				_this.x = nx;
				_this.y = ny;
				var l = _this.points.length;
				_this.points[l] = [];
				_this.points[l][0] = nx;
				_this.points[l][1] = ny;
				_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
				_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
				_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this.dim[_this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this.contour.reset();
			}
		}
		var _this1 = _this;
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("RIGHT");
			_this1.turtleParameters.push(144);
		} else {
			_this1.rotation += 144 * Math.PI / 180;
		}
		var _this = _this1;
		if(_this.repeatCommands) {
			_this.turtleCommands.push("PEN_COLOR_CHANGE");
			_this.turtleParameters.push(0.09);
			_this.turtleParameters.push(0.1);
			_this.turtleParameters.push(-0.09);
		} else {
			var c = _this.pen.currentColor;
			var r0 = (c >> 16 & 255) / 255;
			var g0 = (c >> 8 & 255) / 255;
			var b0 = (c & 255) / 255;
			_this.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + 0.09) * 255) << 16 | Math.round((g0 + 0.1) * 255) << 8 | Math.round((b0 + (-0.09)) * 255);
		}
		var _this1 = _this;
		_this1.repeatCommands = false;
		var v = _this1.turtleParameters;
		var j = 0;
		haxe_Log.trace("turtleCommands" + _this1.turtleCommands.length,{ fileName : "cornerContour/Sketcher.hx", lineNumber : 527, className : "cornerContour.Sketcher", methodName : "endRepeat"});
		var _g = 0;
		var _g1 = _this1.repeatCount;
		while(_g < _g1) {
			var k = _g++;
			var _g2 = 0;
			var _g3 = _this1.turtleCommands.length;
			while(_g2 < _g3) {
				var i = _g2++;
				var command = _this1.turtleCommands[i];
				switch(command) {
				case "ARC":
					var radius = v[j];
					var degrees = v[j + 1];
					if(radius != 0) {
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("ARC");
							_this1.turtleParameters.push(radius);
							_this1.turtleParameters.push(degrees);
						} else {
							var beta = degrees * Math.PI / 180 / 24;
							var alpha = (Math.PI - beta) / 2;
							var rotate = -(Math.PI / 2 - alpha);
							var baseLength = 0.5 * radius * Math.sin(beta / 2);
							var _g4 = 0;
							while(_g4 < 48) {
								var i1 = _g4++;
								_this1.rotation += rotate;
								if(_this1.repeatCommands) {
									_this1.turtleCommands.push("FORWARD");
									_this1.turtleParameters.push(baseLength);
								} else {
									var nx = _this1.x + baseLength * Math.cos(_this1.rotation);
									var ny = _this1.y + baseLength * Math.sin(_this1.rotation);
									if(_this1.penIsDown) {
										_this1.lineTo(nx,ny);
									} else {
										if(_this1.endLine == 2 || _this1.endLine == 3) {
											_this1.contour.end(_this1.width);
										}
										_this1.x = nx;
										_this1.y = ny;
										var l = _this1.points.length;
										_this1.points[l] = [];
										_this1.points[l][0] = nx;
										_this1.points[l][1] = ny;
										_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
										_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
										_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d = _this1.dim[_this1.dim.length - 1];
										if(nx < d.minX) {
											d.minX = nx;
										}
										if(nx > d.maxX) {
											d.maxX = nx;
										}
										if(ny < d.minY) {
											d.minY = ny;
										}
										if(ny > d.maxY) {
											d.maxY = ny;
										}
										_this1.contour.reset();
									}
								}
							}
						}
					}
					j += 2;
					break;
				case "ARC_SIDES":
					var radius1 = v[j];
					var degrees1 = v[j + 1];
					var sides = v[j + 2];
					if(sides == null) {
						sides = 24;
					}
					if(radius1 != 0) {
						if(_this1.repeatCommands) {
							if(sides == 24) {
								_this1.turtleCommands.push("ARC");
								_this1.turtleParameters.push(radius1);
								_this1.turtleParameters.push(degrees1);
							} else {
								_this1.turtleCommands.push("ARC_SIDES");
								_this1.turtleParameters.push(radius1);
								_this1.turtleParameters.push(degrees1);
								_this1.turtleParameters.push(sides);
							}
						} else {
							var beta1 = degrees1 * Math.PI / 180 / sides;
							var alpha1 = (Math.PI - beta1) / 2;
							var rotate1 = -(Math.PI / 2 - alpha1);
							var baseLength1 = 0.5 * radius1 * Math.sin(beta1 / 2);
							var _g5 = 0;
							while(_g5 < 48) {
								var i2 = _g5++;
								_this1.rotation += rotate1;
								if(_this1.repeatCommands) {
									_this1.turtleCommands.push("FORWARD");
									_this1.turtleParameters.push(baseLength1);
								} else {
									var nx1 = _this1.x + baseLength1 * Math.cos(_this1.rotation);
									var ny1 = _this1.y + baseLength1 * Math.sin(_this1.rotation);
									if(_this1.penIsDown) {
										_this1.lineTo(nx1,ny1);
									} else {
										if(_this1.endLine == 2 || _this1.endLine == 3) {
											_this1.contour.end(_this1.width);
										}
										_this1.x = nx1;
										_this1.y = ny1;
										var l1 = _this1.points.length;
										_this1.points[l1] = [];
										_this1.points[l1][0] = nx1;
										_this1.points[l1][1] = ny1;
										_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
										_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
										_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d1 = _this1.dim[_this1.dim.length - 1];
										if(nx1 < d1.minX) {
											d1.minX = nx1;
										}
										if(nx1 > d1.maxX) {
											d1.maxX = nx1;
										}
										if(ny1 < d1.minY) {
											d1.minY = ny1;
										}
										if(ny1 > d1.maxY) {
											d1.maxY = ny1;
										}
										_this1.contour.reset();
									}
								}
							}
						}
					}
					j += 3;
					break;
				case "BACKWARD":
					var distance = v[j];
					var nx2 = _this1.x + distance * Math.cos(_this1.rotation + Math.PI);
					var ny2 = _this1.y + distance * Math.sin(_this1.rotation + Math.PI);
					if(_this1.penIsDown) {
						_this1.lineTo(nx2,ny2);
					} else {
						if(_this1.endLine == 2 || _this1.endLine == 3) {
							_this1.contour.end(_this1.width);
						}
						_this1.x = nx2;
						_this1.y = ny2;
						var l2 = _this1.points.length;
						_this1.points[l2] = [];
						_this1.points[l2][0] = nx2;
						_this1.points[l2][1] = ny2;
						_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
						_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
						_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d2 = _this1.dim[_this1.dim.length - 1];
						if(nx2 < d2.minX) {
							d2.minX = nx2;
						}
						if(nx2 > d2.maxX) {
							d2.maxX = nx2;
						}
						if(ny2 < d2.minY) {
							d2.minY = ny2;
						}
						if(ny2 > d2.maxY) {
							d2.maxY = ny2;
						}
						_this1.contour.reset();
					}
					++j;
					break;
				case "BLACK":
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("BLACK");
					} else {
						_this1.pen.currentColor = -16777216;
					}
					break;
				case "BLUE":
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("BLACK");
					} else {
						_this1.pen.currentColor = -16776961;
					}
					break;
				case "BROWN":
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("BROWN");
					} else {
						_this1.pen.currentColor = -6594501;
					}
					break;
				case "CIRCLE":
					var radius2 = v[j];
					if(radius2 != 0) {
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("CIRCLE");
							_this1.turtleParameters.push(radius2);
						} else {
							var beta2 = 2 * Math.PI / 24;
							var alpha2 = (Math.PI - beta2) / 2;
							var rotate2 = -(Math.PI / 2 - alpha2);
							var baseLength2 = 0.5 * radius2 * Math.sin(beta2 / 2);
							var _g6 = 0;
							while(_g6 < 48) {
								var i3 = _g6++;
								_this1.rotation += rotate2;
								if(_this1.repeatCommands) {
									_this1.turtleCommands.push("FORWARD");
									_this1.turtleParameters.push(baseLength2);
								} else {
									var nx3 = _this1.x + baseLength2 * Math.cos(_this1.rotation);
									var ny3 = _this1.y + baseLength2 * Math.sin(_this1.rotation);
									if(_this1.penIsDown) {
										_this1.lineTo(nx3,ny3);
									} else {
										if(_this1.endLine == 2 || _this1.endLine == 3) {
											_this1.contour.end(_this1.width);
										}
										_this1.x = nx3;
										_this1.y = ny3;
										var l3 = _this1.points.length;
										_this1.points[l3] = [];
										_this1.points[l3][0] = nx3;
										_this1.points[l3][1] = ny3;
										_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
										_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
										_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d3 = _this1.dim[_this1.dim.length - 1];
										if(nx3 < d3.minX) {
											d3.minX = nx3;
										}
										if(nx3 > d3.maxX) {
											d3.maxX = nx3;
										}
										if(ny3 < d3.minY) {
											d3.minY = ny3;
										}
										if(ny3 > d3.maxY) {
											d3.maxY = ny3;
										}
										_this1.contour.reset();
									}
								}
							}
						}
					}
					++j;
					break;
				case "CIRCLE_SIDES":
					var radius3 = v[j];
					var sides1 = v[j + 1];
					if(sides1 == null) {
						sides1 = 24;
					}
					if(radius3 != 0) {
						if(_this1.repeatCommands) {
							if(sides1 == 24) {
								_this1.turtleCommands.push("CIRCLE");
								_this1.turtleParameters.push(radius3);
							} else {
								_this1.turtleCommands.push("CIRCLE_SIDES");
								_this1.turtleParameters.push(radius3);
								_this1.turtleParameters.push(sides1);
							}
						} else {
							var beta3 = 2 * Math.PI / sides1;
							var alpha3 = (Math.PI - beta3) / 2;
							var rotate3 = -(Math.PI / 2 - alpha3);
							var baseLength3 = 0.5 * radius3 * Math.sin(beta3 / 2);
							var _g7 = 0;
							while(_g7 < 48) {
								var i4 = _g7++;
								_this1.rotation += rotate3;
								if(_this1.repeatCommands) {
									_this1.turtleCommands.push("FORWARD");
									_this1.turtleParameters.push(baseLength3);
								} else {
									var nx4 = _this1.x + baseLength3 * Math.cos(_this1.rotation);
									var ny4 = _this1.y + baseLength3 * Math.sin(_this1.rotation);
									if(_this1.penIsDown) {
										_this1.lineTo(nx4,ny4);
									} else {
										if(_this1.endLine == 2 || _this1.endLine == 3) {
											_this1.contour.end(_this1.width);
										}
										_this1.x = nx4;
										_this1.y = ny4;
										var l4 = _this1.points.length;
										_this1.points[l4] = [];
										_this1.points[l4][0] = nx4;
										_this1.points[l4][1] = ny4;
										_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
										_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
										_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d4 = _this1.dim[_this1.dim.length - 1];
										if(nx4 < d4.minX) {
											d4.minX = nx4;
										}
										if(nx4 > d4.maxX) {
											d4.maxX = nx4;
										}
										if(ny4 < d4.minY) {
											d4.minY = ny4;
										}
										if(ny4 > d4.maxY) {
											d4.maxY = ny4;
										}
										_this1.contour.reset();
									}
								}
							}
						}
					}
					j += 2;
					break;
				case "CYAN":
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("CYAN");
					} else {
						_this1.pen.currentColor = -16711681;
					}
					break;
				case "DARKISH_BLUE":
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("DARKISH_BLUE");
					} else {
						_this1.pen.currentColor = -8864837;
					}
					break;
				case "DARK_GREEN":
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("DARK_GREEN");
					} else {
						_this1.pen.currentColor = -10182080;
					}
					break;
				case "EAST":
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("EAST");
					} else {
						_this1.rotation = Math.PI;
					}
					break;
				case "FORWARD":
					var distance1 = v[j];
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("FORWARD");
						_this1.turtleParameters.push(distance1);
					} else {
						var nx5 = _this1.x + distance1 * Math.cos(_this1.rotation);
						var ny5 = _this1.y + distance1 * Math.sin(_this1.rotation);
						if(_this1.penIsDown) {
							_this1.lineTo(nx5,ny5);
						} else {
							if(_this1.endLine == 2 || _this1.endLine == 3) {
								_this1.contour.end(_this1.width);
							}
							_this1.x = nx5;
							_this1.y = ny5;
							var l5 = _this1.points.length;
							_this1.points[l5] = [];
							_this1.points[l5][0] = nx5;
							_this1.points[l5][1] = ny5;
							_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
							_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
							_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d5 = _this1.dim[_this1.dim.length - 1];
							if(nx5 < d5.minX) {
								d5.minX = nx5;
							}
							if(nx5 > d5.maxX) {
								d5.maxX = nx5;
							}
							if(ny5 < d5.minY) {
								d5.minY = ny5;
							}
							if(ny5 > d5.maxY) {
								d5.maxY = ny5;
							}
							_this1.contour.reset();
						}
					}
					++j;
					break;
				case "GREEN":
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("GREEN");
					} else {
						_this1.pen.currentColor = -16711936;
					}
					break;
				case "GREY":
					_this1.grey();
					break;
				case "LEFT":
					var degrees2 = v[j];
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("LEFT");
						_this1.turtleParameters.push(degrees2);
					} else {
						_this1.rotation -= degrees2 * Math.PI / 180;
					}
					++j;
					break;
				case "LIGHT_BROWN":
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("LIGHT_BROWN");
					} else {
						_this1.pen.currentColor = -3831790;
					}
					break;
				case "MAGENTA":
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("MAGENTA");
					} else {
						_this1.pen.currentColor = -65281;
					}
					break;
				case "MOVE_PEN":
					var distance2 = v[j];
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("MOVE_PEN");
						_this1.turtleParameters.push(distance2);
					} else if(_this1.penIsDown) {
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_UP");
						} else {
							_this1.penIsDown = false;
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("FORWARD");
							_this1.turtleParameters.push(distance2);
						} else {
							var nx6 = _this1.x + distance2 * Math.cos(_this1.rotation);
							var ny6 = _this1.y + distance2 * Math.sin(_this1.rotation);
							if(_this1.penIsDown) {
								_this1.lineTo(nx6,ny6);
							} else {
								if(_this1.endLine == 2 || _this1.endLine == 3) {
									_this1.contour.end(_this1.width);
								}
								_this1.x = nx6;
								_this1.y = ny6;
								var l6 = _this1.points.length;
								_this1.points[l6] = [];
								_this1.points[l6][0] = nx6;
								_this1.points[l6][1] = ny6;
								_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
								_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
								_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d6 = _this1.dim[_this1.dim.length - 1];
								if(nx6 < d6.minX) {
									d6.minX = nx6;
								}
								if(nx6 > d6.maxX) {
									d6.maxX = nx6;
								}
								if(ny6 < d6.minY) {
									d6.minY = ny6;
								}
								if(ny6 > d6.maxY) {
									d6.maxY = ny6;
								}
								_this1.contour.reset();
							}
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_DOWN");
						} else {
							_this1.penIsDown = true;
						}
					} else if(_this1.repeatCommands) {
						_this1.turtleCommands.push("FORWARD");
						_this1.turtleParameters.push(distance2);
					} else {
						var nx7 = _this1.x + distance2 * Math.cos(_this1.rotation);
						var ny7 = _this1.y + distance2 * Math.sin(_this1.rotation);
						if(_this1.penIsDown) {
							_this1.lineTo(nx7,ny7);
						} else {
							if(_this1.endLine == 2 || _this1.endLine == 3) {
								_this1.contour.end(_this1.width);
							}
							_this1.x = nx7;
							_this1.y = ny7;
							var l7 = _this1.points.length;
							_this1.points[l7] = [];
							_this1.points[l7][0] = nx7;
							_this1.points[l7][1] = ny7;
							_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
							_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
							_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d7 = _this1.dim[_this1.dim.length - 1];
							if(nx7 < d7.minX) {
								d7.minX = nx7;
							}
							if(nx7 > d7.maxX) {
								d7.maxX = nx7;
							}
							if(ny7 < d7.minY) {
								d7.minY = ny7;
							}
							if(ny7 > d7.maxY) {
								d7.maxY = ny7;
							}
							_this1.contour.reset();
						}
					}
					++j;
					break;
				case "NORTH":
					_this1.rotation = -Math.PI / 2;
					break;
				case "ORANGE":
					_this1.orange();
					break;
				case "PEN_COLOR":
					var r = v[j];
					var g = v[j + 1];
					var b = v[j + 2];
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("PEN_COLOR");
						_this1.turtleParameters.push(r);
						_this1.turtleParameters.push(g);
						_this1.turtleParameters.push(b);
					} else {
						_this1.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_B":
					var r1 = v[j];
					var g1 = v[j + 1];
					var b1 = v[j + 2];
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("PEN_COLOR_B");
						_this1.turtleParameters.push(r1);
						_this1.turtleParameters.push(g1);
						_this1.turtleParameters.push(b1);
					} else {
						_this1.pen.colorB = Math.round(255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_C":
					var r2 = v[j];
					var g2 = v[j + 1];
					var b2 = v[j + 2];
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("PEN_COLOR_C");
						_this1.turtleParameters.push(r2);
						_this1.turtleParameters.push(g2);
						_this1.turtleParameters.push(b2);
					} else {
						_this1.pen.colorC = Math.round(255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE":
					var r3 = v[j];
					var g3 = v[j + 1];
					var b3 = v[j + 2];
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("PEN_COLOR_CHANGE");
						_this1.turtleParameters.push(r3);
						_this1.turtleParameters.push(g3);
						_this1.turtleParameters.push(b3);
					} else {
						var c = _this1.pen.currentColor;
						var r0 = (c >> 16 & 255) / 255;
						var g0 = (c >> 8 & 255) / 255;
						var b0 = (c & 255) / 255;
						_this1.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r3) * 255) << 16 | Math.round((g0 + g3) * 255) << 8 | Math.round((b0 + b3) * 255);
					}
					j += 3;
					break;
				case "PEN_DOWN":
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("PEN_DOWN");
					} else {
						_this1.penIsDown = true;
					}
					break;
				case "PEN_SIZE":
					_this1.width = v[j];
					break;
				case "PEN_UP":
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("PEN_UP");
					} else {
						_this1.penIsDown = false;
					}
					break;
				case "PLUM":
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("PLUM");
					} else {
						_this1.pen.currentColor = -7310896;
					}
					break;
				case "RED":
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("RED");
					} else {
						_this1.pen.currentColor = -65536;
					}
					break;
				case "RIGHT":
					var degrees3 = v[j];
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("RIGHT");
						_this1.turtleParameters.push(degrees3);
					} else {
						_this1.rotation += degrees3 * Math.PI / 180;
					}
					++j;
					break;
				case "SET_POSITION":
					var x = v[j];
					var y = v[j + 1];
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("SET_POSITION");
						_this1.turtleParameters.push(x);
						_this1.turtleParameters.push(y);
					} else {
						if(_this1.endLine == 2 || _this1.endLine == 3) {
							_this1.contour.end(_this1.width);
						}
						_this1.x = x;
						_this1.y = y;
						var l8 = _this1.points.length;
						_this1.points[l8] = [];
						_this1.points[l8][0] = x;
						_this1.points[l8][1] = y;
						_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
						_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
						_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d8 = _this1.dim[_this1.dim.length - 1];
						if(x < d8.minX) {
							d8.minX = x;
						}
						if(x > d8.maxX) {
							d8.maxX = x;
						}
						if(y < d8.minY) {
							d8.minY = y;
						}
						if(y > d8.maxY) {
							d8.maxY = y;
						}
						_this1.contour.reset();
					}
					j += 2;
					break;
				case "SOUTH":
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("SOUTH");
					} else {
						_this1.rotation = Math.PI / 2;
					}
					break;
				case "TAN":
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("TAN");
					} else {
						_this1.pen.currentColor = -27273;
					}
					break;
				case "WEST":
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("WEST");
						_this1.turtleParameters.push(_this1.x);
						_this1.turtleParameters.push(_this1.y);
					} else {
						_this1.rotation = 0;
					}
					break;
				case "WHITE":
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("WHITE");
					} else {
						_this1.pen.currentColor = -1;
					}
					break;
				case "YELLOW":
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("YELLOW");
					} else {
						_this1.pen.currentColor = 16776960;
					}
					break;
				}
			}
			j = 0;
		}
		_this1.turtleCommands.length = 0;
		_this1.turtleParameters.length = 0;
		var _this = _this1;
		if(_this.repeatCommands) {
			_this.turtleCommands.push("BLACK");
		} else {
			_this.pen.currentColor = -16776961;
		}
	}
};
function cornerContourWebGLTest_CornerContourWebGLTurtle_main() {
	new cornerContourWebGLTest_CornerContourWebGLTurtle();
}
var cornerContourWebGLTest_DivertTrace = function(left_) {
	if(left_ == null) {
		left_ = 610;
	}
	this.textStyle1 = "<span style=\"font-size:14px; color:Grey\">";
	this.textStyle0 = "<span style=\"font-size:12px; color:Silver\">";
	this.traceString = "";
	var doc = window.document;
	this.traceDiv = doc.createElement("div");
	doc.body.appendChild(this.traceDiv);
	var dom = this.traceDiv;
	var style = dom.style;
	style.position = "absolute";
	style.top = Std.string(0 + "px");
	style.left = Std.string(left_ + "px");
	style.height = Std.string(500 + "px");
	style.width = Std.string(500 + "px");
	style.zIndex = "99";
	style.overflow = "auto";
	haxe_Log.trace = $bind(this,this.myTrace);
	window.onerror = $bind(this,this.myError);
};
cornerContourWebGLTest_DivertTrace.__name__ = true;
cornerContourWebGLTest_DivertTrace.prototype = {
	myError: function(msg,url,lineNo,columnNo,errorObj) {
		var arr = url.split("/");
		var file = arr[arr.length - 2] + " " + arr[arr.length - 1];
		var str = this.textStyle0;
		str += "ERROR: " + file + " ( " + (lineNo == null ? "null" : "" + lineNo) + ": " + (columnNo == null ? "null" : "" + columnNo) + " )";
		str += "</span>";
		str += "<br> - ";
		str += this.textStyle1;
		str += Std.string(msg);
		str += "</span>";
		str += "<br>";
		this.traceString += str;
		this.traceDiv.innerHTML = this.traceString;
		return false;
	}
	,myTrace: function(v,inf) {
		if(Std.string(v) == "") {
			return;
		}
		this.traceString += this.textStyle0 + inf.className + "." + inf.methodName + " ( " + (inf.lineNumber == null ? "null" : "" + inf.lineNumber) + " )" + "</span>" + "<br> - " + this.textStyle1 + Std.string(v) + "</span>" + "<br>";
		this.traceDiv.innerHTML = this.traceString;
	}
};
var cornerContourWebGLTest_Sheet = function() {
};
cornerContourWebGLTest_Sheet.__name__ = true;
cornerContourWebGLTest_Sheet.prototype = {
	create: function(width_,height_,autoChild) {
		if(autoChild == null) {
			autoChild = false;
		}
		if(height_ == null) {
			height_ = 600;
		}
		if(width_ == null) {
			width_ = 600;
		}
		this.width = width_;
		this.height = height_;
		this.canvasGL = window.document.createElement("canvas");
		this.canvasGL.width = this.width;
		this.canvasGL.height = this.height;
		var body = window.document.body;
		body.style.overflow = "hidden";
		body.style.position = "fixed";
		this.pixelRatio = window.devicePixelRatio;
		if(this.pixelRatio == null) {
			this.pixelRatio = 1.;
		}
		var bodyEL = window.document.body;
		var style = bodyEL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		this.domGL = this.canvasGL;
		var style = this.domGL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		if(autoChild) {
			body.appendChild(this.canvasGL);
		}
		this.canvas2D = window.document.createElement("canvas");
		this.canvas2D.width = this.width;
		this.canvas2D.height = this.height;
		this.domGL2D = this.canvasGL;
		var style = this.domGL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		if(autoChild) {
			body.appendChild(this.canvas2D);
		}
		this.gl = this.canvasGL.getContext("webgl",{ premultipliedAlpha : false});
		this.cx = this.canvas2D.getContext("2d");
	}
};
var fracs_DifferencePreference = $hxEnums["fracs.DifferencePreference"] = { __ename__:true,__constructs__:null
	,CLOCKWISE: {_hx_name:"CLOCKWISE",_hx_index:0,__enum__:"fracs.DifferencePreference",toString:$estr}
	,ANTICLOCKWISE: {_hx_name:"ANTICLOCKWISE",_hx_index:1,__enum__:"fracs.DifferencePreference",toString:$estr}
	,SMALL: {_hx_name:"SMALL",_hx_index:2,__enum__:"fracs.DifferencePreference",toString:$estr}
	,LARGE: {_hx_name:"LARGE",_hx_index:3,__enum__:"fracs.DifferencePreference",toString:$estr}
};
fracs_DifferencePreference.__constructs__ = [fracs_DifferencePreference.CLOCKWISE,fracs_DifferencePreference.ANTICLOCKWISE,fracs_DifferencePreference.SMALL,fracs_DifferencePreference.LARGE];
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = true;
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	get_native: function() {
		return this.__nativeException;
	}
});
var haxe_Log = function() { };
haxe_Log.__name__ = true;
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
});
var haxe_ds_Either = $hxEnums["haxe.ds.Either"] = { __ename__:true,__constructs__:null
	,Left: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.ds.Either",toString:$estr}; },$_._hx_name="Left",$_.__params__ = ["v"],$_)
	,Right: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"haxe.ds.Either",toString:$estr}; },$_._hx_name="Right",$_.__params__ = ["v"],$_)
};
haxe_ds_Either.__constructs__ = [haxe_ds_Either.Left,haxe_ds_Either.Right];
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
String.__name__ = true;
Array.__name__ = true;
js_Boot.__toStr = ({ }).toString;
cornerContourWebGLTest_CornerContourWebGLTurtle_main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
