// Generated by Haxe 4.3.0-rc.1+5f599ba
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var cornerContour_Contour = function(pen_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.count = 0;
	this.pointsAnti = [];
	this.pointsClock = [];
	this.pen = pen_;
	this.endLine = endLine_;
};
cornerContour_Contour.__name__ = true;
cornerContour_Contour.prototype = {
	reset: function() {
		this.angleA = 0;
		this.count = 0;
		this.kax = 0;
		this.kay = 0;
		this.kbx = 0;
		this.kby = 0;
		this.kcx = 0;
		this.kcy = 0;
		this.ncx = 0;
		this.ncy = 0;
		this.ax = 0;
		this.ay = 0;
		this.bx = 0;
		this.by = 0;
		this.cx = 0;
		this.cy = 0;
		this.dx = null;
		this.dy = null;
		this.ex = null;
		this.ey = null;
		this.pointsClock.length = 0;
		this.pointsAnti.length = 0;
	}
	,triangleJoin: function(ax_,ay_,bx_,by_,width_,curveEnds,overlap) {
		if(overlap == null) {
			overlap = false;
		}
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = this.dx != null ? this.angle1 : null;
		this.halfA = Math.PI / 2;
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var x = this.dxOld - bx_;
		var y = this.dyOld - by_;
		var x1 = this.exOld - bx_;
		var y1 = this.eyOld - by_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(this.ay - this.dyOld,this.ax - this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.eyPrev,this.ax - this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(this.ay - this.eyOld,this.ax - this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.dyPrev,this.ax - this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(fracs_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		if(!overlap && this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f = theta0;
			} else {
				var a = (theta0 + Math.PI) % (2 * Math.PI);
				f = a >= 0 ? a - Math.PI : a + Math.PI;
			}
			var this1 = f;
			var start = this1;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			this.jx = this.ax + h * Math.sin(delta);
			this.jy = this.ay + h * Math.cos(delta);
		}
		if(this.count == 0 && (this.endLine == 1 || this.endLine == 3)) {
			var ax = this.ax;
			var ay = this.ay;
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif1;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 > 0 ? dif2 : 2 * Math.PI + dif2;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = smallest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = largest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif1 >= 0;
			var totalSteps = Math.ceil(Math.abs(dif1) / step);
			var step = dif1 / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[i * 2 + len + 1];
				this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(overlap) {
			this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,-1);
			this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
		} else {
			if(this.count != 0) {
				this.addQuads(clockWise,width_);
			}
			this.quadIndex = this.pen.get_pos();
			if(this.count == 0) {
				this.penultimateAX = this.dxPrev;
				this.penultimateAY = this.dyPrev;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.penultimateCX = this.dx;
				this.penultimateCY = this.dy;
				this.lastClockX = this.exPrev;
				this.lastClockY = this.eyPrev;
				this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,-1);
				this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
			} else {
				if(clockWise && !this.lastClock) {
					this.penultimateAX = this.jx;
					this.penultimateAY = this.jy;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.exPrev;
					this.lastClockY = this.eyPrev;
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,-1);
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
				}
				if(clockWise && this.lastClock) {
					this.penultimateAX = this.jx;
					this.penultimateAY = this.jy;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.exPrev;
					this.lastClockY = this.eyPrev;
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,-1);
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
				}
				if(!clockWise && !this.lastClock) {
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.jx;
					this.lastClockY = this.jy;
					this.penultimateAX = this.dxPrev;
					this.penultimateAY = this.dyPrev;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.jx,this.jy,-1);
					this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,-1);
				}
				if(!clockWise && this.lastClock) {
					this.penultimateAX = this.dxPrev;
					this.penultimateAY = this.dyPrev;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.jx;
					this.penultimateCY = this.jy;
					this.lastClockX = this.dx;
					this.lastClockY = this.dy;
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,-1);
					this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.jx,this.jy,this.ex,this.ey,-1);
				}
			}
		}
		if(curveEnds) {
			if(clockWise) {
				var radius = width_ / 2;
				var edgePoly = this.pointsClock;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						var color_ = -1;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
					}
					angle += step;
					bx = cx;
					by = cy;
				}
			} else {
				var radius = width_ / 2;
				var edgePoly = this.pointsAnti;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						var color_ = -1;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
					}
					angle += step;
					bx = cx;
					by = cy;
				}
			}
		} else if(this.count != 0) {
			if(overlap) {
				if(clockWise) {
					this.pen.triangle2DFill(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.ax,this.ay,-1);
				} else {
					this.pen.triangle2DFill(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.ax,this.ay,-1);
				}
			} else if(clockWise) {
				this.pen.triangle2DFill(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.jx,this.jy,-1);
			} else {
				this.pen.triangle2DFill(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.jx,this.jy,-1);
			}
		}
		this.kax = this.dxPrev;
		this.kay = this.dyPrev;
		this.kbx = this.dx;
		this.kby = this.dy;
		this.ncx = this.exPrev;
		this.ncy = this.eyPrev;
		this.kcx = this.ex;
		this.kcy = this.ey;
		if(curveEnds && !overlap && this.count != 0) {
			if(clockWise) {
				this.pen.triangle2DFill(this.ax,this.ay,this.dxOld,this.dyOld,this.jx,this.jy,-1);
				this.pen.triangle2DFill(this.ax,this.ay,this.exPrev,this.eyPrev,this.jx,this.jy,-1);
			} else {
				this.pen.triangle2DFill(this.ax,this.ay,this.exOld,this.eyOld,this.jx,this.jy,-1);
				this.pen.triangle2DFill(this.ax,this.ay,this.dxPrev,this.dyPrev,this.jx,this.jy,-1);
			}
		}
		this.jxOld = this.jx;
		this.jyOld = this.jy;
		this.lastClock = clockWise;
		this.count++;
	}
	,end: function(width_) {
		this.endEdges();
		if(this.count != 0) {
			var ax = this.bx;
			var ay = this.by;
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var temp = [];
			var color = 0;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var _g = 0;
			var _g1 = len + 2;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[i];
			}
			var pC = this.pointsClock.length;
			var _g = 1;
			var _g1 = len / 2 + 1 | 0;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[temp.length - 2 * i];
				this.pointsClock[pC++] = temp[temp.length - 2 * i - 1];
			}
		}
	}
	,endEdges: function() {
		var pC = this.pointsClock.length;
		var pA = this.pointsAnti.length;
		this.pointsClock[pC++] = this.penultimateCX;
		this.pointsClock[pC++] = this.penultimateCY;
		this.pointsClock[pC++] = this.lastClockX;
		this.pointsClock[pC++] = this.lastClockY;
		this.pointsAnti[pA++] = this.penultimateAX;
		this.pointsAnti[pA++] = this.penultimateAY;
		this.pointsAnti[pA++] = this.lastAntiX;
		this.pointsAnti[pA++] = this.lastAntiY;
	}
	,addQuads: function(clockWise,width_) {
		var currQuadIndex = this.pen.get_pos();
		var pC = 0;
		var pA = 0;
		if(clockWise && !this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.jxOld,this.jyOld,-1);
			}
			this.pen.set_pos(this.quadIndex);
			this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.jx,this.jy,-1);
		}
		if(clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				this.pointsAnti[pA++] = this.kbx;
				this.pointsAnti[pA++] = this.kby;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kax;
				this.pointsClock[pC++] = this.kay;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.jx,this.jy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.kbx,this.kby,this.jx,this.jy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.kbx,this.kby,this.ncx,this.ncy,-1);
			}
		}
		if(!clockWise && !this.lastClock) {
			this.pen.set_pos(this.quadIndex);
			this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.kcx,this.kcy,-1);
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.jxOld,this.jyOld,-1);
			}
		}
		if(!clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.kcx,this.kcy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.jx,this.jy,this.kcx,this.kcy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.jx,this.jy,this.ncx,this.ncy,-1);
			}
		}
		this.pen.set_pos(currQuadIndex);
	}
	,line: function(ax_,ay_,bx_,by_,width_,endLineCurve) {
		if(endLineCurve == null) {
			endLineCurve = 0;
		}
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.halfA = Math.PI / 2;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var dxPrev_ = this.dx;
		var dyPrev_ = this.dy;
		var exPrev_ = this.ex;
		var eyPrev_ = this.ey;
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		switch(endLineCurve) {
		case 0:
			break;
		case 1:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = 0;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 2:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = 0;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 3:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = 0;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = 0;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		}
		this.pen.triangle2DFill(dxPrev_,dyPrev_,this.dx,this.dy,exPrev_,eyPrev_,-1);
		this.pen.triangle2DFill(dxPrev_,dyPrev_,this.dx,this.dy,this.ex,this.ey,-1);
	}
};
var cornerContour_Pen2D = function(col) {
	var this1 = [];
	this1[0] = 0.;
	this.arr = this1;
	this.currentColor = col;
};
cornerContour_Pen2D.__name__ = true;
cornerContour_Pen2D.prototype = {
	get_pos: function() {
		return this.arr[0];
	}
	,set_pos: function(val) {
		this.arr[0] = val;
		return val;
	}
	,triangle2DFill: function(ax,ay,bx,by,cx,cy,color) {
		if(color == null || color == -1) {
			color = this.currentColor;
		}
		var this1 = this.arr;
		cornerContour_io_Array2DTriangles.triangle(this1,ax,ay,bx,by,cx,cy);
		if(color == null) {
			cornerContour_io_Array2DTriangles.set_colorInt(this1,16711680);
		} else {
			cornerContour_io_Array2DTriangles.set_colorInt(this1,color);
		}
		var pos_ = this.arr[0] + 1;
		this.arr[0] = pos_;
		return 1;
	}
};
var cornerContour_Sketcher = function(pen_,sketchForm_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.historyParameters = [];
	this.historyCommands = [];
	this.historyParamPos = [];
	this.turtleParameters = [];
	this.turtleCommands = [];
	this.repeatCommands = false;
	this.repeatCount = 0;
	this.fill = false;
	this.lastDistance = 0.;
	this.rotation = 0.;
	this.penIsDown = true;
	this.width = 0.01;
	this.y = 0.;
	this.x = 0.;
	this.rotation = -Math.PI / 2;
	this.pen = pen_;
	this.endLine = endLine_;
	this.contour = this.createContour();
	this.sketchForm = sketchForm_;
	switch(sketchForm_) {
	case 0:
		this.line = $bind(this,this.tracerLine);
		break;
	case 1:
		this.line = $bind(this,this.baseLine);
		break;
	case 2:
		this.line = $bind(this,this.crudeLine);
		break;
	case 3:
		this.line = $bind(this,this.fillOnlyLine);
		break;
	case 4:
		this.line = $bind(this,this.fineLine);
		break;
	case 5:
		this.line = $bind(this,this.fineOverlapLine);
		break;
	case 6:
		this.line = $bind(this,this.mediumLine);
		break;
	case 7:
		this.line = $bind(this,this.mediumOverlapLine);
		break;
	case 8:
		this.line = $bind(this,this.roundEndLine);
		break;
	}
	this.points = [];
	this.pointsClock = [];
	this.pointsAnti = [];
	this.points[0] = [];
	this.dim = [];
};
cornerContour_Sketcher.__name__ = true;
cornerContour_Sketcher.prototype = {
	tracerLine: function(x_,y_) {
		haxe_Log.trace("lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )",{ fileName : "cornerContour/Sketcher.hx", lineNumber : 30, className : "cornerContour.Sketcher", methodName : "tracerLine"});
	}
	,fillOnlyLine: function(x_,y_) {
	}
	,baseLine: function(x_,y_) {
		haxe_Log.trace("lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )",{ fileName : "cornerContour/Sketcher.hx", lineNumber : 30, className : "cornerContour.Sketcher", methodName : "tracerLine"});
		this.contour.line(this.x,this.y,x_,y_,this.width);
	}
	,crudeLine: function(x_,y_) {
		this.contour.line(this.x,this.y,x_,y_,this.width);
	}
	,roundEndLine: function(x_,y_) {
		this.contour.line(this.x,this.y,x_,y_,this.width,3);
	}
	,mediumLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,false);
	}
	,mediumOverlapLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,false,true);
	}
	,fineLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,true);
	}
	,fineOverlapLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,true,true);
	}
	,createContour: function() {
		return new cornerContour_Contour(this.pen,this.endLine);
	}
	,lineTo: function(x_,y_) {
		var repeat = this.x == x_ && this.y == y_;
		if(!repeat) {
			if(this.widthFunction != null) {
				this.width = this.widthFunction(this.width,this.x,this.y,x_,y_);
			}
			if(this.colourFunction != null) {
				this.pen.currentColor = this.colourFunction(this.pen.currentColor,this.x,this.y,x_,y_);
			}
			this.line(x_,y_);
			var l = this.points.length;
			var p = this.points[l - 1];
			var l2 = p.length;
			p[l2] = x_;
			p[l2 + 1] = y_;
			var d = this.dim[this.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			this.x = x_;
			this.y = y_;
		}
	}
	,traceHistory: function() {
		haxe_Log.trace(this.historyCommands,{ fileName : "cornerContour/Sketcher.hx", lineNumber : 315, className : "cornerContour.Sketcher", methodName : "traceHistory"});
		haxe_Log.trace(this.historyParameters,{ fileName : "cornerContour/Sketcher.hx", lineNumber : 316, className : "cornerContour.Sketcher", methodName : "traceHistory"});
	}
	,historyAdd: function(command) {
		this.historyParamPos.push(this.historyParameters.length);
		this.historyCommands.push(command);
		return this.historyParameters.length;
	}
	,playHistory: function(start,end) {
		if(end == null) {
			end = -1;
		}
		if(start == null) {
			start = 0;
		}
		this.playCommands(this.historyCommands,this.historyParameters,start,end);
	}
	,playCommands: function(commands,parameters,start,end) {
		if(end == null) {
			end = -1;
		}
		if(start == null) {
			start = 0;
		}
		if(end == -1) {
			end = commands.length;
		}
		var v = parameters;
		var j = this.historyParamPos[start];
		this.turtleHistoryOn = false;
		var _g = start;
		var _g1 = end;
		while(_g < _g1) {
			var i = _g++;
			var command = commands[i];
			switch(command) {
			case "ARC":
				var radius = v[j];
				var degrees = v[j + 1];
				if(this.turtleHistoryOn) {
					this.historyAdd("ARC");
					this.historyParameters.push(radius);
					this.historyParameters.push(degrees);
				}
				if(radius != 0) {
					if(this.repeatCommands) {
						this.turtleCommands.push("ARC");
						this.turtleParameters.push(radius);
						this.turtleParameters.push(degrees);
					} else {
						var beta = degrees * Math.PI / 180 / 24;
						var alpha = (Math.PI - beta) / 2;
						var rotate = -(Math.PI / 2 - alpha);
						var baseLength = 0.5 * radius * Math.sin(beta / 2);
						var ox = this.x;
						var oy = this.y;
						var arr = [];
						arr.push(this.x);
						arr.push(this.y);
						var _g2 = 0;
						while(_g2 < 48) {
							var i1 = _g2++;
							this.rotation += rotate;
							var wasHistoryOn = this.turtleHistoryOn;
							this.turtleHistoryOn = false;
							if(this.turtleHistoryOn) {
								this.historyAdd("FORWARD");
								this.historyParameters.push(baseLength);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FORWARD");
								this.turtleParameters.push(baseLength);
							} else {
								var nx = this.x + baseLength * Math.cos(this.rotation);
								var ny = this.y + baseLength * Math.sin(this.rotation);
								if(this.penIsDown) {
									this.lastDistance = baseLength;
									this.lineTo(nx,ny);
								} else {
									if(this.endLine == 2 || this.endLine == 3) {
										this.contour.end(this.width);
									}
									this.x = nx;
									this.y = ny;
									var l = this.points.length;
									this.points[l] = [];
									this.points[l][0] = nx;
									this.points[l][1] = ny;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d = this.dim[this.dim.length - 1];
									if(nx < d.minX) {
										d.minX = nx;
									}
									if(nx > d.maxX) {
										d.maxX = nx;
									}
									if(ny < d.minY) {
										d.minY = ny;
									}
									if(ny > d.maxY) {
										d.maxY = ny;
									}
									this.contour.reset();
								}
							}
							this.turtleHistoryOn = wasHistoryOn;
							if(this.fill) {
								arr.push(this.x);
								arr.push(this.y);
							}
						}
						if(this.fill) {
							var cx = (ox + arr[arr.length - 2]) / 2;
							var cy = (oy + arr[arr.length - 1]) / 2;
							var l1 = arr.length;
							var i2 = 2;
							var lx = 0.;
							var ly = 0.;
							this.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
							while(i2 < l1) {
								if(i2 > 2) {
									this.pen.triangle2DFill(lx,ly,arr[i2],arr[i2 + 1],cx,cy);
								}
								lx = arr[i2];
								ly = arr[i2 + 1];
								i2 += 2;
							}
						}
						arr.length = 0;
					}
				}
				j += 2;
				break;
			case "ARCH_BEZIER":
				var distance = v[j];
				var distance2 = v[j + 1];
				var radius1 = v[j + 2];
				if(this.turtleHistoryOn) {
					this.historyAdd("ARCH_BEZIER");
					this.historyParameters.push(distance);
					this.historyParameters.push(distance2);
					this.historyParameters.push(radius1);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("ARCH_BEZIER");
					this.turtleParameters.push(distance);
					this.turtleParameters.push(distance2);
					this.turtleParameters.push(radius1);
				} else {
					var nx1 = this.x + distance * Math.cos(this.rotation);
					var ny1 = this.y + distance * Math.sin(this.rotation);
					if(this.penIsDown) {
						var thruX = this.x + distance2 * Math.cos(this.rotation) - radius1 * Math.cos(this.rotation + Math.PI / 2);
						var thruY = this.y + distance2 * Math.sin(this.rotation) - radius1 * Math.sin(this.rotation + Math.PI / 2);
						var newx = 2 * thruX - 0.5 * (this.x + nx1);
						var newy = 2 * thruY - 0.5 * (this.y + ny1);
						this.tempArr = [];
						var p = this.tempArr;
						var ax = this.x;
						var ay = this.y;
						var x = ax - newx;
						var y = ay - newy;
						var x1 = newx - nx1;
						var y1 = newy - ny1;
						var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
						if(approxDistance == 0) {
							approxDistance = 0.000001;
						}
						var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
						var l2 = p.length;
						p[l2++] = ax;
						p[l2++] = ay;
						var t = step;
						while(t < 1.) {
							var u = 1 - t;
							p[l2++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx1;
							var u1 = 1 - t;
							p[l2++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny1;
							t += step;
						}
						p[l2++] = nx1;
						p[l2++] = ny1;
						var arr1 = this.tempArr;
						var withMove = false;
						if(withMove == null) {
							withMove = true;
						}
						var l3 = arr1.length;
						var i3 = 2;
						if(withMove) {
							var x_ = arr1[0];
							var y_ = arr1[1];
							if(this.endLine == 2 || this.endLine == 3) {
								this.contour.end(this.width);
							}
							this.x = x_;
							this.y = y_;
							var l4 = this.points.length;
							this.points[l4] = [];
							this.points[l4][0] = x_;
							this.points[l4][1] = y_;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d1 = this.dim[this.dim.length - 1];
							if(x_ < d1.minX) {
								d1.minX = x_;
							}
							if(x_ > d1.maxX) {
								d1.maxX = x_;
							}
							if(y_ < d1.minY) {
								d1.minY = y_;
							}
							if(y_ > d1.maxY) {
								d1.maxY = y_;
							}
							this.contour.reset();
						} else {
							this.lineTo(arr1[0],arr1[1]);
						}
						var cx1 = (arr1[0] + arr1[l3 - 2]) / 2;
						var cy1 = (arr1[1] + arr1[l3 - 1]) / 2;
						var ox1 = this.x;
						var oy1 = this.y;
						while(i3 < l3) {
							if(this.fill && this.penIsDown) {
								if(i3 > 0 && i3 < l3 - 2) {
									this.pen.triangle2DFill(arr1[i3 - 2],arr1[i3 - 1],arr1[i3],arr1[i3 + 1],cx1,cy1);
								}
							}
							this.lineTo(arr1[i3],arr1[i3 + 1]);
							i3 += 2;
						}
						if(this.fill && this.penIsDown) {
							if(this.endLine == 2 || this.endLine == 3) {
								this.contour.end(this.width);
							}
							this.x = ox1;
							this.y = oy1;
							var l5 = this.points.length;
							this.points[l5] = [];
							this.points[l5][0] = ox1;
							this.points[l5][1] = oy1;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d2 = this.dim[this.dim.length - 1];
							if(ox1 < d2.minX) {
								d2.minX = ox1;
							}
							if(ox1 > d2.maxX) {
								d2.maxX = ox1;
							}
							if(oy1 < d2.minY) {
								d2.minY = oy1;
							}
							if(oy1 > d2.maxY) {
								d2.maxY = oy1;
							}
							this.contour.reset();
							this.lineTo(arr1[l3 - 2],arr1[l3 - 1]);
						}
						this.x = nx1;
						this.y = ny1;
					} else {
						if(this.endLine == 2 || this.endLine == 3) {
							this.contour.end(this.width);
						}
						this.x = nx1;
						this.y = ny1;
						var l6 = this.points.length;
						this.points[l6] = [];
						this.points[l6][0] = nx1;
						this.points[l6][1] = ny1;
						this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
						this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
						this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d3 = this.dim[this.dim.length - 1];
						if(nx1 < d3.minX) {
							d3.minX = nx1;
						}
						if(nx1 > d3.maxX) {
							d3.maxX = nx1;
						}
						if(ny1 < d3.minY) {
							d3.minY = ny1;
						}
						if(ny1 > d3.maxY) {
							d3.maxY = ny1;
						}
						this.contour.reset();
					}
				}
				j += 3;
				break;
			case "ARC_SIDES":
				var radius2 = v[j];
				var degrees1 = v[j + 1];
				var sides = v[j + 2];
				if(sides == null) {
					sides = 24;
				}
				if(this.turtleHistoryOn) {
					if(sides == 24) {
						this.historyAdd("ARC");
						this.historyParameters.push(radius2);
						this.historyParameters.push(degrees1);
					} else {
						this.historyAdd("ARC_SIDES");
						this.historyParameters.push(radius2);
						this.historyParameters.push(degrees1);
						this.historyParameters.push(sides);
					}
				}
				if(radius2 != 0) {
					if(this.repeatCommands) {
						if(sides == 24) {
							this.turtleCommands.push("ARC");
							this.turtleParameters.push(radius2);
							this.turtleParameters.push(degrees1);
						} else {
							this.turtleCommands.push("ARC_SIDES");
							this.turtleParameters.push(radius2);
							this.turtleParameters.push(degrees1);
							this.turtleParameters.push(sides);
						}
					} else {
						var beta1 = degrees1 * Math.PI / 180 / sides;
						var alpha1 = (Math.PI - beta1) / 2;
						var rotate1 = -(Math.PI / 2 - alpha1);
						var baseLength1 = 0.5 * radius2 * Math.sin(beta1 / 2);
						var ox2 = this.x;
						var oy2 = this.y;
						var arr2 = [];
						arr2.push(this.x);
						arr2.push(this.y);
						var _g3 = 0;
						while(_g3 < 48) {
							var i4 = _g3++;
							this.rotation += rotate1;
							var wasHistoryOn1 = this.turtleHistoryOn;
							this.turtleHistoryOn = false;
							if(this.turtleHistoryOn) {
								this.historyAdd("FORWARD");
								this.historyParameters.push(baseLength1);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FORWARD");
								this.turtleParameters.push(baseLength1);
							} else {
								var nx2 = this.x + baseLength1 * Math.cos(this.rotation);
								var ny2 = this.y + baseLength1 * Math.sin(this.rotation);
								if(this.penIsDown) {
									this.lastDistance = baseLength1;
									this.lineTo(nx2,ny2);
								} else {
									if(this.endLine == 2 || this.endLine == 3) {
										this.contour.end(this.width);
									}
									this.x = nx2;
									this.y = ny2;
									var l7 = this.points.length;
									this.points[l7] = [];
									this.points[l7][0] = nx2;
									this.points[l7][1] = ny2;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d4 = this.dim[this.dim.length - 1];
									if(nx2 < d4.minX) {
										d4.minX = nx2;
									}
									if(nx2 > d4.maxX) {
										d4.maxX = nx2;
									}
									if(ny2 < d4.minY) {
										d4.minY = ny2;
									}
									if(ny2 > d4.maxY) {
										d4.maxY = ny2;
									}
									this.contour.reset();
								}
							}
							this.turtleHistoryOn = wasHistoryOn1;
							if(this.fill) {
								arr2.push(this.x);
								arr2.push(this.y);
							}
						}
						if(this.fill) {
							var cx2 = (ox2 + arr2[arr2.length - 2]) / 2;
							var cy2 = (oy2 + arr2[arr2.length - 1]) / 2;
							var l8 = arr2.length;
							var i5 = 2;
							var lx1 = 0.;
							var ly1 = 0.;
							this.pen.triangle2DFill(ox2,oy2,arr2[0],arr2[1],cx2,cy2);
							while(i5 < l8) {
								if(i5 > 2) {
									this.pen.triangle2DFill(lx1,ly1,arr2[i5],arr2[i5 + 1],cx2,cy2);
								}
								lx1 = arr2[i5];
								ly1 = arr2[i5 + 1];
								i5 += 2;
							}
						}
						arr2.length = 0;
					}
				}
				j += 3;
				break;
			case "BACKWARD":
				var distance1 = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("BACKWARD");
					this.historyParameters.push(distance1);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("BACKWARD");
					this.turtleParameters.push(distance1);
				} else {
					var nx3 = this.x + distance1 * Math.cos(this.rotation + Math.PI);
					var ny3 = this.y + distance1 * Math.sin(this.rotation + Math.PI);
					if(this.penIsDown) {
						this.lineTo(nx3,ny3);
					} else {
						if(this.endLine == 2 || this.endLine == 3) {
							this.contour.end(this.width);
						}
						this.x = nx3;
						this.y = ny3;
						var l9 = this.points.length;
						this.points[l9] = [];
						this.points[l9][0] = nx3;
						this.points[l9][1] = ny3;
						this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
						this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
						this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d5 = this.dim[this.dim.length - 1];
						if(nx3 < d5.minX) {
							d5.minX = nx3;
						}
						if(nx3 > d5.maxX) {
							d5.maxX = nx3;
						}
						if(ny3 < d5.minY) {
							d5.minY = ny3;
						}
						if(ny3 > d5.maxY) {
							d5.maxY = ny3;
						}
						this.contour.reset();
					}
				}
				++j;
				break;
			case "BEGIN_REPEAT":
				var repeatCount_ = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("BEGIN_REPEAT");
					this.historyParameters.push(Math.round(repeatCount_));
				}
				if(this.repeatCommands == true) {
					this.repeatCommands = false;
					if(this.turtleHistoryOn) {
						this.historyAdd("END_REPEAT");
					}
					var wasHistoryOn2 = this.turtleHistoryOn;
					this.turtleHistoryOn = false;
					var v1 = this.turtleParameters;
					var j1 = 0;
					var _g4 = 0;
					var _g5 = this.repeatCount;
					while(_g4 < _g5) {
						var k = _g4++;
						var _g6 = 0;
						var _g7 = this.turtleCommands.length;
						while(_g6 < _g7) {
							var i6 = _g6++;
							var command1 = this.turtleCommands[i6];
							switch(command1) {
							case "ARC":
								var radius3 = v1[j1];
								var degrees2 = v1[j1 + 1];
								if(this.turtleHistoryOn) {
									this.historyAdd("ARC");
									this.historyParameters.push(radius3);
									this.historyParameters.push(degrees2);
								}
								if(radius3 != 0) {
									if(this.repeatCommands) {
										this.turtleCommands.push("ARC");
										this.turtleParameters.push(radius3);
										this.turtleParameters.push(degrees2);
									} else {
										var beta2 = degrees2 * Math.PI / 180 / 24;
										var alpha2 = (Math.PI - beta2) / 2;
										var rotate2 = -(Math.PI / 2 - alpha2);
										var baseLength2 = 0.5 * radius3 * Math.sin(beta2 / 2);
										var ox3 = this.x;
										var oy3 = this.y;
										var arr3 = [];
										arr3.push(this.x);
										arr3.push(this.y);
										var _g8 = 0;
										while(_g8 < 48) {
											var i7 = _g8++;
											this.rotation += rotate2;
											var wasHistoryOn3 = this.turtleHistoryOn;
											this.turtleHistoryOn = false;
											if(this.turtleHistoryOn) {
												this.historyAdd("FORWARD");
												this.historyParameters.push(baseLength2);
											}
											if(this.repeatCommands) {
												this.turtleCommands.push("FORWARD");
												this.turtleParameters.push(baseLength2);
											} else {
												var nx4 = this.x + baseLength2 * Math.cos(this.rotation);
												var ny4 = this.y + baseLength2 * Math.sin(this.rotation);
												if(this.penIsDown) {
													this.lastDistance = baseLength2;
													this.lineTo(nx4,ny4);
												} else {
													if(this.endLine == 2 || this.endLine == 3) {
														this.contour.end(this.width);
													}
													this.x = nx4;
													this.y = ny4;
													var l10 = this.points.length;
													this.points[l10] = [];
													this.points[l10][0] = nx4;
													this.points[l10][1] = ny4;
													this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
													this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
													this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
													var d6 = this.dim[this.dim.length - 1];
													if(nx4 < d6.minX) {
														d6.minX = nx4;
													}
													if(nx4 > d6.maxX) {
														d6.maxX = nx4;
													}
													if(ny4 < d6.minY) {
														d6.minY = ny4;
													}
													if(ny4 > d6.maxY) {
														d6.maxY = ny4;
													}
													this.contour.reset();
												}
											}
											this.turtleHistoryOn = wasHistoryOn3;
											if(this.fill) {
												arr3.push(this.x);
												arr3.push(this.y);
											}
										}
										if(this.fill) {
											var cx3 = (ox3 + arr3[arr3.length - 2]) / 2;
											var cy3 = (oy3 + arr3[arr3.length - 1]) / 2;
											var l11 = arr3.length;
											var i8 = 2;
											var lx2 = 0.;
											var ly2 = 0.;
											this.pen.triangle2DFill(ox3,oy3,arr3[0],arr3[1],cx3,cy3);
											while(i8 < l11) {
												if(i8 > 2) {
													this.pen.triangle2DFill(lx2,ly2,arr3[i8],arr3[i8 + 1],cx3,cy3);
												}
												lx2 = arr3[i8];
												ly2 = arr3[i8 + 1];
												i8 += 2;
											}
										}
										arr3.length = 0;
									}
								}
								j1 += 2;
								break;
							case "ARCH_BEZIER":
								var distance3 = v1[j1];
								var distance21 = v1[j1 + 1];
								var radius4 = v1[j1 + 2];
								if(this.turtleHistoryOn) {
									this.historyAdd("ARCH_BEZIER");
									this.historyParameters.push(distance3);
									this.historyParameters.push(distance21);
									this.historyParameters.push(radius4);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("ARCH_BEZIER");
									this.turtleParameters.push(distance3);
									this.turtleParameters.push(distance21);
									this.turtleParameters.push(radius4);
								} else {
									var nx5 = this.x + distance3 * Math.cos(this.rotation);
									var ny5 = this.y + distance3 * Math.sin(this.rotation);
									if(this.penIsDown) {
										var thruX1 = this.x + distance21 * Math.cos(this.rotation) - radius4 * Math.cos(this.rotation + Math.PI / 2);
										var thruY1 = this.y + distance21 * Math.sin(this.rotation) - radius4 * Math.sin(this.rotation + Math.PI / 2);
										var newx1 = 2 * thruX1 - 0.5 * (this.x + nx5);
										var newy1 = 2 * thruY1 - 0.5 * (this.y + ny5);
										this.tempArr = [];
										var p1 = this.tempArr;
										var ax1 = this.x;
										var ay1 = this.y;
										var x2 = ax1 - newx1;
										var y2 = ay1 - newy1;
										var x3 = newx1 - nx5;
										var y3 = newy1 - ny5;
										var approxDistance1 = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3);
										if(approxDistance1 == 0) {
											approxDistance1 = 0.000001;
										}
										var step1 = Math.min(1 / (approxDistance1 * 0.707),cornerContour_CurveMath_quadStep);
										var l12 = p1.length;
										p1[l12++] = ax1;
										p1[l12++] = ay1;
										var t1 = step1;
										while(t1 < 1.) {
											var u2 = 1 - t1;
											p1[l12++] = Math.pow(u2,2) * ax1 + 2 * u2 * t1 * newx1 + Math.pow(t1,2) * nx5;
											var u3 = 1 - t1;
											p1[l12++] = Math.pow(u3,2) * ay1 + 2 * u3 * t1 * newy1 + Math.pow(t1,2) * ny5;
											t1 += step1;
										}
										p1[l12++] = nx5;
										p1[l12++] = ny5;
										var arr4 = this.tempArr;
										var withMove1 = false;
										if(withMove1 == null) {
											withMove1 = true;
										}
										var l13 = arr4.length;
										var i9 = 2;
										if(withMove1) {
											var x_1 = arr4[0];
											var y_1 = arr4[1];
											if(this.endLine == 2 || this.endLine == 3) {
												this.contour.end(this.width);
											}
											this.x = x_1;
											this.y = y_1;
											var l14 = this.points.length;
											this.points[l14] = [];
											this.points[l14][0] = x_1;
											this.points[l14][1] = y_1;
											this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
											this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
											this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d7 = this.dim[this.dim.length - 1];
											if(x_1 < d7.minX) {
												d7.minX = x_1;
											}
											if(x_1 > d7.maxX) {
												d7.maxX = x_1;
											}
											if(y_1 < d7.minY) {
												d7.minY = y_1;
											}
											if(y_1 > d7.maxY) {
												d7.maxY = y_1;
											}
											this.contour.reset();
										} else {
											this.lineTo(arr4[0],arr4[1]);
										}
										var cx4 = (arr4[0] + arr4[l13 - 2]) / 2;
										var cy4 = (arr4[1] + arr4[l13 - 1]) / 2;
										var ox4 = this.x;
										var oy4 = this.y;
										while(i9 < l13) {
											if(this.fill && this.penIsDown) {
												if(i9 > 0 && i9 < l13 - 2) {
													this.pen.triangle2DFill(arr4[i9 - 2],arr4[i9 - 1],arr4[i9],arr4[i9 + 1],cx4,cy4);
												}
											}
											this.lineTo(arr4[i9],arr4[i9 + 1]);
											i9 += 2;
										}
										if(this.fill && this.penIsDown) {
											if(this.endLine == 2 || this.endLine == 3) {
												this.contour.end(this.width);
											}
											this.x = ox4;
											this.y = oy4;
											var l15 = this.points.length;
											this.points[l15] = [];
											this.points[l15][0] = ox4;
											this.points[l15][1] = oy4;
											this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
											this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
											this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d8 = this.dim[this.dim.length - 1];
											if(ox4 < d8.minX) {
												d8.minX = ox4;
											}
											if(ox4 > d8.maxX) {
												d8.maxX = ox4;
											}
											if(oy4 < d8.minY) {
												d8.minY = oy4;
											}
											if(oy4 > d8.maxY) {
												d8.maxY = oy4;
											}
											this.contour.reset();
											this.lineTo(arr4[l13 - 2],arr4[l13 - 1]);
										}
										this.x = nx5;
										this.y = ny5;
									} else {
										if(this.endLine == 2 || this.endLine == 3) {
											this.contour.end(this.width);
										}
										this.x = nx5;
										this.y = ny5;
										var l16 = this.points.length;
										this.points[l16] = [];
										this.points[l16][0] = nx5;
										this.points[l16][1] = ny5;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d9 = this.dim[this.dim.length - 1];
										if(nx5 < d9.minX) {
											d9.minX = nx5;
										}
										if(nx5 > d9.maxX) {
											d9.maxX = nx5;
										}
										if(ny5 < d9.minY) {
											d9.minY = ny5;
										}
										if(ny5 > d9.maxY) {
											d9.maxY = ny5;
										}
										this.contour.reset();
									}
								}
								j1 += 3;
								break;
							case "ARC_SIDES":
								var radius5 = v1[j1];
								var degrees3 = v1[j1 + 1];
								var sides1 = v1[j1 + 2];
								if(sides1 == null) {
									sides1 = 24;
								}
								if(this.turtleHistoryOn) {
									if(sides1 == 24) {
										this.historyAdd("ARC");
										this.historyParameters.push(radius5);
										this.historyParameters.push(degrees3);
									} else {
										this.historyAdd("ARC_SIDES");
										this.historyParameters.push(radius5);
										this.historyParameters.push(degrees3);
										this.historyParameters.push(sides1);
									}
								}
								if(radius5 != 0) {
									if(this.repeatCommands) {
										if(sides1 == 24) {
											this.turtleCommands.push("ARC");
											this.turtleParameters.push(radius5);
											this.turtleParameters.push(degrees3);
										} else {
											this.turtleCommands.push("ARC_SIDES");
											this.turtleParameters.push(radius5);
											this.turtleParameters.push(degrees3);
											this.turtleParameters.push(sides1);
										}
									} else {
										var beta3 = degrees3 * Math.PI / 180 / sides1;
										var alpha3 = (Math.PI - beta3) / 2;
										var rotate3 = -(Math.PI / 2 - alpha3);
										var baseLength3 = 0.5 * radius5 * Math.sin(beta3 / 2);
										var ox5 = this.x;
										var oy5 = this.y;
										var arr5 = [];
										arr5.push(this.x);
										arr5.push(this.y);
										var _g9 = 0;
										while(_g9 < 48) {
											var i10 = _g9++;
											this.rotation += rotate3;
											var wasHistoryOn4 = this.turtleHistoryOn;
											this.turtleHistoryOn = false;
											if(this.turtleHistoryOn) {
												this.historyAdd("FORWARD");
												this.historyParameters.push(baseLength3);
											}
											if(this.repeatCommands) {
												this.turtleCommands.push("FORWARD");
												this.turtleParameters.push(baseLength3);
											} else {
												var nx6 = this.x + baseLength3 * Math.cos(this.rotation);
												var ny6 = this.y + baseLength3 * Math.sin(this.rotation);
												if(this.penIsDown) {
													this.lastDistance = baseLength3;
													this.lineTo(nx6,ny6);
												} else {
													if(this.endLine == 2 || this.endLine == 3) {
														this.contour.end(this.width);
													}
													this.x = nx6;
													this.y = ny6;
													var l17 = this.points.length;
													this.points[l17] = [];
													this.points[l17][0] = nx6;
													this.points[l17][1] = ny6;
													this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
													this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
													this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
													var d10 = this.dim[this.dim.length - 1];
													if(nx6 < d10.minX) {
														d10.minX = nx6;
													}
													if(nx6 > d10.maxX) {
														d10.maxX = nx6;
													}
													if(ny6 < d10.minY) {
														d10.minY = ny6;
													}
													if(ny6 > d10.maxY) {
														d10.maxY = ny6;
													}
													this.contour.reset();
												}
											}
											this.turtleHistoryOn = wasHistoryOn4;
											if(this.fill) {
												arr5.push(this.x);
												arr5.push(this.y);
											}
										}
										if(this.fill) {
											var cx5 = (ox5 + arr5[arr5.length - 2]) / 2;
											var cy5 = (oy5 + arr5[arr5.length - 1]) / 2;
											var l18 = arr5.length;
											var i11 = 2;
											var lx3 = 0.;
											var ly3 = 0.;
											this.pen.triangle2DFill(ox5,oy5,arr5[0],arr5[1],cx5,cy5);
											while(i11 < l18) {
												if(i11 > 2) {
													this.pen.triangle2DFill(lx3,ly3,arr5[i11],arr5[i11 + 1],cx5,cy5);
												}
												lx3 = arr5[i11];
												ly3 = arr5[i11 + 1];
												i11 += 2;
											}
										}
										arr5.length = 0;
									}
								}
								j1 += 3;
								break;
							case "BACKWARD":
								var distance4 = v1[j1];
								if(this.turtleHistoryOn) {
									this.historyAdd("BACKWARD");
									this.historyParameters.push(distance4);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("BACKWARD");
									this.turtleParameters.push(distance4);
								} else {
									var nx7 = this.x + distance4 * Math.cos(this.rotation + Math.PI);
									var ny7 = this.y + distance4 * Math.sin(this.rotation + Math.PI);
									if(this.penIsDown) {
										this.lineTo(nx7,ny7);
									} else {
										if(this.endLine == 2 || this.endLine == 3) {
											this.contour.end(this.width);
										}
										this.x = nx7;
										this.y = ny7;
										var l19 = this.points.length;
										this.points[l19] = [];
										this.points[l19][0] = nx7;
										this.points[l19][1] = ny7;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d11 = this.dim[this.dim.length - 1];
										if(nx7 < d11.minX) {
											d11.minX = nx7;
										}
										if(nx7 > d11.maxX) {
											d11.maxX = nx7;
										}
										if(ny7 < d11.minY) {
											d11.minY = ny7;
										}
										if(ny7 > d11.maxY) {
											d11.maxY = ny7;
										}
										this.contour.reset();
									}
								}
								++j1;
								break;
							case "BEGIN_REPEAT":
								break;
							case "BLACK":
								if(this.turtleHistoryOn) {
									this.historyAdd("BLACK");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("BLACK");
								} else {
									this.pen.currentColor = -16777216;
								}
								break;
							case "BLUE":
								if(this.turtleHistoryOn) {
									this.historyAdd("BLUE");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("BLUE");
								} else {
									this.pen.currentColor = -16776961;
								}
								break;
							case "BROWN":
								if(this.turtleHistoryOn) {
									this.historyAdd("BROWN");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("BROWN");
								} else {
									this.pen.currentColor = -6594501;
								}
								break;
							case "CIRCLE":
								var radius6 = v1[j1];
								if(this.turtleHistoryOn) {
									this.historyAdd("CIRCLE");
									this.historyParameters.push(radius6);
								}
								if(radius6 != 0) {
									if(this.repeatCommands) {
										this.turtleCommands.push("CIRCLE");
										this.turtleParameters.push(radius6);
									} else {
										var beta4 = 2 * Math.PI / 24;
										var alpha4 = (Math.PI - beta4) / 2;
										var rotate4 = -(Math.PI / 2 - alpha4);
										var baseLength4 = 0.5 * radius6 * Math.sin(beta4 / 2);
										var ox6 = this.x;
										var oy6 = this.y;
										var arr6 = [];
										var _g10 = 0;
										while(_g10 < 48) {
											var i12 = _g10++;
											this.rotation += rotate4;
											var wasHistoryOn5 = this.turtleHistoryOn;
											this.turtleHistoryOn = false;
											if(this.turtleHistoryOn) {
												this.historyAdd("FORWARD");
												this.historyParameters.push(baseLength4);
											}
											if(this.repeatCommands) {
												this.turtleCommands.push("FORWARD");
												this.turtleParameters.push(baseLength4);
											} else {
												var nx8 = this.x + baseLength4 * Math.cos(this.rotation);
												var ny8 = this.y + baseLength4 * Math.sin(this.rotation);
												if(this.penIsDown) {
													this.lastDistance = baseLength4;
													this.lineTo(nx8,ny8);
												} else {
													if(this.endLine == 2 || this.endLine == 3) {
														this.contour.end(this.width);
													}
													this.x = nx8;
													this.y = ny8;
													var l20 = this.points.length;
													this.points[l20] = [];
													this.points[l20][0] = nx8;
													this.points[l20][1] = ny8;
													this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
													this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
													this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
													var d12 = this.dim[this.dim.length - 1];
													if(nx8 < d12.minX) {
														d12.minX = nx8;
													}
													if(nx8 > d12.maxX) {
														d12.maxX = nx8;
													}
													if(ny8 < d12.minY) {
														d12.minY = ny8;
													}
													if(ny8 > d12.maxY) {
														d12.maxY = ny8;
													}
													this.contour.reset();
												}
											}
											this.turtleHistoryOn = wasHistoryOn5;
											if(this.fill) {
												arr6.push(this.x);
												arr6.push(this.y);
											}
										}
										if(this.fill) {
											var cx6 = (ox6 + arr6[arr6.length - 2]) / 2;
											var cy6 = (oy6 + arr6[arr6.length - 1]) / 2;
											var l21 = arr6.length;
											var i13 = 2;
											var lx4 = 0.;
											var ly4 = 0.;
											while(i13 < l21) {
												if(i13 > 2) {
													this.pen.triangle2DFill(lx4,ly4,arr6[i13],arr6[i13 + 1],cx6,cy6);
												}
												lx4 = arr6[i13];
												ly4 = arr6[i13 + 1];
												i13 += 2;
											}
										}
										arr6.length = 0;
									}
								}
								++j1;
								break;
							case "CIRCLE_SIDES":
								var radius7 = v1[j1];
								var sides2 = v1[j1 + 1];
								if(sides2 == null) {
									sides2 = 24;
								}
								if(this.turtleHistoryOn) {
									if(sides2 == 24) {
										this.historyAdd("CIRCLE");
										this.historyParameters.push(radius7);
									} else {
										this.historyAdd("CIRCLE_SIDES");
										this.historyParameters.push(radius7);
										this.historyParameters.push(sides2);
									}
								}
								if(radius7 != 0) {
									if(this.repeatCommands) {
										if(sides2 == 24) {
											this.turtleCommands.push("CIRCLE");
											this.turtleParameters.push(radius7);
										} else {
											this.turtleCommands.push("CIRCLE_SIDES");
											this.turtleParameters.push(radius7);
											this.turtleParameters.push(sides2);
										}
									} else {
										var beta5 = 2 * Math.PI / sides2;
										var alpha5 = (Math.PI - beta5) / 2;
										var rotate5 = -(Math.PI / 2 - alpha5);
										var baseLength5 = 0.5 * radius7 * Math.sin(beta5 / 2);
										var ox7 = this.x;
										var oy7 = this.y;
										var arr7 = [];
										var _g11 = 0;
										while(_g11 < 48) {
											var i14 = _g11++;
											this.rotation += rotate5;
											var wasHistoryOn6 = this.turtleHistoryOn;
											this.turtleHistoryOn = false;
											if(this.turtleHistoryOn) {
												this.historyAdd("FORWARD");
												this.historyParameters.push(baseLength5);
											}
											if(this.repeatCommands) {
												this.turtleCommands.push("FORWARD");
												this.turtleParameters.push(baseLength5);
											} else {
												var nx9 = this.x + baseLength5 * Math.cos(this.rotation);
												var ny9 = this.y + baseLength5 * Math.sin(this.rotation);
												if(this.penIsDown) {
													this.lastDistance = baseLength5;
													this.lineTo(nx9,ny9);
												} else {
													if(this.endLine == 2 || this.endLine == 3) {
														this.contour.end(this.width);
													}
													this.x = nx9;
													this.y = ny9;
													var l22 = this.points.length;
													this.points[l22] = [];
													this.points[l22][0] = nx9;
													this.points[l22][1] = ny9;
													this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
													this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
													this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
													var d13 = this.dim[this.dim.length - 1];
													if(nx9 < d13.minX) {
														d13.minX = nx9;
													}
													if(nx9 > d13.maxX) {
														d13.maxX = nx9;
													}
													if(ny9 < d13.minY) {
														d13.minY = ny9;
													}
													if(ny9 > d13.maxY) {
														d13.maxY = ny9;
													}
													this.contour.reset();
												}
											}
											this.turtleHistoryOn = wasHistoryOn6;
											if(this.fill) {
												arr7.push(this.x);
												arr7.push(this.y);
											}
										}
										if(this.fill) {
											var cx7 = (ox7 + arr7[arr7.length - 2]) / 2;
											var cy7 = (oy7 + arr7[arr7.length - 1]) / 2;
											var l23 = arr7.length;
											var i15 = 2;
											var lx5 = 0.;
											var ly5 = 0.;
											while(i15 < l23) {
												if(i15 > 2) {
													this.pen.triangle2DFill(lx5,ly5,arr7[i15],arr7[i15 + 1],cx7,cy7);
												}
												lx5 = arr7[i15];
												ly5 = arr7[i15 + 1];
												i15 += 2;
											}
										}
										arr7.length = 0;
									}
								}
								j1 += 2;
								break;
							case "CYAN":
								if(this.turtleHistoryOn) {
									this.historyAdd("CYAN");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("CYAN");
								} else {
									this.pen.currentColor = -16711681;
								}
								break;
							case "DARKISH_BLUE":
								if(this.turtleHistoryOn) {
									this.historyAdd("DARKISH_BLUE");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("DARKISH_BLUE");
								} else {
									this.pen.currentColor = -8864837;
								}
								break;
							case "DARK_GREEN":
								if(this.turtleHistoryOn) {
									this.historyAdd("DARK_GREEN");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("DARK_GREEN");
								} else {
									this.pen.currentColor = -10182080;
								}
								break;
							case "EAST":
								if(this.turtleHistoryOn) {
									this.historyAdd("WEST");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("EAST");
								} else {
									this.rotation = Math.PI;
								}
								break;
							case "END_REPEAT":
								break;
							case "FILL_OFF":
								if(this.turtleHistoryOn) {
									this.historyAdd("FILL_OFF");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FILL_OFF");
								} else {
									this.fill = false;
								}
								break;
							case "FILL_ON":
								if(this.turtleHistoryOn) {
									this.historyAdd("FILL_ON");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FILL_ON");
								} else {
									this.fill = true;
								}
								break;
							case "FORWARD":
								var distance5 = v1[j1];
								if(this.turtleHistoryOn) {
									this.historyAdd("FORWARD");
									this.historyParameters.push(distance5);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FORWARD");
									this.turtleParameters.push(distance5);
								} else {
									var nx10 = this.x + distance5 * Math.cos(this.rotation);
									var ny10 = this.y + distance5 * Math.sin(this.rotation);
									if(this.penIsDown) {
										this.lastDistance = distance5;
										this.lineTo(nx10,ny10);
									} else {
										if(this.endLine == 2 || this.endLine == 3) {
											this.contour.end(this.width);
										}
										this.x = nx10;
										this.y = ny10;
										var l24 = this.points.length;
										this.points[l24] = [];
										this.points[l24][0] = nx10;
										this.points[l24][1] = ny10;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d14 = this.dim[this.dim.length - 1];
										if(nx10 < d14.minX) {
											d14.minX = nx10;
										}
										if(nx10 > d14.maxX) {
											d14.maxX = nx10;
										}
										if(ny10 < d14.minY) {
											d14.minY = ny10;
										}
										if(ny10 > d14.maxY) {
											d14.maxY = ny10;
										}
										this.contour.reset();
									}
								}
								++j1;
								break;
							case "FORWARD_CHANGE":
								var deltaDistance = v1[j1];
								if(this.turtleHistoryOn) {
									this.historyAdd("FORWARD_CHANGE");
									this.historyParameters.push(deltaDistance);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FORWARD_CHANGE");
									this.turtleParameters.push(deltaDistance);
								} else {
									var distance6 = this.lastDistance + deltaDistance;
									var nx11 = this.x + distance6 * Math.cos(this.rotation);
									var ny11 = this.y + distance6 * Math.sin(this.rotation);
									if(this.penIsDown) {
										this.lastDistance = distance6 + deltaDistance;
										this.lineTo(nx11,ny11);
									} else {
										if(this.endLine == 2 || this.endLine == 3) {
											this.contour.end(this.width);
										}
										this.x = nx11;
										this.y = ny11;
										var l25 = this.points.length;
										this.points[l25] = [];
										this.points[l25][0] = nx11;
										this.points[l25][1] = ny11;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d15 = this.dim[this.dim.length - 1];
										if(nx11 < d15.minX) {
											d15.minX = nx11;
										}
										if(nx11 > d15.maxX) {
											d15.maxX = nx11;
										}
										if(ny11 < d15.minY) {
											d15.minY = ny11;
										}
										if(ny11 > d15.maxY) {
											d15.maxY = ny11;
										}
										this.contour.reset();
									}
								}
								++j1;
								break;
							case "FORWARD_FACTOR":
								var factor = v1[j1];
								if(this.turtleHistoryOn) {
									this.historyAdd("FORWARD_FACTOR");
									this.historyParameters.push(factor);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FORWARD_FACTOR");
									this.turtleParameters.push(factor);
								} else {
									var distance7 = this.lastDistance * factor;
									var nx12 = this.x + distance7 * Math.cos(this.rotation);
									var ny12 = this.y + distance7 * Math.sin(this.rotation);
									if(this.penIsDown) {
										this.lastDistance = distance7;
										this.lineTo(nx12,ny12);
									} else {
										if(this.endLine == 2 || this.endLine == 3) {
											this.contour.end(this.width);
										}
										this.x = nx12;
										this.y = ny12;
										var l26 = this.points.length;
										this.points[l26] = [];
										this.points[l26][0] = nx12;
										this.points[l26][1] = ny12;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d16 = this.dim[this.dim.length - 1];
										if(nx12 < d16.minX) {
											d16.minX = nx12;
										}
										if(nx12 > d16.maxX) {
											d16.maxX = nx12;
										}
										if(ny12 < d16.minY) {
											d16.minY = ny12;
										}
										if(ny12 > d16.maxY) {
											d16.maxY = ny12;
										}
										this.contour.reset();
									}
								}
								++j1;
								break;
							case "GREEN":
								if(this.turtleHistoryOn) {
									this.historyAdd("GREEN");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("GREEN");
								} else {
									this.pen.currentColor = -16711936;
								}
								break;
							case "GREY":
								if(this.turtleHistoryOn) {
									this.historyAdd("GREY");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("GREY");
								} else {
									this.pen.currentColor = -4737097;
								}
								break;
							case "LEFT":
								var degrees4 = v1[j1];
								if(this.turtleHistoryOn) {
									this.historyAdd("LEFT");
									this.historyParameters.push(degrees4);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("LEFT");
									this.turtleParameters.push(degrees4);
								} else {
									this.rotation -= degrees4 * Math.PI / 180;
								}
								++j1;
								break;
							case "LIGHT_BROWN":
								if(this.turtleHistoryOn) {
									this.historyAdd("LIGHT_BROWN");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("LIGHT_BROWN");
								} else {
									this.pen.currentColor = -3831790;
								}
								break;
							case "MAGENTA":
								if(this.turtleHistoryOn) {
									this.historyAdd("MAGENTA");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("MAGENTA");
								} else {
									this.pen.currentColor = -65281;
								}
								break;
							case "MOVE_PEN":
								var distance8 = v1[j1];
								if(this.repeatCommands) {
									this.turtleCommands.push("MOVE_PEN");
									this.turtleParameters.push(distance8);
								} else if(this.penIsDown) {
									if(this.turtleHistoryOn) {
										this.historyAdd("PEN_UP");
									}
									if(this.repeatCommands) {
										this.turtleCommands.push("PEN_UP");
									} else {
										this.penIsDown = false;
									}
									if(this.turtleHistoryOn) {
										this.historyAdd("FORWARD");
										this.historyParameters.push(distance8);
									}
									if(this.repeatCommands) {
										this.turtleCommands.push("FORWARD");
										this.turtleParameters.push(distance8);
									} else {
										var nx13 = this.x + distance8 * Math.cos(this.rotation);
										var ny13 = this.y + distance8 * Math.sin(this.rotation);
										if(this.penIsDown) {
											this.lastDistance = distance8;
											this.lineTo(nx13,ny13);
										} else {
											if(this.endLine == 2 || this.endLine == 3) {
												this.contour.end(this.width);
											}
											this.x = nx13;
											this.y = ny13;
											var l27 = this.points.length;
											this.points[l27] = [];
											this.points[l27][0] = nx13;
											this.points[l27][1] = ny13;
											this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
											this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
											this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d17 = this.dim[this.dim.length - 1];
											if(nx13 < d17.minX) {
												d17.minX = nx13;
											}
											if(nx13 > d17.maxX) {
												d17.maxX = nx13;
											}
											if(ny13 < d17.minY) {
												d17.minY = ny13;
											}
											if(ny13 > d17.maxY) {
												d17.maxY = ny13;
											}
											this.contour.reset();
										}
									}
									if(this.turtleHistoryOn) {
										this.historyAdd("PEN_DOWN");
									}
									if(this.repeatCommands) {
										this.turtleCommands.push("PEN_DOWN");
									} else {
										this.penIsDown = true;
									}
								} else {
									if(this.turtleHistoryOn) {
										this.historyAdd("FORWARD");
										this.historyParameters.push(distance8);
									}
									if(this.repeatCommands) {
										this.turtleCommands.push("FORWARD");
										this.turtleParameters.push(distance8);
									} else {
										var nx14 = this.x + distance8 * Math.cos(this.rotation);
										var ny14 = this.y + distance8 * Math.sin(this.rotation);
										if(this.penIsDown) {
											this.lastDistance = distance8;
											this.lineTo(nx14,ny14);
										} else {
											if(this.endLine == 2 || this.endLine == 3) {
												this.contour.end(this.width);
											}
											this.x = nx14;
											this.y = ny14;
											var l28 = this.points.length;
											this.points[l28] = [];
											this.points[l28][0] = nx14;
											this.points[l28][1] = ny14;
											this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
											this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
											this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d18 = this.dim[this.dim.length - 1];
											if(nx14 < d18.minX) {
												d18.minX = nx14;
											}
											if(nx14 > d18.maxX) {
												d18.maxX = nx14;
											}
											if(ny14 < d18.minY) {
												d18.minY = ny14;
											}
											if(ny14 > d18.maxY) {
												d18.maxY = ny14;
											}
											this.contour.reset();
										}
									}
								}
								++j1;
								break;
							case "NORTH":
								if(this.turtleHistoryOn) {
									this.historyAdd("NORTH");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("NORTH");
								} else {
									this.rotation = -Math.PI / 2;
								}
								break;
							case "ORANGE":
								if(this.turtleHistoryOn) {
									this.historyAdd("ORANGE");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("ORANGE");
								} else {
									this.pen.currentColor = -23808;
								}
								break;
							case "PEN_COLOR":
								var r = v1[j1];
								var g = v1[j1 + 1];
								var b = v1[j1 + 2];
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_COLOR");
									this.historyParameters.push(r);
									this.historyParameters.push(g);
									this.historyParameters.push(b);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_COLOR");
									this.turtleParameters.push(r);
									this.turtleParameters.push(g);
									this.turtleParameters.push(b);
								} else {
									this.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
								}
								j1 += 3;
								break;
							case "PEN_COLOR_B":
								var r1 = v1[j1];
								var g1 = v1[j1 + 1];
								var b1 = v1[j1 + 2];
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_COLOR_B");
									this.historyParameters.push(r1);
									this.historyParameters.push(g1);
									this.historyParameters.push(b1);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_COLOR_B");
									this.turtleParameters.push(r1);
									this.turtleParameters.push(g1);
									this.turtleParameters.push(b1);
								} else {
									this.pen.colorB = Math.round(255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
								}
								j1 += 3;
								break;
							case "PEN_COLOR_C":
								var r2 = v1[j1];
								var g2 = v1[j1 + 1];
								var b2 = v1[j1 + 2];
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_COLOR_C");
									this.historyParameters.push(r2);
									this.historyParameters.push(g2);
									this.historyParameters.push(b2);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_COLOR_C");
									this.turtleParameters.push(r2);
									this.turtleParameters.push(g2);
									this.turtleParameters.push(b2);
								} else {
									this.pen.colorC = Math.round(255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
								}
								j1 += 3;
								break;
							case "PEN_COLOR_CHANGE":
								var r3 = v1[j1];
								var g3 = v1[j1 + 1];
								var b3 = v1[j1 + 2];
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_COLOR_CHANGE");
									this.historyParameters.push(r3);
									this.historyParameters.push(g3);
									this.historyParameters.push(b3);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_COLOR_CHANGE");
									this.turtleParameters.push(r3);
									this.turtleParameters.push(g3);
									this.turtleParameters.push(b3);
								} else {
									var c = this.pen.currentColor;
									var r0 = (c >> 16 & 255) / 255;
									var g0 = (c >> 8 & 255) / 255;
									var b0 = (c & 255) / 255;
									this.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r3) * 255) << 16 | Math.round((g0 + g3) * 255) << 8 | Math.round((b0 + b3) * 255);
								}
								j1 += 3;
								break;
							case "PEN_COLOR_CHANGE_B":
								var r4 = v1[j1];
								var g4 = v1[j1 + 1];
								var b4 = v1[j1 + 2];
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_COLOR_CHANGE_B");
									this.historyParameters.push(r4);
									this.historyParameters.push(g4);
									this.historyParameters.push(b4);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_COLOR_CHANGE_B");
									this.turtleParameters.push(r4);
									this.turtleParameters.push(g4);
									this.turtleParameters.push(b4);
								} else {
									var c1 = this.pen.colorB;
									var r01 = (c1 >> 16 & 255) / 255;
									var g01 = (c1 >> 8 & 255) / 255;
									var b01 = (c1 & 255) / 255;
									this.pen.colorB = Math.round(255) << 24 | Math.round((r01 + r4) * 255) << 16 | Math.round((g01 + g4) * 255) << 8 | Math.round((b01 + b4) * 255);
								}
								j1 += 3;
								break;
							case "PEN_COLOR_CHANGE_C":
								var r5 = v1[j1];
								var g5 = v1[j1 + 1];
								var b5 = v1[j1 + 2];
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_COLOR_CHANGE_C");
									this.historyParameters.push(r5);
									this.historyParameters.push(g5);
									this.historyParameters.push(b5);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_COLOR_CHANGE_C");
									this.turtleParameters.push(r5);
									this.turtleParameters.push(g5);
									this.turtleParameters.push(b5);
								} else {
									var c2 = this.pen.colorC;
									var r02 = (c2 >> 16 & 255) / 255;
									var g02 = (c2 >> 8 & 255) / 255;
									var b02 = (c2 & 255) / 255;
									this.pen.colorC = Math.round(255) << 24 | Math.round((r02 + r5) * 255) << 16 | Math.round((g02 + g5) * 255) << 8 | Math.round((b02 + b5) * 255);
								}
								j1 += 3;
								break;
							case "PEN_DOWN":
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_DOWN");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_DOWN");
								} else {
									this.penIsDown = true;
								}
								break;
							case "PEN_SIZE":
								var w = v1[j1];
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_SIZE");
									this.historyParameters.push(w);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_SIZE");
									this.turtleParameters.push(w);
								} else {
									this.width = w;
								}
								++j1;
								break;
							case "PEN_SIZE_CHANGE":
								var dw = v1[j1];
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_SIZE_CHANGE");
									this.historyParameters.push(dw);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_SIZE_CHANGE");
									this.turtleParameters.push(dw);
								} else {
									this.width += dw;
								}
								++j1;
								break;
							case "PEN_SIZE_FACTOR":
								var factor1 = v1[j1];
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_SIZE_FACTOR");
									this.historyParameters.push(factor1);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_SIZE_FACTOR");
									this.turtleParameters.push(factor1);
								} else {
									this.width *= factor1;
								}
								++j1;
								break;
							case "PEN_UP":
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_UP");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_UP");
								} else {
									this.penIsDown = false;
								}
								break;
							case "PLUM":
								if(this.turtleHistoryOn) {
									this.historyAdd("PLUM");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PLUM");
								} else {
									this.pen.currentColor = -7310896;
								}
								break;
							case "RED":
								if(this.turtleHistoryOn) {
									this.historyAdd("RED");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("RED");
								} else {
									this.pen.currentColor = -65536;
								}
								break;
							case "RIGHT":
								var degrees5 = v1[j1];
								if(this.turtleHistoryOn) {
									this.historyAdd("RIGHT");
									this.historyParameters.push(degrees5);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("RIGHT");
									this.turtleParameters.push(degrees5);
								} else {
									this.rotation += degrees5 * Math.PI / 180;
								}
								++j1;
								break;
							case "SET_ANGLE":
								var degrees6 = v1[j1];
								if(this.turtleHistoryOn) {
									this.historyAdd("SET_ANGLE");
									this.historyParameters.push(degrees6);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("SET_ANGLE");
									this.turtleParameters.push(degrees6);
								} else {
									this.rotation = -Math.PI / 2;
									this.rotation += degrees6 * Math.PI / 180;
								}
								++j1;
								break;
							case "SET_POSITION":
								var x4 = v1[j1];
								var y4 = v1[j1 + 1];
								if(this.turtleHistoryOn) {
									this.historyAdd("SET_POSITION");
									this.historyParameters.push(x4);
									this.historyParameters.push(y4);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("SET_POSITION");
									this.turtleParameters.push(x4);
									this.turtleParameters.push(y4);
								} else {
									if(this.endLine == 2 || this.endLine == 3) {
										this.contour.end(this.width);
									}
									this.x = x4;
									this.y = y4;
									var l29 = this.points.length;
									this.points[l29] = [];
									this.points[l29][0] = x4;
									this.points[l29][1] = y4;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d19 = this.dim[this.dim.length - 1];
									if(x4 < d19.minX) {
										d19.minX = x4;
									}
									if(x4 > d19.maxX) {
										d19.maxX = x4;
									}
									if(y4 < d19.minY) {
										d19.minY = y4;
									}
									if(y4 > d19.maxY) {
										d19.maxY = y4;
									}
									this.contour.reset();
								}
								j1 += 2;
								break;
							case "SOUTH":
								if(this.turtleHistoryOn) {
									this.historyAdd("SOUTH");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("SOUTH");
								} else {
									this.rotation = Math.PI / 2;
								}
								break;
							case "TAN":
								if(this.turtleHistoryOn) {
									this.historyAdd("TAN");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("TAN");
								} else {
									this.pen.currentColor = -27273;
								}
								break;
							case "TRIANGLE_ARCH":
								var distance9 = v1[j1];
								var distance22 = v1[j1 + 1];
								var radius8 = v1[j1 + 2];
								if(this.turtleHistoryOn) {
									this.historyAdd("TRIANGLE_ARCH");
									this.historyParameters.push(distance9);
									this.historyParameters.push(distance22);
									this.historyParameters.push(radius8);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("TRIANGLE_ARCH");
									this.turtleParameters.push(distance9);
									this.turtleParameters.push(distance22);
									this.turtleParameters.push(radius8);
								} else {
									var nx15 = this.x + distance9 * Math.cos(this.rotation);
									var ny15 = this.y + distance9 * Math.sin(this.rotation);
									if(this.penIsDown) {
										var thruX2 = this.x + distance22 * Math.cos(this.rotation) - radius8 * Math.cos(this.rotation + Math.PI / 2);
										var thruY2 = this.y + distance22 * Math.sin(this.rotation) - radius8 * Math.sin(this.rotation + Math.PI / 2);
										if(this.fill) {
											this.pen.triangle2DFill(this.x,this.y,thruX2,thruY2,nx15,ny15);
										}
										this.lineTo(thruX2,thruY2);
										this.lineTo(nx15,ny15);
										if(this.fill) {
											this.lineTo(this.x,this.y);
										}
										if(this.endLine == 2 || this.endLine == 3) {
											this.contour.end(this.width);
										}
										this.x = nx15;
										this.y = ny15;
										var l30 = this.points.length;
										this.points[l30] = [];
										this.points[l30][0] = nx15;
										this.points[l30][1] = ny15;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d20 = this.dim[this.dim.length - 1];
										if(nx15 < d20.minX) {
											d20.minX = nx15;
										}
										if(nx15 > d20.maxX) {
											d20.maxX = nx15;
										}
										if(ny15 < d20.minY) {
											d20.minY = ny15;
										}
										if(ny15 > d20.maxY) {
											d20.maxY = ny15;
										}
										this.contour.reset();
									} else {
										if(this.endLine == 2 || this.endLine == 3) {
											this.contour.end(this.width);
										}
										this.x = nx15;
										this.y = ny15;
										var l31 = this.points.length;
										this.points[l31] = [];
										this.points[l31][0] = nx15;
										this.points[l31][1] = ny15;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d21 = this.dim[this.dim.length - 1];
										if(nx15 < d21.minX) {
											d21.minX = nx15;
										}
										if(nx15 > d21.maxX) {
											d21.maxX = nx15;
										}
										if(ny15 < d21.minY) {
											d21.minY = ny15;
										}
										if(ny15 > d21.maxY) {
											d21.maxY = ny15;
										}
										this.contour.reset();
									}
								}
								j1 += 3;
								break;
							case "WEST":
								if(this.turtleHistoryOn) {
									this.historyAdd("WEST");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("WEST");
								} else {
									this.rotation = 0;
								}
								break;
							case "WHITE":
								if(this.turtleHistoryOn) {
									this.historyAdd("WHITE");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("WHITE");
								} else {
									this.pen.currentColor = -1;
								}
								break;
							case "YELLOW":
								if(this.turtleHistoryOn) {
									this.historyAdd("YELLOW");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("YELLOW");
								} else {
									this.pen.currentColor = -256;
								}
								break;
							}
						}
						j1 = 0;
					}
					this.turtleHistoryOn = wasHistoryOn2;
					this.turtleCommands.length = 0;
					this.turtleParameters.length = 0;
				}
				if(repeatCount_ > 0) {
					this.repeatCount = Math.round(repeatCount_);
					this.repeatCommands = true;
					this.turtleCommands.length = 0;
					this.turtleParameters.length = 0;
				}
				++j;
				break;
			case "BLACK":
				if(this.turtleHistoryOn) {
					this.historyAdd("BLACK");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("BLACK");
				} else {
					this.pen.currentColor = -16777216;
				}
				break;
			case "BLUE":
				if(this.turtleHistoryOn) {
					this.historyAdd("BLUE");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("BLUE");
				} else {
					this.pen.currentColor = -16776961;
				}
				break;
			case "BROWN":
				if(this.turtleHistoryOn) {
					this.historyAdd("BROWN");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("BROWN");
				} else {
					this.pen.currentColor = -6594501;
				}
				break;
			case "CIRCLE":
				var radius9 = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("CIRCLE");
					this.historyParameters.push(radius9);
				}
				if(radius9 != 0) {
					if(this.repeatCommands) {
						this.turtleCommands.push("CIRCLE");
						this.turtleParameters.push(radius9);
					} else {
						var beta6 = 2 * Math.PI / 24;
						var alpha6 = (Math.PI - beta6) / 2;
						var rotate6 = -(Math.PI / 2 - alpha6);
						var baseLength6 = 0.5 * radius9 * Math.sin(beta6 / 2);
						var ox8 = this.x;
						var oy8 = this.y;
						var arr8 = [];
						var _g12 = 0;
						while(_g12 < 48) {
							var i16 = _g12++;
							this.rotation += rotate6;
							var wasHistoryOn7 = this.turtleHistoryOn;
							this.turtleHistoryOn = false;
							if(this.turtleHistoryOn) {
								this.historyAdd("FORWARD");
								this.historyParameters.push(baseLength6);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FORWARD");
								this.turtleParameters.push(baseLength6);
							} else {
								var nx16 = this.x + baseLength6 * Math.cos(this.rotation);
								var ny16 = this.y + baseLength6 * Math.sin(this.rotation);
								if(this.penIsDown) {
									this.lastDistance = baseLength6;
									this.lineTo(nx16,ny16);
								} else {
									if(this.endLine == 2 || this.endLine == 3) {
										this.contour.end(this.width);
									}
									this.x = nx16;
									this.y = ny16;
									var l32 = this.points.length;
									this.points[l32] = [];
									this.points[l32][0] = nx16;
									this.points[l32][1] = ny16;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d22 = this.dim[this.dim.length - 1];
									if(nx16 < d22.minX) {
										d22.minX = nx16;
									}
									if(nx16 > d22.maxX) {
										d22.maxX = nx16;
									}
									if(ny16 < d22.minY) {
										d22.minY = ny16;
									}
									if(ny16 > d22.maxY) {
										d22.maxY = ny16;
									}
									this.contour.reset();
								}
							}
							this.turtleHistoryOn = wasHistoryOn7;
							if(this.fill) {
								arr8.push(this.x);
								arr8.push(this.y);
							}
						}
						if(this.fill) {
							var cx8 = (ox8 + arr8[arr8.length - 2]) / 2;
							var cy8 = (oy8 + arr8[arr8.length - 1]) / 2;
							var l33 = arr8.length;
							var i17 = 2;
							var lx6 = 0.;
							var ly6 = 0.;
							while(i17 < l33) {
								if(i17 > 2) {
									this.pen.triangle2DFill(lx6,ly6,arr8[i17],arr8[i17 + 1],cx8,cy8);
								}
								lx6 = arr8[i17];
								ly6 = arr8[i17 + 1];
								i17 += 2;
							}
						}
						arr8.length = 0;
					}
				}
				++j;
				break;
			case "CIRCLE_SIDES":
				var radius10 = v[j];
				var sides3 = v[j + 1];
				if(sides3 == null) {
					sides3 = 24;
				}
				if(this.turtleHistoryOn) {
					if(sides3 == 24) {
						this.historyAdd("CIRCLE");
						this.historyParameters.push(radius10);
					} else {
						this.historyAdd("CIRCLE_SIDES");
						this.historyParameters.push(radius10);
						this.historyParameters.push(sides3);
					}
				}
				if(radius10 != 0) {
					if(this.repeatCommands) {
						if(sides3 == 24) {
							this.turtleCommands.push("CIRCLE");
							this.turtleParameters.push(radius10);
						} else {
							this.turtleCommands.push("CIRCLE_SIDES");
							this.turtleParameters.push(radius10);
							this.turtleParameters.push(sides3);
						}
					} else {
						var beta7 = 2 * Math.PI / sides3;
						var alpha7 = (Math.PI - beta7) / 2;
						var rotate7 = -(Math.PI / 2 - alpha7);
						var baseLength7 = 0.5 * radius10 * Math.sin(beta7 / 2);
						var ox9 = this.x;
						var oy9 = this.y;
						var arr9 = [];
						var _g13 = 0;
						while(_g13 < 48) {
							var i18 = _g13++;
							this.rotation += rotate7;
							var wasHistoryOn8 = this.turtleHistoryOn;
							this.turtleHistoryOn = false;
							if(this.turtleHistoryOn) {
								this.historyAdd("FORWARD");
								this.historyParameters.push(baseLength7);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FORWARD");
								this.turtleParameters.push(baseLength7);
							} else {
								var nx17 = this.x + baseLength7 * Math.cos(this.rotation);
								var ny17 = this.y + baseLength7 * Math.sin(this.rotation);
								if(this.penIsDown) {
									this.lastDistance = baseLength7;
									this.lineTo(nx17,ny17);
								} else {
									if(this.endLine == 2 || this.endLine == 3) {
										this.contour.end(this.width);
									}
									this.x = nx17;
									this.y = ny17;
									var l34 = this.points.length;
									this.points[l34] = [];
									this.points[l34][0] = nx17;
									this.points[l34][1] = ny17;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d23 = this.dim[this.dim.length - 1];
									if(nx17 < d23.minX) {
										d23.minX = nx17;
									}
									if(nx17 > d23.maxX) {
										d23.maxX = nx17;
									}
									if(ny17 < d23.minY) {
										d23.minY = ny17;
									}
									if(ny17 > d23.maxY) {
										d23.maxY = ny17;
									}
									this.contour.reset();
								}
							}
							this.turtleHistoryOn = wasHistoryOn8;
							if(this.fill) {
								arr9.push(this.x);
								arr9.push(this.y);
							}
						}
						if(this.fill) {
							var cx9 = (ox9 + arr9[arr9.length - 2]) / 2;
							var cy9 = (oy9 + arr9[arr9.length - 1]) / 2;
							var l35 = arr9.length;
							var i19 = 2;
							var lx7 = 0.;
							var ly7 = 0.;
							while(i19 < l35) {
								if(i19 > 2) {
									this.pen.triangle2DFill(lx7,ly7,arr9[i19],arr9[i19 + 1],cx9,cy9);
								}
								lx7 = arr9[i19];
								ly7 = arr9[i19 + 1];
								i19 += 2;
							}
						}
						arr9.length = 0;
					}
				}
				j += 2;
				break;
			case "CYAN":
				if(this.turtleHistoryOn) {
					this.historyAdd("CYAN");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("CYAN");
				} else {
					this.pen.currentColor = -16711681;
				}
				break;
			case "DARKISH_BLUE":
				if(this.turtleHistoryOn) {
					this.historyAdd("DARKISH_BLUE");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("DARKISH_BLUE");
				} else {
					this.pen.currentColor = -8864837;
				}
				break;
			case "DARK_GREEN":
				if(this.turtleHistoryOn) {
					this.historyAdd("DARK_GREEN");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("DARK_GREEN");
				} else {
					this.pen.currentColor = -10182080;
				}
				break;
			case "EAST":
				if(this.turtleHistoryOn) {
					this.historyAdd("WEST");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("EAST");
				} else {
					this.rotation = Math.PI;
				}
				break;
			case "END_REPEAT":
				this.repeatCommands = false;
				if(this.turtleHistoryOn) {
					this.historyAdd("END_REPEAT");
				}
				var wasHistoryOn9 = this.turtleHistoryOn;
				this.turtleHistoryOn = false;
				var v2 = this.turtleParameters;
				var j2 = 0;
				var _g14 = 0;
				var _g15 = this.repeatCount;
				while(_g14 < _g15) {
					var k1 = _g14++;
					var _g16 = 0;
					var _g17 = this.turtleCommands.length;
					while(_g16 < _g17) {
						var i20 = _g16++;
						var command2 = this.turtleCommands[i20];
						switch(command2) {
						case "ARC":
							var radius11 = v2[j2];
							var degrees7 = v2[j2 + 1];
							if(this.turtleHistoryOn) {
								this.historyAdd("ARC");
								this.historyParameters.push(radius11);
								this.historyParameters.push(degrees7);
							}
							if(radius11 != 0) {
								if(this.repeatCommands) {
									this.turtleCommands.push("ARC");
									this.turtleParameters.push(radius11);
									this.turtleParameters.push(degrees7);
								} else {
									var beta8 = degrees7 * Math.PI / 180 / 24;
									var alpha8 = (Math.PI - beta8) / 2;
									var rotate8 = -(Math.PI / 2 - alpha8);
									var baseLength8 = 0.5 * radius11 * Math.sin(beta8 / 2);
									var ox10 = this.x;
									var oy10 = this.y;
									var arr10 = [];
									arr10.push(this.x);
									arr10.push(this.y);
									var _g18 = 0;
									while(_g18 < 48) {
										var i21 = _g18++;
										this.rotation += rotate8;
										var wasHistoryOn10 = this.turtleHistoryOn;
										this.turtleHistoryOn = false;
										if(this.turtleHistoryOn) {
											this.historyAdd("FORWARD");
											this.historyParameters.push(baseLength8);
										}
										if(this.repeatCommands) {
											this.turtleCommands.push("FORWARD");
											this.turtleParameters.push(baseLength8);
										} else {
											var nx18 = this.x + baseLength8 * Math.cos(this.rotation);
											var ny18 = this.y + baseLength8 * Math.sin(this.rotation);
											if(this.penIsDown) {
												this.lastDistance = baseLength8;
												this.lineTo(nx18,ny18);
											} else {
												if(this.endLine == 2 || this.endLine == 3) {
													this.contour.end(this.width);
												}
												this.x = nx18;
												this.y = ny18;
												var l36 = this.points.length;
												this.points[l36] = [];
												this.points[l36][0] = nx18;
												this.points[l36][1] = ny18;
												this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
												this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
												this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
												var d24 = this.dim[this.dim.length - 1];
												if(nx18 < d24.minX) {
													d24.minX = nx18;
												}
												if(nx18 > d24.maxX) {
													d24.maxX = nx18;
												}
												if(ny18 < d24.minY) {
													d24.minY = ny18;
												}
												if(ny18 > d24.maxY) {
													d24.maxY = ny18;
												}
												this.contour.reset();
											}
										}
										this.turtleHistoryOn = wasHistoryOn10;
										if(this.fill) {
											arr10.push(this.x);
											arr10.push(this.y);
										}
									}
									if(this.fill) {
										var cx10 = (ox10 + arr10[arr10.length - 2]) / 2;
										var cy10 = (oy10 + arr10[arr10.length - 1]) / 2;
										var l37 = arr10.length;
										var i22 = 2;
										var lx8 = 0.;
										var ly8 = 0.;
										this.pen.triangle2DFill(ox10,oy10,arr10[0],arr10[1],cx10,cy10);
										while(i22 < l37) {
											if(i22 > 2) {
												this.pen.triangle2DFill(lx8,ly8,arr10[i22],arr10[i22 + 1],cx10,cy10);
											}
											lx8 = arr10[i22];
											ly8 = arr10[i22 + 1];
											i22 += 2;
										}
									}
									arr10.length = 0;
								}
							}
							j2 += 2;
							break;
						case "ARCH_BEZIER":
							var distance10 = v2[j2];
							var distance23 = v2[j2 + 1];
							var radius12 = v2[j2 + 2];
							if(this.turtleHistoryOn) {
								this.historyAdd("ARCH_BEZIER");
								this.historyParameters.push(distance10);
								this.historyParameters.push(distance23);
								this.historyParameters.push(radius12);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("ARCH_BEZIER");
								this.turtleParameters.push(distance10);
								this.turtleParameters.push(distance23);
								this.turtleParameters.push(radius12);
							} else {
								var nx19 = this.x + distance10 * Math.cos(this.rotation);
								var ny19 = this.y + distance10 * Math.sin(this.rotation);
								if(this.penIsDown) {
									var thruX3 = this.x + distance23 * Math.cos(this.rotation) - radius12 * Math.cos(this.rotation + Math.PI / 2);
									var thruY3 = this.y + distance23 * Math.sin(this.rotation) - radius12 * Math.sin(this.rotation + Math.PI / 2);
									var newx2 = 2 * thruX3 - 0.5 * (this.x + nx19);
									var newy2 = 2 * thruY3 - 0.5 * (this.y + ny19);
									this.tempArr = [];
									var p2 = this.tempArr;
									var ax2 = this.x;
									var ay2 = this.y;
									var x5 = ax2 - newx2;
									var y5 = ay2 - newy2;
									var x6 = newx2 - nx19;
									var y6 = newy2 - ny19;
									var approxDistance2 = Math.sqrt(x5 * x5 + y5 * y5) + Math.sqrt(x6 * x6 + y6 * y6);
									if(approxDistance2 == 0) {
										approxDistance2 = 0.000001;
									}
									var step2 = Math.min(1 / (approxDistance2 * 0.707),cornerContour_CurveMath_quadStep);
									var l38 = p2.length;
									p2[l38++] = ax2;
									p2[l38++] = ay2;
									var t2 = step2;
									while(t2 < 1.) {
										var u4 = 1 - t2;
										p2[l38++] = Math.pow(u4,2) * ax2 + 2 * u4 * t2 * newx2 + Math.pow(t2,2) * nx19;
										var u5 = 1 - t2;
										p2[l38++] = Math.pow(u5,2) * ay2 + 2 * u5 * t2 * newy2 + Math.pow(t2,2) * ny19;
										t2 += step2;
									}
									p2[l38++] = nx19;
									p2[l38++] = ny19;
									var arr11 = this.tempArr;
									var withMove2 = false;
									if(withMove2 == null) {
										withMove2 = true;
									}
									var l39 = arr11.length;
									var i23 = 2;
									if(withMove2) {
										var x_2 = arr11[0];
										var y_2 = arr11[1];
										if(this.endLine == 2 || this.endLine == 3) {
											this.contour.end(this.width);
										}
										this.x = x_2;
										this.y = y_2;
										var l40 = this.points.length;
										this.points[l40] = [];
										this.points[l40][0] = x_2;
										this.points[l40][1] = y_2;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d25 = this.dim[this.dim.length - 1];
										if(x_2 < d25.minX) {
											d25.minX = x_2;
										}
										if(x_2 > d25.maxX) {
											d25.maxX = x_2;
										}
										if(y_2 < d25.minY) {
											d25.minY = y_2;
										}
										if(y_2 > d25.maxY) {
											d25.maxY = y_2;
										}
										this.contour.reset();
									} else {
										this.lineTo(arr11[0],arr11[1]);
									}
									var cx11 = (arr11[0] + arr11[l39 - 2]) / 2;
									var cy11 = (arr11[1] + arr11[l39 - 1]) / 2;
									var ox11 = this.x;
									var oy11 = this.y;
									while(i23 < l39) {
										if(this.fill && this.penIsDown) {
											if(i23 > 0 && i23 < l39 - 2) {
												this.pen.triangle2DFill(arr11[i23 - 2],arr11[i23 - 1],arr11[i23],arr11[i23 + 1],cx11,cy11);
											}
										}
										this.lineTo(arr11[i23],arr11[i23 + 1]);
										i23 += 2;
									}
									if(this.fill && this.penIsDown) {
										if(this.endLine == 2 || this.endLine == 3) {
											this.contour.end(this.width);
										}
										this.x = ox11;
										this.y = oy11;
										var l41 = this.points.length;
										this.points[l41] = [];
										this.points[l41][0] = ox11;
										this.points[l41][1] = oy11;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d26 = this.dim[this.dim.length - 1];
										if(ox11 < d26.minX) {
											d26.minX = ox11;
										}
										if(ox11 > d26.maxX) {
											d26.maxX = ox11;
										}
										if(oy11 < d26.minY) {
											d26.minY = oy11;
										}
										if(oy11 > d26.maxY) {
											d26.maxY = oy11;
										}
										this.contour.reset();
										this.lineTo(arr11[l39 - 2],arr11[l39 - 1]);
									}
									this.x = nx19;
									this.y = ny19;
								} else {
									if(this.endLine == 2 || this.endLine == 3) {
										this.contour.end(this.width);
									}
									this.x = nx19;
									this.y = ny19;
									var l42 = this.points.length;
									this.points[l42] = [];
									this.points[l42][0] = nx19;
									this.points[l42][1] = ny19;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d27 = this.dim[this.dim.length - 1];
									if(nx19 < d27.minX) {
										d27.minX = nx19;
									}
									if(nx19 > d27.maxX) {
										d27.maxX = nx19;
									}
									if(ny19 < d27.minY) {
										d27.minY = ny19;
									}
									if(ny19 > d27.maxY) {
										d27.maxY = ny19;
									}
									this.contour.reset();
								}
							}
							j2 += 3;
							break;
						case "ARC_SIDES":
							var radius13 = v2[j2];
							var degrees8 = v2[j2 + 1];
							var sides4 = v2[j2 + 2];
							if(sides4 == null) {
								sides4 = 24;
							}
							if(this.turtleHistoryOn) {
								if(sides4 == 24) {
									this.historyAdd("ARC");
									this.historyParameters.push(radius13);
									this.historyParameters.push(degrees8);
								} else {
									this.historyAdd("ARC_SIDES");
									this.historyParameters.push(radius13);
									this.historyParameters.push(degrees8);
									this.historyParameters.push(sides4);
								}
							}
							if(radius13 != 0) {
								if(this.repeatCommands) {
									if(sides4 == 24) {
										this.turtleCommands.push("ARC");
										this.turtleParameters.push(radius13);
										this.turtleParameters.push(degrees8);
									} else {
										this.turtleCommands.push("ARC_SIDES");
										this.turtleParameters.push(radius13);
										this.turtleParameters.push(degrees8);
										this.turtleParameters.push(sides4);
									}
								} else {
									var beta9 = degrees8 * Math.PI / 180 / sides4;
									var alpha9 = (Math.PI - beta9) / 2;
									var rotate9 = -(Math.PI / 2 - alpha9);
									var baseLength9 = 0.5 * radius13 * Math.sin(beta9 / 2);
									var ox12 = this.x;
									var oy12 = this.y;
									var arr12 = [];
									arr12.push(this.x);
									arr12.push(this.y);
									var _g19 = 0;
									while(_g19 < 48) {
										var i24 = _g19++;
										this.rotation += rotate9;
										var wasHistoryOn11 = this.turtleHistoryOn;
										this.turtleHistoryOn = false;
										if(this.turtleHistoryOn) {
											this.historyAdd("FORWARD");
											this.historyParameters.push(baseLength9);
										}
										if(this.repeatCommands) {
											this.turtleCommands.push("FORWARD");
											this.turtleParameters.push(baseLength9);
										} else {
											var nx20 = this.x + baseLength9 * Math.cos(this.rotation);
											var ny20 = this.y + baseLength9 * Math.sin(this.rotation);
											if(this.penIsDown) {
												this.lastDistance = baseLength9;
												this.lineTo(nx20,ny20);
											} else {
												if(this.endLine == 2 || this.endLine == 3) {
													this.contour.end(this.width);
												}
												this.x = nx20;
												this.y = ny20;
												var l43 = this.points.length;
												this.points[l43] = [];
												this.points[l43][0] = nx20;
												this.points[l43][1] = ny20;
												this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
												this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
												this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
												var d28 = this.dim[this.dim.length - 1];
												if(nx20 < d28.minX) {
													d28.minX = nx20;
												}
												if(nx20 > d28.maxX) {
													d28.maxX = nx20;
												}
												if(ny20 < d28.minY) {
													d28.minY = ny20;
												}
												if(ny20 > d28.maxY) {
													d28.maxY = ny20;
												}
												this.contour.reset();
											}
										}
										this.turtleHistoryOn = wasHistoryOn11;
										if(this.fill) {
											arr12.push(this.x);
											arr12.push(this.y);
										}
									}
									if(this.fill) {
										var cx12 = (ox12 + arr12[arr12.length - 2]) / 2;
										var cy12 = (oy12 + arr12[arr12.length - 1]) / 2;
										var l44 = arr12.length;
										var i25 = 2;
										var lx9 = 0.;
										var ly9 = 0.;
										this.pen.triangle2DFill(ox12,oy12,arr12[0],arr12[1],cx12,cy12);
										while(i25 < l44) {
											if(i25 > 2) {
												this.pen.triangle2DFill(lx9,ly9,arr12[i25],arr12[i25 + 1],cx12,cy12);
											}
											lx9 = arr12[i25];
											ly9 = arr12[i25 + 1];
											i25 += 2;
										}
									}
									arr12.length = 0;
								}
							}
							j2 += 3;
							break;
						case "BACKWARD":
							var distance11 = v2[j2];
							if(this.turtleHistoryOn) {
								this.historyAdd("BACKWARD");
								this.historyParameters.push(distance11);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("BACKWARD");
								this.turtleParameters.push(distance11);
							} else {
								var nx21 = this.x + distance11 * Math.cos(this.rotation + Math.PI);
								var ny21 = this.y + distance11 * Math.sin(this.rotation + Math.PI);
								if(this.penIsDown) {
									this.lineTo(nx21,ny21);
								} else {
									if(this.endLine == 2 || this.endLine == 3) {
										this.contour.end(this.width);
									}
									this.x = nx21;
									this.y = ny21;
									var l45 = this.points.length;
									this.points[l45] = [];
									this.points[l45][0] = nx21;
									this.points[l45][1] = ny21;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d29 = this.dim[this.dim.length - 1];
									if(nx21 < d29.minX) {
										d29.minX = nx21;
									}
									if(nx21 > d29.maxX) {
										d29.maxX = nx21;
									}
									if(ny21 < d29.minY) {
										d29.minY = ny21;
									}
									if(ny21 > d29.maxY) {
										d29.maxY = ny21;
									}
									this.contour.reset();
								}
							}
							++j2;
							break;
						case "BEGIN_REPEAT":
							break;
						case "BLACK":
							if(this.turtleHistoryOn) {
								this.historyAdd("BLACK");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("BLACK");
							} else {
								this.pen.currentColor = -16777216;
							}
							break;
						case "BLUE":
							if(this.turtleHistoryOn) {
								this.historyAdd("BLUE");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("BLUE");
							} else {
								this.pen.currentColor = -16776961;
							}
							break;
						case "BROWN":
							if(this.turtleHistoryOn) {
								this.historyAdd("BROWN");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("BROWN");
							} else {
								this.pen.currentColor = -6594501;
							}
							break;
						case "CIRCLE":
							var radius14 = v2[j2];
							if(this.turtleHistoryOn) {
								this.historyAdd("CIRCLE");
								this.historyParameters.push(radius14);
							}
							if(radius14 != 0) {
								if(this.repeatCommands) {
									this.turtleCommands.push("CIRCLE");
									this.turtleParameters.push(radius14);
								} else {
									var beta10 = 2 * Math.PI / 24;
									var alpha10 = (Math.PI - beta10) / 2;
									var rotate10 = -(Math.PI / 2 - alpha10);
									var baseLength10 = 0.5 * radius14 * Math.sin(beta10 / 2);
									var ox13 = this.x;
									var oy13 = this.y;
									var arr13 = [];
									var _g20 = 0;
									while(_g20 < 48) {
										var i26 = _g20++;
										this.rotation += rotate10;
										var wasHistoryOn12 = this.turtleHistoryOn;
										this.turtleHistoryOn = false;
										if(this.turtleHistoryOn) {
											this.historyAdd("FORWARD");
											this.historyParameters.push(baseLength10);
										}
										if(this.repeatCommands) {
											this.turtleCommands.push("FORWARD");
											this.turtleParameters.push(baseLength10);
										} else {
											var nx22 = this.x + baseLength10 * Math.cos(this.rotation);
											var ny22 = this.y + baseLength10 * Math.sin(this.rotation);
											if(this.penIsDown) {
												this.lastDistance = baseLength10;
												this.lineTo(nx22,ny22);
											} else {
												if(this.endLine == 2 || this.endLine == 3) {
													this.contour.end(this.width);
												}
												this.x = nx22;
												this.y = ny22;
												var l46 = this.points.length;
												this.points[l46] = [];
												this.points[l46][0] = nx22;
												this.points[l46][1] = ny22;
												this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
												this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
												this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
												var d30 = this.dim[this.dim.length - 1];
												if(nx22 < d30.minX) {
													d30.minX = nx22;
												}
												if(nx22 > d30.maxX) {
													d30.maxX = nx22;
												}
												if(ny22 < d30.minY) {
													d30.minY = ny22;
												}
												if(ny22 > d30.maxY) {
													d30.maxY = ny22;
												}
												this.contour.reset();
											}
										}
										this.turtleHistoryOn = wasHistoryOn12;
										if(this.fill) {
											arr13.push(this.x);
											arr13.push(this.y);
										}
									}
									if(this.fill) {
										var cx13 = (ox13 + arr13[arr13.length - 2]) / 2;
										var cy13 = (oy13 + arr13[arr13.length - 1]) / 2;
										var l47 = arr13.length;
										var i27 = 2;
										var lx10 = 0.;
										var ly10 = 0.;
										while(i27 < l47) {
											if(i27 > 2) {
												this.pen.triangle2DFill(lx10,ly10,arr13[i27],arr13[i27 + 1],cx13,cy13);
											}
											lx10 = arr13[i27];
											ly10 = arr13[i27 + 1];
											i27 += 2;
										}
									}
									arr13.length = 0;
								}
							}
							++j2;
							break;
						case "CIRCLE_SIDES":
							var radius15 = v2[j2];
							var sides5 = v2[j2 + 1];
							if(sides5 == null) {
								sides5 = 24;
							}
							if(this.turtleHistoryOn) {
								if(sides5 == 24) {
									this.historyAdd("CIRCLE");
									this.historyParameters.push(radius15);
								} else {
									this.historyAdd("CIRCLE_SIDES");
									this.historyParameters.push(radius15);
									this.historyParameters.push(sides5);
								}
							}
							if(radius15 != 0) {
								if(this.repeatCommands) {
									if(sides5 == 24) {
										this.turtleCommands.push("CIRCLE");
										this.turtleParameters.push(radius15);
									} else {
										this.turtleCommands.push("CIRCLE_SIDES");
										this.turtleParameters.push(radius15);
										this.turtleParameters.push(sides5);
									}
								} else {
									var beta11 = 2 * Math.PI / sides5;
									var alpha11 = (Math.PI - beta11) / 2;
									var rotate11 = -(Math.PI / 2 - alpha11);
									var baseLength11 = 0.5 * radius15 * Math.sin(beta11 / 2);
									var ox14 = this.x;
									var oy14 = this.y;
									var arr14 = [];
									var _g21 = 0;
									while(_g21 < 48) {
										var i28 = _g21++;
										this.rotation += rotate11;
										var wasHistoryOn13 = this.turtleHistoryOn;
										this.turtleHistoryOn = false;
										if(this.turtleHistoryOn) {
											this.historyAdd("FORWARD");
											this.historyParameters.push(baseLength11);
										}
										if(this.repeatCommands) {
											this.turtleCommands.push("FORWARD");
											this.turtleParameters.push(baseLength11);
										} else {
											var nx23 = this.x + baseLength11 * Math.cos(this.rotation);
											var ny23 = this.y + baseLength11 * Math.sin(this.rotation);
											if(this.penIsDown) {
												this.lastDistance = baseLength11;
												this.lineTo(nx23,ny23);
											} else {
												if(this.endLine == 2 || this.endLine == 3) {
													this.contour.end(this.width);
												}
												this.x = nx23;
												this.y = ny23;
												var l48 = this.points.length;
												this.points[l48] = [];
												this.points[l48][0] = nx23;
												this.points[l48][1] = ny23;
												this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
												this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
												this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
												var d31 = this.dim[this.dim.length - 1];
												if(nx23 < d31.minX) {
													d31.minX = nx23;
												}
												if(nx23 > d31.maxX) {
													d31.maxX = nx23;
												}
												if(ny23 < d31.minY) {
													d31.minY = ny23;
												}
												if(ny23 > d31.maxY) {
													d31.maxY = ny23;
												}
												this.contour.reset();
											}
										}
										this.turtleHistoryOn = wasHistoryOn13;
										if(this.fill) {
											arr14.push(this.x);
											arr14.push(this.y);
										}
									}
									if(this.fill) {
										var cx14 = (ox14 + arr14[arr14.length - 2]) / 2;
										var cy14 = (oy14 + arr14[arr14.length - 1]) / 2;
										var l49 = arr14.length;
										var i29 = 2;
										var lx11 = 0.;
										var ly11 = 0.;
										while(i29 < l49) {
											if(i29 > 2) {
												this.pen.triangle2DFill(lx11,ly11,arr14[i29],arr14[i29 + 1],cx14,cy14);
											}
											lx11 = arr14[i29];
											ly11 = arr14[i29 + 1];
											i29 += 2;
										}
									}
									arr14.length = 0;
								}
							}
							j2 += 2;
							break;
						case "CYAN":
							if(this.turtleHistoryOn) {
								this.historyAdd("CYAN");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("CYAN");
							} else {
								this.pen.currentColor = -16711681;
							}
							break;
						case "DARKISH_BLUE":
							if(this.turtleHistoryOn) {
								this.historyAdd("DARKISH_BLUE");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("DARKISH_BLUE");
							} else {
								this.pen.currentColor = -8864837;
							}
							break;
						case "DARK_GREEN":
							if(this.turtleHistoryOn) {
								this.historyAdd("DARK_GREEN");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("DARK_GREEN");
							} else {
								this.pen.currentColor = -10182080;
							}
							break;
						case "EAST":
							if(this.turtleHistoryOn) {
								this.historyAdd("WEST");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("EAST");
							} else {
								this.rotation = Math.PI;
							}
							break;
						case "END_REPEAT":
							break;
						case "FILL_OFF":
							if(this.turtleHistoryOn) {
								this.historyAdd("FILL_OFF");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FILL_OFF");
							} else {
								this.fill = false;
							}
							break;
						case "FILL_ON":
							if(this.turtleHistoryOn) {
								this.historyAdd("FILL_ON");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FILL_ON");
							} else {
								this.fill = true;
							}
							break;
						case "FORWARD":
							var distance12 = v2[j2];
							if(this.turtleHistoryOn) {
								this.historyAdd("FORWARD");
								this.historyParameters.push(distance12);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FORWARD");
								this.turtleParameters.push(distance12);
							} else {
								var nx24 = this.x + distance12 * Math.cos(this.rotation);
								var ny24 = this.y + distance12 * Math.sin(this.rotation);
								if(this.penIsDown) {
									this.lastDistance = distance12;
									this.lineTo(nx24,ny24);
								} else {
									if(this.endLine == 2 || this.endLine == 3) {
										this.contour.end(this.width);
									}
									this.x = nx24;
									this.y = ny24;
									var l50 = this.points.length;
									this.points[l50] = [];
									this.points[l50][0] = nx24;
									this.points[l50][1] = ny24;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d32 = this.dim[this.dim.length - 1];
									if(nx24 < d32.minX) {
										d32.minX = nx24;
									}
									if(nx24 > d32.maxX) {
										d32.maxX = nx24;
									}
									if(ny24 < d32.minY) {
										d32.minY = ny24;
									}
									if(ny24 > d32.maxY) {
										d32.maxY = ny24;
									}
									this.contour.reset();
								}
							}
							++j2;
							break;
						case "FORWARD_CHANGE":
							var deltaDistance1 = v2[j2];
							if(this.turtleHistoryOn) {
								this.historyAdd("FORWARD_CHANGE");
								this.historyParameters.push(deltaDistance1);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FORWARD_CHANGE");
								this.turtleParameters.push(deltaDistance1);
							} else {
								var distance13 = this.lastDistance + deltaDistance1;
								var nx25 = this.x + distance13 * Math.cos(this.rotation);
								var ny25 = this.y + distance13 * Math.sin(this.rotation);
								if(this.penIsDown) {
									this.lastDistance = distance13 + deltaDistance1;
									this.lineTo(nx25,ny25);
								} else {
									if(this.endLine == 2 || this.endLine == 3) {
										this.contour.end(this.width);
									}
									this.x = nx25;
									this.y = ny25;
									var l51 = this.points.length;
									this.points[l51] = [];
									this.points[l51][0] = nx25;
									this.points[l51][1] = ny25;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d33 = this.dim[this.dim.length - 1];
									if(nx25 < d33.minX) {
										d33.minX = nx25;
									}
									if(nx25 > d33.maxX) {
										d33.maxX = nx25;
									}
									if(ny25 < d33.minY) {
										d33.minY = ny25;
									}
									if(ny25 > d33.maxY) {
										d33.maxY = ny25;
									}
									this.contour.reset();
								}
							}
							++j2;
							break;
						case "FORWARD_FACTOR":
							var factor2 = v2[j2];
							if(this.turtleHistoryOn) {
								this.historyAdd("FORWARD_FACTOR");
								this.historyParameters.push(factor2);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("FORWARD_FACTOR");
								this.turtleParameters.push(factor2);
							} else {
								var distance14 = this.lastDistance * factor2;
								var nx26 = this.x + distance14 * Math.cos(this.rotation);
								var ny26 = this.y + distance14 * Math.sin(this.rotation);
								if(this.penIsDown) {
									this.lastDistance = distance14;
									this.lineTo(nx26,ny26);
								} else {
									if(this.endLine == 2 || this.endLine == 3) {
										this.contour.end(this.width);
									}
									this.x = nx26;
									this.y = ny26;
									var l52 = this.points.length;
									this.points[l52] = [];
									this.points[l52][0] = nx26;
									this.points[l52][1] = ny26;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d34 = this.dim[this.dim.length - 1];
									if(nx26 < d34.minX) {
										d34.minX = nx26;
									}
									if(nx26 > d34.maxX) {
										d34.maxX = nx26;
									}
									if(ny26 < d34.minY) {
										d34.minY = ny26;
									}
									if(ny26 > d34.maxY) {
										d34.maxY = ny26;
									}
									this.contour.reset();
								}
							}
							++j2;
							break;
						case "GREEN":
							if(this.turtleHistoryOn) {
								this.historyAdd("GREEN");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("GREEN");
							} else {
								this.pen.currentColor = -16711936;
							}
							break;
						case "GREY":
							if(this.turtleHistoryOn) {
								this.historyAdd("GREY");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("GREY");
							} else {
								this.pen.currentColor = -4737097;
							}
							break;
						case "LEFT":
							var degrees9 = v2[j2];
							if(this.turtleHistoryOn) {
								this.historyAdd("LEFT");
								this.historyParameters.push(degrees9);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("LEFT");
								this.turtleParameters.push(degrees9);
							} else {
								this.rotation -= degrees9 * Math.PI / 180;
							}
							++j2;
							break;
						case "LIGHT_BROWN":
							if(this.turtleHistoryOn) {
								this.historyAdd("LIGHT_BROWN");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("LIGHT_BROWN");
							} else {
								this.pen.currentColor = -3831790;
							}
							break;
						case "MAGENTA":
							if(this.turtleHistoryOn) {
								this.historyAdd("MAGENTA");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("MAGENTA");
							} else {
								this.pen.currentColor = -65281;
							}
							break;
						case "MOVE_PEN":
							var distance15 = v2[j2];
							if(this.repeatCommands) {
								this.turtleCommands.push("MOVE_PEN");
								this.turtleParameters.push(distance15);
							} else if(this.penIsDown) {
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_UP");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_UP");
								} else {
									this.penIsDown = false;
								}
								if(this.turtleHistoryOn) {
									this.historyAdd("FORWARD");
									this.historyParameters.push(distance15);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FORWARD");
									this.turtleParameters.push(distance15);
								} else {
									var nx27 = this.x + distance15 * Math.cos(this.rotation);
									var ny27 = this.y + distance15 * Math.sin(this.rotation);
									if(this.penIsDown) {
										this.lastDistance = distance15;
										this.lineTo(nx27,ny27);
									} else {
										if(this.endLine == 2 || this.endLine == 3) {
											this.contour.end(this.width);
										}
										this.x = nx27;
										this.y = ny27;
										var l53 = this.points.length;
										this.points[l53] = [];
										this.points[l53][0] = nx27;
										this.points[l53][1] = ny27;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d35 = this.dim[this.dim.length - 1];
										if(nx27 < d35.minX) {
											d35.minX = nx27;
										}
										if(nx27 > d35.maxX) {
											d35.maxX = nx27;
										}
										if(ny27 < d35.minY) {
											d35.minY = ny27;
										}
										if(ny27 > d35.maxY) {
											d35.maxY = ny27;
										}
										this.contour.reset();
									}
								}
								if(this.turtleHistoryOn) {
									this.historyAdd("PEN_DOWN");
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("PEN_DOWN");
								} else {
									this.penIsDown = true;
								}
							} else {
								if(this.turtleHistoryOn) {
									this.historyAdd("FORWARD");
									this.historyParameters.push(distance15);
								}
								if(this.repeatCommands) {
									this.turtleCommands.push("FORWARD");
									this.turtleParameters.push(distance15);
								} else {
									var nx28 = this.x + distance15 * Math.cos(this.rotation);
									var ny28 = this.y + distance15 * Math.sin(this.rotation);
									if(this.penIsDown) {
										this.lastDistance = distance15;
										this.lineTo(nx28,ny28);
									} else {
										if(this.endLine == 2 || this.endLine == 3) {
											this.contour.end(this.width);
										}
										this.x = nx28;
										this.y = ny28;
										var l54 = this.points.length;
										this.points[l54] = [];
										this.points[l54][0] = nx28;
										this.points[l54][1] = ny28;
										this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
										this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
										this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d36 = this.dim[this.dim.length - 1];
										if(nx28 < d36.minX) {
											d36.minX = nx28;
										}
										if(nx28 > d36.maxX) {
											d36.maxX = nx28;
										}
										if(ny28 < d36.minY) {
											d36.minY = ny28;
										}
										if(ny28 > d36.maxY) {
											d36.maxY = ny28;
										}
										this.contour.reset();
									}
								}
							}
							++j2;
							break;
						case "NORTH":
							if(this.turtleHistoryOn) {
								this.historyAdd("NORTH");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("NORTH");
							} else {
								this.rotation = -Math.PI / 2;
							}
							break;
						case "ORANGE":
							if(this.turtleHistoryOn) {
								this.historyAdd("ORANGE");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("ORANGE");
							} else {
								this.pen.currentColor = -23808;
							}
							break;
						case "PEN_COLOR":
							var r6 = v2[j2];
							var g6 = v2[j2 + 1];
							var b6 = v2[j2 + 2];
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_COLOR");
								this.historyParameters.push(r6);
								this.historyParameters.push(g6);
								this.historyParameters.push(b6);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_COLOR");
								this.turtleParameters.push(r6);
								this.turtleParameters.push(g6);
								this.turtleParameters.push(b6);
							} else {
								this.pen.currentColor = Math.round(255) << 24 | Math.round(r6 * 255) << 16 | Math.round(g6 * 255) << 8 | Math.round(b6 * 255);
							}
							j2 += 3;
							break;
						case "PEN_COLOR_B":
							var r7 = v2[j2];
							var g7 = v2[j2 + 1];
							var b7 = v2[j2 + 2];
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_COLOR_B");
								this.historyParameters.push(r7);
								this.historyParameters.push(g7);
								this.historyParameters.push(b7);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_COLOR_B");
								this.turtleParameters.push(r7);
								this.turtleParameters.push(g7);
								this.turtleParameters.push(b7);
							} else {
								this.pen.colorB = Math.round(255) << 24 | Math.round(r7 * 255) << 16 | Math.round(g7 * 255) << 8 | Math.round(b7 * 255);
							}
							j2 += 3;
							break;
						case "PEN_COLOR_C":
							var r8 = v2[j2];
							var g8 = v2[j2 + 1];
							var b8 = v2[j2 + 2];
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_COLOR_C");
								this.historyParameters.push(r8);
								this.historyParameters.push(g8);
								this.historyParameters.push(b8);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_COLOR_C");
								this.turtleParameters.push(r8);
								this.turtleParameters.push(g8);
								this.turtleParameters.push(b8);
							} else {
								this.pen.colorC = Math.round(255) << 24 | Math.round(r8 * 255) << 16 | Math.round(g8 * 255) << 8 | Math.round(b8 * 255);
							}
							j2 += 3;
							break;
						case "PEN_COLOR_CHANGE":
							var r9 = v2[j2];
							var g9 = v2[j2 + 1];
							var b9 = v2[j2 + 2];
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_COLOR_CHANGE");
								this.historyParameters.push(r9);
								this.historyParameters.push(g9);
								this.historyParameters.push(b9);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_COLOR_CHANGE");
								this.turtleParameters.push(r9);
								this.turtleParameters.push(g9);
								this.turtleParameters.push(b9);
							} else {
								var c3 = this.pen.currentColor;
								var r03 = (c3 >> 16 & 255) / 255;
								var g03 = (c3 >> 8 & 255) / 255;
								var b03 = (c3 & 255) / 255;
								this.pen.currentColor = Math.round(255) << 24 | Math.round((r03 + r9) * 255) << 16 | Math.round((g03 + g9) * 255) << 8 | Math.round((b03 + b9) * 255);
							}
							j2 += 3;
							break;
						case "PEN_COLOR_CHANGE_B":
							var r10 = v2[j2];
							var g10 = v2[j2 + 1];
							var b10 = v2[j2 + 2];
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_COLOR_CHANGE_B");
								this.historyParameters.push(r10);
								this.historyParameters.push(g10);
								this.historyParameters.push(b10);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_COLOR_CHANGE_B");
								this.turtleParameters.push(r10);
								this.turtleParameters.push(g10);
								this.turtleParameters.push(b10);
							} else {
								var c4 = this.pen.colorB;
								var r04 = (c4 >> 16 & 255) / 255;
								var g04 = (c4 >> 8 & 255) / 255;
								var b04 = (c4 & 255) / 255;
								this.pen.colorB = Math.round(255) << 24 | Math.round((r04 + r10) * 255) << 16 | Math.round((g04 + g10) * 255) << 8 | Math.round((b04 + b10) * 255);
							}
							j2 += 3;
							break;
						case "PEN_COLOR_CHANGE_C":
							var r11 = v2[j2];
							var g11 = v2[j2 + 1];
							var b11 = v2[j2 + 2];
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_COLOR_CHANGE_C");
								this.historyParameters.push(r11);
								this.historyParameters.push(g11);
								this.historyParameters.push(b11);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_COLOR_CHANGE_C");
								this.turtleParameters.push(r11);
								this.turtleParameters.push(g11);
								this.turtleParameters.push(b11);
							} else {
								var c5 = this.pen.colorC;
								var r05 = (c5 >> 16 & 255) / 255;
								var g05 = (c5 >> 8 & 255) / 255;
								var b05 = (c5 & 255) / 255;
								this.pen.colorC = Math.round(255) << 24 | Math.round((r05 + r11) * 255) << 16 | Math.round((g05 + g11) * 255) << 8 | Math.round((b05 + b11) * 255);
							}
							j2 += 3;
							break;
						case "PEN_DOWN":
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_DOWN");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_DOWN");
							} else {
								this.penIsDown = true;
							}
							break;
						case "PEN_SIZE":
							var w1 = v2[j2];
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_SIZE");
								this.historyParameters.push(w1);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_SIZE");
								this.turtleParameters.push(w1);
							} else {
								this.width = w1;
							}
							++j2;
							break;
						case "PEN_SIZE_CHANGE":
							var dw1 = v2[j2];
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_SIZE_CHANGE");
								this.historyParameters.push(dw1);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_SIZE_CHANGE");
								this.turtleParameters.push(dw1);
							} else {
								this.width += dw1;
							}
							++j2;
							break;
						case "PEN_SIZE_FACTOR":
							var factor3 = v2[j2];
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_SIZE_FACTOR");
								this.historyParameters.push(factor3);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_SIZE_FACTOR");
								this.turtleParameters.push(factor3);
							} else {
								this.width *= factor3;
							}
							++j2;
							break;
						case "PEN_UP":
							if(this.turtleHistoryOn) {
								this.historyAdd("PEN_UP");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PEN_UP");
							} else {
								this.penIsDown = false;
							}
							break;
						case "PLUM":
							if(this.turtleHistoryOn) {
								this.historyAdd("PLUM");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("PLUM");
							} else {
								this.pen.currentColor = -7310896;
							}
							break;
						case "RED":
							if(this.turtleHistoryOn) {
								this.historyAdd("RED");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("RED");
							} else {
								this.pen.currentColor = -65536;
							}
							break;
						case "RIGHT":
							var degrees10 = v2[j2];
							if(this.turtleHistoryOn) {
								this.historyAdd("RIGHT");
								this.historyParameters.push(degrees10);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("RIGHT");
								this.turtleParameters.push(degrees10);
							} else {
								this.rotation += degrees10 * Math.PI / 180;
							}
							++j2;
							break;
						case "SET_ANGLE":
							var degrees11 = v2[j2];
							if(this.turtleHistoryOn) {
								this.historyAdd("SET_ANGLE");
								this.historyParameters.push(degrees11);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("SET_ANGLE");
								this.turtleParameters.push(degrees11);
							} else {
								this.rotation = -Math.PI / 2;
								this.rotation += degrees11 * Math.PI / 180;
							}
							++j2;
							break;
						case "SET_POSITION":
							var x7 = v2[j2];
							var y7 = v2[j2 + 1];
							if(this.turtleHistoryOn) {
								this.historyAdd("SET_POSITION");
								this.historyParameters.push(x7);
								this.historyParameters.push(y7);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("SET_POSITION");
								this.turtleParameters.push(x7);
								this.turtleParameters.push(y7);
							} else {
								if(this.endLine == 2 || this.endLine == 3) {
									this.contour.end(this.width);
								}
								this.x = x7;
								this.y = y7;
								var l55 = this.points.length;
								this.points[l55] = [];
								this.points[l55][0] = x7;
								this.points[l55][1] = y7;
								this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
								this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
								this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d37 = this.dim[this.dim.length - 1];
								if(x7 < d37.minX) {
									d37.minX = x7;
								}
								if(x7 > d37.maxX) {
									d37.maxX = x7;
								}
								if(y7 < d37.minY) {
									d37.minY = y7;
								}
								if(y7 > d37.maxY) {
									d37.maxY = y7;
								}
								this.contour.reset();
							}
							j2 += 2;
							break;
						case "SOUTH":
							if(this.turtleHistoryOn) {
								this.historyAdd("SOUTH");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("SOUTH");
							} else {
								this.rotation = Math.PI / 2;
							}
							break;
						case "TAN":
							if(this.turtleHistoryOn) {
								this.historyAdd("TAN");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("TAN");
							} else {
								this.pen.currentColor = -27273;
							}
							break;
						case "TRIANGLE_ARCH":
							var distance16 = v2[j2];
							var distance24 = v2[j2 + 1];
							var radius16 = v2[j2 + 2];
							if(this.turtleHistoryOn) {
								this.historyAdd("TRIANGLE_ARCH");
								this.historyParameters.push(distance16);
								this.historyParameters.push(distance24);
								this.historyParameters.push(radius16);
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("TRIANGLE_ARCH");
								this.turtleParameters.push(distance16);
								this.turtleParameters.push(distance24);
								this.turtleParameters.push(radius16);
							} else {
								var nx29 = this.x + distance16 * Math.cos(this.rotation);
								var ny29 = this.y + distance16 * Math.sin(this.rotation);
								if(this.penIsDown) {
									var thruX4 = this.x + distance24 * Math.cos(this.rotation) - radius16 * Math.cos(this.rotation + Math.PI / 2);
									var thruY4 = this.y + distance24 * Math.sin(this.rotation) - radius16 * Math.sin(this.rotation + Math.PI / 2);
									if(this.fill) {
										this.pen.triangle2DFill(this.x,this.y,thruX4,thruY4,nx29,ny29);
									}
									this.lineTo(thruX4,thruY4);
									this.lineTo(nx29,ny29);
									if(this.fill) {
										this.lineTo(this.x,this.y);
									}
									if(this.endLine == 2 || this.endLine == 3) {
										this.contour.end(this.width);
									}
									this.x = nx29;
									this.y = ny29;
									var l56 = this.points.length;
									this.points[l56] = [];
									this.points[l56][0] = nx29;
									this.points[l56][1] = ny29;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d38 = this.dim[this.dim.length - 1];
									if(nx29 < d38.minX) {
										d38.minX = nx29;
									}
									if(nx29 > d38.maxX) {
										d38.maxX = nx29;
									}
									if(ny29 < d38.minY) {
										d38.minY = ny29;
									}
									if(ny29 > d38.maxY) {
										d38.maxY = ny29;
									}
									this.contour.reset();
								} else {
									if(this.endLine == 2 || this.endLine == 3) {
										this.contour.end(this.width);
									}
									this.x = nx29;
									this.y = ny29;
									var l57 = this.points.length;
									this.points[l57] = [];
									this.points[l57][0] = nx29;
									this.points[l57][1] = ny29;
									this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
									this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
									this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d39 = this.dim[this.dim.length - 1];
									if(nx29 < d39.minX) {
										d39.minX = nx29;
									}
									if(nx29 > d39.maxX) {
										d39.maxX = nx29;
									}
									if(ny29 < d39.minY) {
										d39.minY = ny29;
									}
									if(ny29 > d39.maxY) {
										d39.maxY = ny29;
									}
									this.contour.reset();
								}
							}
							j2 += 3;
							break;
						case "WEST":
							if(this.turtleHistoryOn) {
								this.historyAdd("WEST");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("WEST");
							} else {
								this.rotation = 0;
							}
							break;
						case "WHITE":
							if(this.turtleHistoryOn) {
								this.historyAdd("WHITE");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("WHITE");
							} else {
								this.pen.currentColor = -1;
							}
							break;
						case "YELLOW":
							if(this.turtleHistoryOn) {
								this.historyAdd("YELLOW");
							}
							if(this.repeatCommands) {
								this.turtleCommands.push("YELLOW");
							} else {
								this.pen.currentColor = -256;
							}
							break;
						}
					}
					j2 = 0;
				}
				this.turtleHistoryOn = wasHistoryOn9;
				this.turtleCommands.length = 0;
				this.turtleParameters.length = 0;
				break;
			case "FILL_OFF":
				if(this.turtleHistoryOn) {
					this.historyAdd("FILL_OFF");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("FILL_OFF");
				} else {
					this.fill = false;
				}
				break;
			case "FILL_ON":
				if(this.turtleHistoryOn) {
					this.historyAdd("FILL_ON");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("FILL_ON");
				} else {
					this.fill = true;
				}
				break;
			case "FORWARD":
				var distance17 = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("FORWARD");
					this.historyParameters.push(distance17);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("FORWARD");
					this.turtleParameters.push(distance17);
				} else {
					var nx30 = this.x + distance17 * Math.cos(this.rotation);
					var ny30 = this.y + distance17 * Math.sin(this.rotation);
					if(this.penIsDown) {
						this.lastDistance = distance17;
						this.lineTo(nx30,ny30);
					} else {
						if(this.endLine == 2 || this.endLine == 3) {
							this.contour.end(this.width);
						}
						this.x = nx30;
						this.y = ny30;
						var l58 = this.points.length;
						this.points[l58] = [];
						this.points[l58][0] = nx30;
						this.points[l58][1] = ny30;
						this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
						this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
						this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d40 = this.dim[this.dim.length - 1];
						if(nx30 < d40.minX) {
							d40.minX = nx30;
						}
						if(nx30 > d40.maxX) {
							d40.maxX = nx30;
						}
						if(ny30 < d40.minY) {
							d40.minY = ny30;
						}
						if(ny30 > d40.maxY) {
							d40.maxY = ny30;
						}
						this.contour.reset();
					}
				}
				++j;
				break;
			case "FORWARD_CHANGE":
				var deltaDistance2 = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("FORWARD_CHANGE");
					this.historyParameters.push(deltaDistance2);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("FORWARD_CHANGE");
					this.turtleParameters.push(deltaDistance2);
				} else {
					var distance18 = this.lastDistance + deltaDistance2;
					var nx31 = this.x + distance18 * Math.cos(this.rotation);
					var ny31 = this.y + distance18 * Math.sin(this.rotation);
					if(this.penIsDown) {
						this.lastDistance = distance18 + deltaDistance2;
						this.lineTo(nx31,ny31);
					} else {
						if(this.endLine == 2 || this.endLine == 3) {
							this.contour.end(this.width);
						}
						this.x = nx31;
						this.y = ny31;
						var l59 = this.points.length;
						this.points[l59] = [];
						this.points[l59][0] = nx31;
						this.points[l59][1] = ny31;
						this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
						this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
						this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d41 = this.dim[this.dim.length - 1];
						if(nx31 < d41.minX) {
							d41.minX = nx31;
						}
						if(nx31 > d41.maxX) {
							d41.maxX = nx31;
						}
						if(ny31 < d41.minY) {
							d41.minY = ny31;
						}
						if(ny31 > d41.maxY) {
							d41.maxY = ny31;
						}
						this.contour.reset();
					}
				}
				++j;
				break;
			case "FORWARD_FACTOR":
				var factor4 = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("FORWARD_FACTOR");
					this.historyParameters.push(factor4);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("FORWARD_FACTOR");
					this.turtleParameters.push(factor4);
				} else {
					var distance19 = this.lastDistance * factor4;
					var nx32 = this.x + distance19 * Math.cos(this.rotation);
					var ny32 = this.y + distance19 * Math.sin(this.rotation);
					if(this.penIsDown) {
						this.lastDistance = distance19;
						this.lineTo(nx32,ny32);
					} else {
						if(this.endLine == 2 || this.endLine == 3) {
							this.contour.end(this.width);
						}
						this.x = nx32;
						this.y = ny32;
						var l60 = this.points.length;
						this.points[l60] = [];
						this.points[l60][0] = nx32;
						this.points[l60][1] = ny32;
						this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
						this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
						this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d42 = this.dim[this.dim.length - 1];
						if(nx32 < d42.minX) {
							d42.minX = nx32;
						}
						if(nx32 > d42.maxX) {
							d42.maxX = nx32;
						}
						if(ny32 < d42.minY) {
							d42.minY = ny32;
						}
						if(ny32 > d42.maxY) {
							d42.maxY = ny32;
						}
						this.contour.reset();
					}
				}
				++j;
				break;
			case "GREEN":
				if(this.turtleHistoryOn) {
					this.historyAdd("GREEN");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("GREEN");
				} else {
					this.pen.currentColor = -16711936;
				}
				break;
			case "GREY":
				if(this.turtleHistoryOn) {
					this.historyAdd("GREY");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("GREY");
				} else {
					this.pen.currentColor = -4737097;
				}
				break;
			case "LEFT":
				var degrees12 = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("LEFT");
					this.historyParameters.push(degrees12);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("LEFT");
					this.turtleParameters.push(degrees12);
				} else {
					this.rotation -= degrees12 * Math.PI / 180;
				}
				++j;
				break;
			case "LIGHT_BROWN":
				if(this.turtleHistoryOn) {
					this.historyAdd("LIGHT_BROWN");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("LIGHT_BROWN");
				} else {
					this.pen.currentColor = -3831790;
				}
				break;
			case "MAGENTA":
				if(this.turtleHistoryOn) {
					this.historyAdd("MAGENTA");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("MAGENTA");
				} else {
					this.pen.currentColor = -65281;
				}
				break;
			case "MOVE_PEN":
				var distance20 = v[j];
				if(this.repeatCommands) {
					this.turtleCommands.push("MOVE_PEN");
					this.turtleParameters.push(distance20);
				} else if(this.penIsDown) {
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_UP");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_UP");
					} else {
						this.penIsDown = false;
					}
					if(this.turtleHistoryOn) {
						this.historyAdd("FORWARD");
						this.historyParameters.push(distance20);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("FORWARD");
						this.turtleParameters.push(distance20);
					} else {
						var nx33 = this.x + distance20 * Math.cos(this.rotation);
						var ny33 = this.y + distance20 * Math.sin(this.rotation);
						if(this.penIsDown) {
							this.lastDistance = distance20;
							this.lineTo(nx33,ny33);
						} else {
							if(this.endLine == 2 || this.endLine == 3) {
								this.contour.end(this.width);
							}
							this.x = nx33;
							this.y = ny33;
							var l61 = this.points.length;
							this.points[l61] = [];
							this.points[l61][0] = nx33;
							this.points[l61][1] = ny33;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d43 = this.dim[this.dim.length - 1];
							if(nx33 < d43.minX) {
								d43.minX = nx33;
							}
							if(nx33 > d43.maxX) {
								d43.maxX = nx33;
							}
							if(ny33 < d43.minY) {
								d43.minY = ny33;
							}
							if(ny33 > d43.maxY) {
								d43.maxY = ny33;
							}
							this.contour.reset();
						}
					}
					if(this.turtleHistoryOn) {
						this.historyAdd("PEN_DOWN");
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("PEN_DOWN");
					} else {
						this.penIsDown = true;
					}
				} else {
					if(this.turtleHistoryOn) {
						this.historyAdd("FORWARD");
						this.historyParameters.push(distance20);
					}
					if(this.repeatCommands) {
						this.turtleCommands.push("FORWARD");
						this.turtleParameters.push(distance20);
					} else {
						var nx34 = this.x + distance20 * Math.cos(this.rotation);
						var ny34 = this.y + distance20 * Math.sin(this.rotation);
						if(this.penIsDown) {
							this.lastDistance = distance20;
							this.lineTo(nx34,ny34);
						} else {
							if(this.endLine == 2 || this.endLine == 3) {
								this.contour.end(this.width);
							}
							this.x = nx34;
							this.y = ny34;
							var l62 = this.points.length;
							this.points[l62] = [];
							this.points[l62][0] = nx34;
							this.points[l62][1] = ny34;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d44 = this.dim[this.dim.length - 1];
							if(nx34 < d44.minX) {
								d44.minX = nx34;
							}
							if(nx34 > d44.maxX) {
								d44.maxX = nx34;
							}
							if(ny34 < d44.minY) {
								d44.minY = ny34;
							}
							if(ny34 > d44.maxY) {
								d44.maxY = ny34;
							}
							this.contour.reset();
						}
					}
				}
				++j;
				break;
			case "NORTH":
				if(this.turtleHistoryOn) {
					this.historyAdd("NORTH");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("NORTH");
				} else {
					this.rotation = -Math.PI / 2;
				}
				break;
			case "ORANGE":
				if(this.turtleHistoryOn) {
					this.historyAdd("ORANGE");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("ORANGE");
				} else {
					this.pen.currentColor = -23808;
				}
				break;
			case "PEN_COLOR":
				var r12 = v[j];
				var g12 = v[j + 1];
				var b12 = v[j + 2];
				if(this.turtleHistoryOn) {
					this.historyAdd("PEN_COLOR");
					this.historyParameters.push(r12);
					this.historyParameters.push(g12);
					this.historyParameters.push(b12);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PEN_COLOR");
					this.turtleParameters.push(r12);
					this.turtleParameters.push(g12);
					this.turtleParameters.push(b12);
				} else {
					this.pen.currentColor = Math.round(255) << 24 | Math.round(r12 * 255) << 16 | Math.round(g12 * 255) << 8 | Math.round(b12 * 255);
				}
				j += 3;
				break;
			case "PEN_COLOR_B":
				var r13 = v[j];
				var g13 = v[j + 1];
				var b13 = v[j + 2];
				if(this.turtleHistoryOn) {
					this.historyAdd("PEN_COLOR_B");
					this.historyParameters.push(r13);
					this.historyParameters.push(g13);
					this.historyParameters.push(b13);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PEN_COLOR_B");
					this.turtleParameters.push(r13);
					this.turtleParameters.push(g13);
					this.turtleParameters.push(b13);
				} else {
					this.pen.colorB = Math.round(255) << 24 | Math.round(r13 * 255) << 16 | Math.round(g13 * 255) << 8 | Math.round(b13 * 255);
				}
				j += 3;
				break;
			case "PEN_COLOR_C":
				var r14 = v[j];
				var g14 = v[j + 1];
				var b14 = v[j + 2];
				if(this.turtleHistoryOn) {
					this.historyAdd("PEN_COLOR_C");
					this.historyParameters.push(r14);
					this.historyParameters.push(g14);
					this.historyParameters.push(b14);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PEN_COLOR_C");
					this.turtleParameters.push(r14);
					this.turtleParameters.push(g14);
					this.turtleParameters.push(b14);
				} else {
					this.pen.colorC = Math.round(255) << 24 | Math.round(r14 * 255) << 16 | Math.round(g14 * 255) << 8 | Math.round(b14 * 255);
				}
				j += 3;
				break;
			case "PEN_COLOR_CHANGE":
				var r15 = v[j];
				var g15 = v[j + 1];
				var b15 = v[j + 2];
				if(this.turtleHistoryOn) {
					this.historyAdd("PEN_COLOR_CHANGE");
					this.historyParameters.push(r15);
					this.historyParameters.push(g15);
					this.historyParameters.push(b15);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PEN_COLOR_CHANGE");
					this.turtleParameters.push(r15);
					this.turtleParameters.push(g15);
					this.turtleParameters.push(b15);
				} else {
					var c6 = this.pen.currentColor;
					var r06 = (c6 >> 16 & 255) / 255;
					var g06 = (c6 >> 8 & 255) / 255;
					var b06 = (c6 & 255) / 255;
					this.pen.currentColor = Math.round(255) << 24 | Math.round((r06 + r15) * 255) << 16 | Math.round((g06 + g15) * 255) << 8 | Math.round((b06 + b15) * 255);
				}
				j += 3;
				break;
			case "PEN_COLOR_CHANGE_B":
				var r16 = v[j];
				var g16 = v[j + 1];
				var b16 = v[j + 2];
				if(this.turtleHistoryOn) {
					this.historyAdd("PEN_COLOR_CHANGE_B");
					this.historyParameters.push(r16);
					this.historyParameters.push(g16);
					this.historyParameters.push(b16);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PEN_COLOR_CHANGE_B");
					this.turtleParameters.push(r16);
					this.turtleParameters.push(g16);
					this.turtleParameters.push(b16);
				} else {
					var c7 = this.pen.colorB;
					var r07 = (c7 >> 16 & 255) / 255;
					var g07 = (c7 >> 8 & 255) / 255;
					var b07 = (c7 & 255) / 255;
					this.pen.colorB = Math.round(255) << 24 | Math.round((r07 + r16) * 255) << 16 | Math.round((g07 + g16) * 255) << 8 | Math.round((b07 + b16) * 255);
				}
				j += 3;
				break;
			case "PEN_COLOR_CHANGE_C":
				var r17 = v[j];
				var g17 = v[j + 1];
				var b17 = v[j + 2];
				if(this.turtleHistoryOn) {
					this.historyAdd("PEN_COLOR_CHANGE_C");
					this.historyParameters.push(r17);
					this.historyParameters.push(g17);
					this.historyParameters.push(b17);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PEN_COLOR_CHANGE_C");
					this.turtleParameters.push(r17);
					this.turtleParameters.push(g17);
					this.turtleParameters.push(b17);
				} else {
					var c8 = this.pen.colorC;
					var r08 = (c8 >> 16 & 255) / 255;
					var g08 = (c8 >> 8 & 255) / 255;
					var b08 = (c8 & 255) / 255;
					this.pen.colorC = Math.round(255) << 24 | Math.round((r08 + r17) * 255) << 16 | Math.round((g08 + g17) * 255) << 8 | Math.round((b08 + b17) * 255);
				}
				j += 3;
				break;
			case "PEN_DOWN":
				if(this.turtleHistoryOn) {
					this.historyAdd("PEN_DOWN");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PEN_DOWN");
				} else {
					this.penIsDown = true;
				}
				break;
			case "PEN_SIZE":
				var w2 = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("PEN_SIZE");
					this.historyParameters.push(w2);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PEN_SIZE");
					this.turtleParameters.push(w2);
				} else {
					this.width = w2;
				}
				++j;
				break;
			case "PEN_SIZE_CHANGE":
				var dw2 = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("PEN_SIZE_CHANGE");
					this.historyParameters.push(dw2);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PEN_SIZE_CHANGE");
					this.turtleParameters.push(dw2);
				} else {
					this.width += dw2;
				}
				++j;
				break;
			case "PEN_SIZE_FACTOR":
				var factor5 = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("PEN_SIZE_FACTOR");
					this.historyParameters.push(factor5);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PEN_SIZE_FACTOR");
					this.turtleParameters.push(factor5);
				} else {
					this.width *= factor5;
				}
				++j;
				break;
			case "PEN_UP":
				if(this.turtleHistoryOn) {
					this.historyAdd("PEN_UP");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PEN_UP");
				} else {
					this.penIsDown = false;
				}
				break;
			case "PLUM":
				if(this.turtleHistoryOn) {
					this.historyAdd("PLUM");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("PLUM");
				} else {
					this.pen.currentColor = -7310896;
				}
				break;
			case "RED":
				if(this.turtleHistoryOn) {
					this.historyAdd("RED");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("RED");
				} else {
					this.pen.currentColor = -65536;
				}
				break;
			case "RIGHT":
				var degrees13 = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("RIGHT");
					this.historyParameters.push(degrees13);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("RIGHT");
					this.turtleParameters.push(degrees13);
				} else {
					this.rotation += degrees13 * Math.PI / 180;
				}
				++j;
				break;
			case "SET_ANGLE":
				var degrees14 = v[j];
				if(this.turtleHistoryOn) {
					this.historyAdd("SET_ANGLE");
					this.historyParameters.push(degrees14);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("SET_ANGLE");
					this.turtleParameters.push(degrees14);
				} else {
					this.rotation = -Math.PI / 2;
					this.rotation += degrees14 * Math.PI / 180;
				}
				++j;
				break;
			case "SET_POSITION":
				var x8 = v[j];
				var y8 = v[j + 1];
				if(this.turtleHistoryOn) {
					this.historyAdd("SET_POSITION");
					this.historyParameters.push(x8);
					this.historyParameters.push(y8);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("SET_POSITION");
					this.turtleParameters.push(x8);
					this.turtleParameters.push(y8);
				} else {
					if(this.endLine == 2 || this.endLine == 3) {
						this.contour.end(this.width);
					}
					this.x = x8;
					this.y = y8;
					var l63 = this.points.length;
					this.points[l63] = [];
					this.points[l63][0] = x8;
					this.points[l63][1] = y8;
					this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
					this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
					this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
					var d45 = this.dim[this.dim.length - 1];
					if(x8 < d45.minX) {
						d45.minX = x8;
					}
					if(x8 > d45.maxX) {
						d45.maxX = x8;
					}
					if(y8 < d45.minY) {
						d45.minY = y8;
					}
					if(y8 > d45.maxY) {
						d45.maxY = y8;
					}
					this.contour.reset();
				}
				j += 2;
				break;
			case "SOUTH":
				if(this.turtleHistoryOn) {
					this.historyAdd("SOUTH");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("SOUTH");
				} else {
					this.rotation = Math.PI / 2;
				}
				break;
			case "TAN":
				if(this.turtleHistoryOn) {
					this.historyAdd("TAN");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("TAN");
				} else {
					this.pen.currentColor = -27273;
				}
				break;
			case "TRIANGLE_ARCH":
				var distance25 = v[j];
				var distance26 = v[j + 1];
				var radius17 = v[j + 2];
				if(this.turtleHistoryOn) {
					this.historyAdd("TRIANGLE_ARCH");
					this.historyParameters.push(distance25);
					this.historyParameters.push(distance26);
					this.historyParameters.push(radius17);
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("TRIANGLE_ARCH");
					this.turtleParameters.push(distance25);
					this.turtleParameters.push(distance26);
					this.turtleParameters.push(radius17);
				} else {
					var nx35 = this.x + distance25 * Math.cos(this.rotation);
					var ny35 = this.y + distance25 * Math.sin(this.rotation);
					if(this.penIsDown) {
						var thruX5 = this.x + distance26 * Math.cos(this.rotation) - radius17 * Math.cos(this.rotation + Math.PI / 2);
						var thruY5 = this.y + distance26 * Math.sin(this.rotation) - radius17 * Math.sin(this.rotation + Math.PI / 2);
						if(this.fill) {
							this.pen.triangle2DFill(this.x,this.y,thruX5,thruY5,nx35,ny35);
						}
						this.lineTo(thruX5,thruY5);
						this.lineTo(nx35,ny35);
						if(this.fill) {
							this.lineTo(this.x,this.y);
						}
						if(this.endLine == 2 || this.endLine == 3) {
							this.contour.end(this.width);
						}
						this.x = nx35;
						this.y = ny35;
						var l64 = this.points.length;
						this.points[l64] = [];
						this.points[l64][0] = nx35;
						this.points[l64][1] = ny35;
						this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
						this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
						this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d46 = this.dim[this.dim.length - 1];
						if(nx35 < d46.minX) {
							d46.minX = nx35;
						}
						if(nx35 > d46.maxX) {
							d46.maxX = nx35;
						}
						if(ny35 < d46.minY) {
							d46.minY = ny35;
						}
						if(ny35 > d46.maxY) {
							d46.maxY = ny35;
						}
						this.contour.reset();
					} else {
						if(this.endLine == 2 || this.endLine == 3) {
							this.contour.end(this.width);
						}
						this.x = nx35;
						this.y = ny35;
						var l65 = this.points.length;
						this.points[l65] = [];
						this.points[l65][0] = nx35;
						this.points[l65][1] = ny35;
						this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
						this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
						this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d47 = this.dim[this.dim.length - 1];
						if(nx35 < d47.minX) {
							d47.minX = nx35;
						}
						if(nx35 > d47.maxX) {
							d47.maxX = nx35;
						}
						if(ny35 < d47.minY) {
							d47.minY = ny35;
						}
						if(ny35 > d47.maxY) {
							d47.maxY = ny35;
						}
						this.contour.reset();
					}
				}
				j += 3;
				break;
			case "WEST":
				if(this.turtleHistoryOn) {
					this.historyAdd("WEST");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("WEST");
				} else {
					this.rotation = 0;
				}
				break;
			case "WHITE":
				if(this.turtleHistoryOn) {
					this.historyAdd("WHITE");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("WHITE");
				} else {
					this.pen.currentColor = -1;
				}
				break;
			case "YELLOW":
				if(this.turtleHistoryOn) {
					this.historyAdd("YELLOW");
				}
				if(this.repeatCommands) {
					this.turtleCommands.push("YELLOW");
				} else {
					this.pen.currentColor = -256;
				}
				break;
			}
		}
	}
};
var cornerContour_io_Array2DTriangles = {};
cornerContour_io_Array2DTriangles.get_ax = function(this1) {
	return this1[(this1[0] | 0) * 7 + 1];
};
cornerContour_io_Array2DTriangles.set_ax = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_ay = function(this1) {
	return this1[(this1[0] | 0) * 7 + 1 + 1];
};
cornerContour_io_Array2DTriangles.set_ay = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 1 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_bx = function(this1) {
	return this1[(this1[0] | 0) * 7 + 2 + 1];
};
cornerContour_io_Array2DTriangles.set_bx = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 2 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_by = function(this1) {
	return this1[(this1[0] | 0) * 7 + 3 + 1];
};
cornerContour_io_Array2DTriangles.set_by = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 3 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_cx = function(this1) {
	return this1[(this1[0] | 0) * 7 + 4 + 1];
};
cornerContour_io_Array2DTriangles.set_cx = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 4 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_cy = function(this1) {
	return this1[(this1[0] | 0) * 7 + 5 + 1];
};
cornerContour_io_Array2DTriangles.set_cy = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 5 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_color = function(this1) {
	return this1[(this1[0] | 0) * 7 + 6 + 1];
};
cornerContour_io_Array2DTriangles.set_colorInt = function(this1,v) {
	var v1 = v | 0;
	this1[(this1[0] | 0) * 7 + 6 + 1] = v1;
	return v;
};
cornerContour_io_Array2DTriangles.triangle = function(this1,ax_,ay_,bx_,by_,cx_,cy_) {
	cornerContour_io_Array2DTriangles.set_ax(this1,ax_);
	cornerContour_io_Array2DTriangles.set_ay(this1,ay_);
	cornerContour_io_Array2DTriangles.set_bx(this1,bx_);
	cornerContour_io_Array2DTriangles.set_by(this1,by_);
	cornerContour_io_Array2DTriangles.set_cx(this1,cx_);
	cornerContour_io_Array2DTriangles.set_cy(this1,cy_);
	var windingAdjusted = cornerContour_io_Array2DTriangles.adjustWinding(this1);
	if(windingAdjusted) {
		cornerContour_io_Array2DTriangles.set_ax(this1,ax_);
		cornerContour_io_Array2DTriangles.set_ay(this1,ay_);
		cornerContour_io_Array2DTriangles.set_bx(this1,cx_);
		cornerContour_io_Array2DTriangles.set_by(this1,cy_);
		cornerContour_io_Array2DTriangles.set_cx(this1,bx_);
		cornerContour_io_Array2DTriangles.set_cy(this1,by_);
	}
	return windingAdjusted;
};
cornerContour_io_Array2DTriangles.adjustWinding = function(this1) {
	return cornerContour_io_Array2DTriangles.get_ax(this1) * cornerContour_io_Array2DTriangles.get_by(this1) - cornerContour_io_Array2DTriangles.get_bx(this1) * cornerContour_io_Array2DTriangles.get_ay(this1) + (cornerContour_io_Array2DTriangles.get_bx(this1) * cornerContour_io_Array2DTriangles.get_cy(this1) - cornerContour_io_Array2DTriangles.get_cx(this1) * cornerContour_io_Array2DTriangles.get_by(this1)) + (cornerContour_io_Array2DTriangles.get_cx(this1) * cornerContour_io_Array2DTriangles.get_ay(this1) - cornerContour_io_Array2DTriangles.get_ax(this1) * cornerContour_io_Array2DTriangles.get_cy(this1)) > 0;
};
var cornerContourWebGLTest_CornerContourWebGLTurtle = function() {
	this.vertexColor = "vertexColor";
	this.vertexPosition = "vertexPosition";
	this.divertTrace = new cornerContourWebGLTest_DivertTrace();
	haxe_Log.trace("Contour Test of Turtle",{ fileName : "src/cornerContourWebGLTest/CornerContourWebGLTurtle.js.hx", lineNumber : 62, className : "cornerContourWebGLTest.CornerContourWebGLTurtle", methodName : "new"});
	this.width = 1024;
	this.height = 768;
	this.drawContours();
	this.rearrageDrawData();
	this.renderOnce();
};
cornerContourWebGLTest_CornerContourWebGLTurtle.__name__ = true;
cornerContourWebGLTest_CornerContourWebGLTurtle.prototype = {
	rearrageDrawData: function() {
		haxe_Log.trace("rearrangeDrawData",{ fileName : "src/cornerContourWebGLTest/CornerContourWebGLTurtle.js.hx", lineNumber : 73, className : "cornerContourWebGLTest.CornerContourWebGLTurtle", methodName : "rearrageDrawData"});
		var pen = this.pen2D;
		var data = pen.arr;
		var red = 0.;
		var green = 0.;
		var blue = 0.;
		var alpha = 0.;
		var color = 0;
		this.totalTriangles = (data.length - 1) / 7 | 0;
		this.bufferLength = this.totalTriangles * 3;
		this.len = this.totalTriangles * 6 * 3 | 0;
		var j = 0;
		var this1 = new Float32Array(this.len);
		this.arr32 = this1;
		var _g = 0;
		var _g1 = this.totalTriangles;
		while(_g < _g1) {
			var i = _g++;
			pen.arr[0] = i;
			color = cornerContour_io_Array2DTriangles.get_color(data) | 0;
			alpha = (color >> 24 & 255) / 255;
			red = (color >> 16 & 255) / 255;
			green = (color >> 8 & 255) / 255;
			blue = (color & 255) / 255;
			this.arr32[j] = -(1 - 2 * cornerContour_io_Array2DTriangles.get_ax(data) / this.width);
			++j;
			this.arr32[j] = 1 - 2 * cornerContour_io_Array2DTriangles.get_ay(data) / this.height;
			++j;
			this.arr32[j] = red;
			++j;
			this.arr32[j] = green;
			++j;
			this.arr32[j] = blue;
			++j;
			this.arr32[j] = alpha;
			++j;
			this.arr32[j] = -(1 - 2 * cornerContour_io_Array2DTriangles.get_bx(data) / this.width);
			++j;
			this.arr32[j] = 1 - 2 * cornerContour_io_Array2DTriangles.get_by(data) / this.height;
			++j;
			this.arr32[j] = red;
			++j;
			this.arr32[j] = green;
			++j;
			this.arr32[j] = blue;
			++j;
			this.arr32[j] = alpha;
			++j;
			this.arr32[j] = -(1 - 2 * cornerContour_io_Array2DTriangles.get_cx(data) / this.width);
			++j;
			this.arr32[j] = 1 - 2 * cornerContour_io_Array2DTriangles.get_cy(data) / this.height;
			++j;
			this.arr32[j] = red;
			++j;
			this.arr32[j] = green;
			++j;
			this.arr32[j] = blue;
			++j;
			this.arr32[j] = alpha;
			++j;
		}
	}
	,drawContours: function() {
		haxe_Log.trace("drawContours",{ fileName : "src/cornerContourWebGLTest/CornerContourWebGLTurtle.js.hx", lineNumber : 136, className : "cornerContourWebGLTest.CornerContourWebGLTurtle", methodName : "drawContours"});
		this.pen2D = new cornerContour_Pen2D(-16776961);
		this.pen2D.currentColor = -16776961;
		this.turtleStar();
		this.haxeLogo();
		this.heptagram();
		this.enneagram();
	}
	,renderOnce: function() {
		haxe_Log.trace("renderOnce",{ fileName : "src/cornerContourWebGLTest/CornerContourWebGLTurtle.js.hx", lineNumber : 147, className : "cornerContourWebGLTest.CornerContourWebGLTurtle", methodName : "renderOnce"});
		this.mainSheet = new cornerContourWebGLTest_Sheet();
		this.mainSheet.create(this.width,this.height,true);
		this.gl = this.mainSheet.gl;
		var gl = this.gl;
		var width = this.width;
		var height = this.height;
		var r = 0.;
		var g = 0.;
		var b = 0.;
		var a = 1.;
		if(a == null) {
			a = 0.;
		}
		if(b == null) {
			b = 0.;
		}
		if(g == null) {
			g = 0.;
		}
		if(r == null) {
			r = 0.;
		}
		gl.clearColor(r,g,b,a);
		gl.enable(2929);
		gl.clear(16384);
		gl.viewport(0,0,width,height);
		gl.enable(3042);
		gl.blendFunc(1,771);
		gl.enable(2929);
		var gl = this.gl;
		var program = gl.createProgram();
		var shader = gl.createShader(35633);
		gl.shaderSource(shader,"attribute vec2 vertexPosition;" + "attribute vec4 vertexColor;" + "varying vec4 vcol;" + "void main(void) {" + " gl_Position = vec4(vertexPosition, .0, 1.0);" + " vcol = vertexColor;" + "}");
		gl.compileShader(shader);
		var tmp;
		if(!gl.getShaderParameter(shader,35713)) {
			throw haxe_Exception.thrown("Error compiling shader. " + gl.getShaderInfoLog(shader));
		} else {
			tmp = shader;
		}
		gl.attachShader(program,tmp);
		var shader = gl.createShader(35632);
		gl.shaderSource(shader,"precision mediump float;" + "varying vec4 vcol;" + "void main(void) {" + "vec4 color = vec4(vcol.rgb, 1. );" + "color *= vcol.a; " + "gl_FragColor = color;" + "}");
		gl.compileShader(shader);
		var tmp;
		if(!gl.getShaderParameter(shader,35713)) {
			throw haxe_Exception.thrown("Error compiling shader. " + gl.getShaderInfoLog(shader));
		} else {
			tmp = shader;
		}
		gl.attachShader(program,tmp);
		gl.linkProgram(program);
		var tmp;
		if(!gl.getProgramParameter(program,35714)) {
			throw haxe_Exception.thrown("Error linking program. " + gl.getProgramInfoLog(program));
		} else {
			gl.validateProgram(program);
			if(!gl.getProgramParameter(program,35715)) {
				throw haxe_Exception.thrown("Error validating program. " + gl.getProgramInfoLog(program));
			} else {
				gl.useProgram(program);
				tmp = program;
			}
		}
		this.programColor = tmp;
		this.gl.bindBuffer(34962,null);
		this.gl.useProgram(this.programColor);
		var gl = this.gl;
		var program = this.programColor;
		var data = this.arr32;
		var xyName = this.vertexPosition;
		var rgbaName = this.vertexColor;
		var isDynamic = true;
		if(isDynamic == null) {
			isDynamic = false;
		}
		var isDynamic1 = isDynamic;
		if(isDynamic1 == null) {
			isDynamic1 = false;
		}
		var buf = gl.createBuffer();
		var staticDraw = 35044;
		var dynamicDraw = 35048;
		var arrayBuffer = 34962;
		gl.bindBuffer(arrayBuffer,buf);
		if(isDynamic1) {
			var arrayBuffer = 34962;
			gl.bufferData(arrayBuffer,data,dynamicDraw);
		} else {
			var arrayBuffer = 34962;
			gl.bufferData(arrayBuffer,data,staticDraw);
		}
		var vbo = buf;
		var inp = gl.getAttribLocation(program,xyName);
		var elementBytes = 4;
		var fp = 5126;
		var strideBytes = 6 * elementBytes;
		var offBytes = 0 * elementBytes;
		gl.vertexAttribPointer(inp,2,fp,false,strideBytes,offBytes);
		gl.enableVertexAttribArray(inp);
		var inp = gl.getAttribLocation(program,rgbaName);
		var elementBytes = 4;
		var fp = 5126;
		var strideBytes = 6 * elementBytes;
		var offBytes = 2 * elementBytes;
		gl.vertexAttribPointer(inp,4,fp,false,strideBytes,offBytes);
		gl.enableVertexAttribArray(inp);
		this.bufColor = vbo;
		this.gl.bindBuffer(34962,this.bufColor);
		this.gl.useProgram(this.programColor);
		this.gl.drawArrays(4,0,this.bufferLength);
	}
	,haxeLogo: function() {
		var sketcher = new cornerContour_Sketcher(this.pen2D,4,0);
		var a = 10;
		var b = 47;
		if(sketcher.turtleHistoryOn) {
			sketcher.historyAdd("SET_POSITION");
			sketcher.historyParameters.push(500);
			sketcher.historyParameters.push(300);
		}
		if(sketcher.repeatCommands) {
			sketcher.turtleCommands.push("SET_POSITION");
			sketcher.turtleParameters.push(500);
			sketcher.turtleParameters.push(300);
		} else {
			if(sketcher.endLine == 2 || sketcher.endLine == 3) {
				sketcher.contour.end(sketcher.width);
			}
			sketcher.x = 500;
			sketcher.y = 300;
			var l = sketcher.points.length;
			sketcher.points[l] = [];
			sketcher.points[l][0] = 500;
			sketcher.points[l][1] = 300;
			sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
			sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
			sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = sketcher.dim[sketcher.dim.length - 1];
			if(500 < d.minX) {
				d.minX = 500;
			}
			if(500 > d.maxX) {
				d.maxX = 500;
			}
			if(300 < d.minY) {
				d.minY = 300;
			}
			if(300 > d.maxY) {
				d.maxY = 300;
			}
			sketcher.contour.reset();
		}
		sketcher.turtleHistoryOn = true;
		if(sketcher.turtleHistoryOn) {
			sketcher.historyAdd("PEN_SIZE");
			sketcher.historyParameters.push(8);
		}
		if(sketcher.repeatCommands) {
			sketcher.turtleCommands.push("PEN_SIZE");
			sketcher.turtleParameters.push(8);
		} else {
			sketcher.width = 8;
		}
		var _this = sketcher;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("RED");
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("RED");
		} else {
			_this.pen.currentColor = -65536;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("FILL_OFF");
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("FILL_OFF");
		} else {
			_this1.fill = false;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("CIRCLE");
			_this.historyParameters.push(10);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("CIRCLE");
			_this.turtleParameters.push(10);
		} else {
			var beta = 2 * Math.PI / 24;
			var alpha = (Math.PI - beta) / 2;
			var rotate = -(Math.PI / 2 - alpha);
			var baseLength = 5. * Math.sin(beta / 2);
			var ox = _this.x;
			var oy = _this.y;
			var arr = [];
			var _g = 0;
			while(_g < 48) {
				var i = _g++;
				_this.rotation += rotate;
				var wasHistoryOn = _this.turtleHistoryOn;
				_this.turtleHistoryOn = false;
				if(_this.turtleHistoryOn) {
					_this.historyAdd("FORWARD");
					_this.historyParameters.push(baseLength);
				}
				if(_this.repeatCommands) {
					_this.turtleCommands.push("FORWARD");
					_this.turtleParameters.push(baseLength);
				} else {
					var nx = _this.x + baseLength * Math.cos(_this.rotation);
					var ny = _this.y + baseLength * Math.sin(_this.rotation);
					if(_this.penIsDown) {
						_this.lastDistance = baseLength;
						_this.lineTo(nx,ny);
					} else {
						if(_this.endLine == 2 || _this.endLine == 3) {
							_this.contour.end(_this.width);
						}
						_this.x = nx;
						_this.y = ny;
						var l = _this.points.length;
						_this.points[l] = [];
						_this.points[l][0] = nx;
						_this.points[l][1] = ny;
						_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
						_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
						_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d = _this.dim[_this.dim.length - 1];
						if(nx < d.minX) {
							d.minX = nx;
						}
						if(nx > d.maxX) {
							d.maxX = nx;
						}
						if(ny < d.minY) {
							d.minY = ny;
						}
						if(ny > d.maxY) {
							d.maxY = ny;
						}
						_this.contour.reset();
					}
				}
				_this.turtleHistoryOn = wasHistoryOn;
				if(_this.fill) {
					arr.push(_this.x);
					arr.push(_this.y);
				}
			}
			if(_this.fill) {
				var cx = (ox + arr[arr.length - 2]) / 2;
				var cy = (oy + arr[arr.length - 1]) / 2;
				var l = arr.length;
				var i = 2;
				var lx = 0.;
				var ly = 0.;
				while(i < l) {
					if(i > 2) {
						_this.pen.triangle2DFill(lx,ly,arr[i],arr[i + 1],cx,cy);
					}
					lx = arr[i];
					ly = arr[i + 1];
					i += 2;
				}
			}
			arr.length = 0;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("ORANGE");
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("ORANGE");
		} else {
			_this1.pen.currentColor = -23808;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("NORTH");
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("NORTH");
		} else {
			_this.rotation = -Math.PI / 2;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("FORWARD");
			_this1.historyParameters.push(100);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("FORWARD");
			_this1.turtleParameters.push(100);
		} else {
			var nx = _this1.x + 100 * Math.cos(_this1.rotation);
			var ny = _this1.y + 100 * Math.sin(_this1.rotation);
			if(_this1.penIsDown) {
				_this1.lastDistance = 100;
				_this1.lineTo(nx,ny);
			} else {
				if(_this1.endLine == 2 || _this1.endLine == 3) {
					_this1.contour.end(_this1.width);
				}
				_this1.x = nx;
				_this1.y = ny;
				var l = _this1.points.length;
				_this1.points[l] = [];
				_this1.points[l][0] = nx;
				_this1.points[l][1] = ny;
				_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
				_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
				_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this1.dim[_this1.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this1.contour.reset();
			}
		}
		var _this = _this1;
		var degrees = b - a / 2 - 2;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("RIGHT");
			_this.historyParameters.push(degrees);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("RIGHT");
			_this.turtleParameters.push(degrees);
		} else {
			_this.rotation += degrees * Math.PI / 180;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("BEGIN_REPEAT");
			_this1.historyParameters.push(Math.round(40));
		}
		if(_this1.repeatCommands == true) {
			_this1.repeatCommands = false;
			if(_this1.turtleHistoryOn) {
				_this1.historyAdd("END_REPEAT");
			}
			var wasHistoryOn = _this1.turtleHistoryOn;
			_this1.turtleHistoryOn = false;
			var v = _this1.turtleParameters;
			var j = 0;
			var _g = 0;
			var _g1 = _this1.repeatCount;
			while(_g < _g1) {
				var k = _g++;
				var _g2 = 0;
				var _g3 = _this1.turtleCommands.length;
				while(_g2 < _g3) {
					var i = _g2++;
					var command = _this1.turtleCommands[i];
					switch(command) {
					case "ARC":
						var radius = v[j];
						var degrees = v[j + 1];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("ARC");
							_this1.historyParameters.push(radius);
							_this1.historyParameters.push(degrees);
						}
						if(radius != 0) {
							if(_this1.repeatCommands) {
								_this1.turtleCommands.push("ARC");
								_this1.turtleParameters.push(radius);
								_this1.turtleParameters.push(degrees);
							} else {
								var beta = degrees * Math.PI / 180 / 24;
								var alpha = (Math.PI - beta) / 2;
								var rotate = -(Math.PI / 2 - alpha);
								var baseLength = 0.5 * radius * Math.sin(beta / 2);
								var ox = _this1.x;
								var oy = _this1.y;
								var arr = [];
								arr.push(_this1.x);
								arr.push(_this1.y);
								var _g4 = 0;
								while(_g4 < 48) {
									var i1 = _g4++;
									_this1.rotation += rotate;
									var wasHistoryOn1 = _this1.turtleHistoryOn;
									_this1.turtleHistoryOn = false;
									if(_this1.turtleHistoryOn) {
										_this1.historyAdd("FORWARD");
										_this1.historyParameters.push(baseLength);
									}
									if(_this1.repeatCommands) {
										_this1.turtleCommands.push("FORWARD");
										_this1.turtleParameters.push(baseLength);
									} else {
										var nx = _this1.x + baseLength * Math.cos(_this1.rotation);
										var ny = _this1.y + baseLength * Math.sin(_this1.rotation);
										if(_this1.penIsDown) {
											_this1.lastDistance = baseLength;
											_this1.lineTo(nx,ny);
										} else {
											if(_this1.endLine == 2 || _this1.endLine == 3) {
												_this1.contour.end(_this1.width);
											}
											_this1.x = nx;
											_this1.y = ny;
											var l = _this1.points.length;
											_this1.points[l] = [];
											_this1.points[l][0] = nx;
											_this1.points[l][1] = ny;
											_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
											_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
											_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d = _this1.dim[_this1.dim.length - 1];
											if(nx < d.minX) {
												d.minX = nx;
											}
											if(nx > d.maxX) {
												d.maxX = nx;
											}
											if(ny < d.minY) {
												d.minY = ny;
											}
											if(ny > d.maxY) {
												d.maxY = ny;
											}
											_this1.contour.reset();
										}
									}
									_this1.turtleHistoryOn = wasHistoryOn1;
									if(_this1.fill) {
										arr.push(_this1.x);
										arr.push(_this1.y);
									}
								}
								if(_this1.fill) {
									var cx = (ox + arr[arr.length - 2]) / 2;
									var cy = (oy + arr[arr.length - 1]) / 2;
									var l1 = arr.length;
									var i2 = 2;
									var lx = 0.;
									var ly = 0.;
									_this1.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
									while(i2 < l1) {
										if(i2 > 2) {
											_this1.pen.triangle2DFill(lx,ly,arr[i2],arr[i2 + 1],cx,cy);
										}
										lx = arr[i2];
										ly = arr[i2 + 1];
										i2 += 2;
									}
								}
								arr.length = 0;
							}
						}
						j += 2;
						break;
					case "ARCH_BEZIER":
						var distance = v[j];
						var distance2 = v[j + 1];
						var radius1 = v[j + 2];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("ARCH_BEZIER");
							_this1.historyParameters.push(distance);
							_this1.historyParameters.push(distance2);
							_this1.historyParameters.push(radius1);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("ARCH_BEZIER");
							_this1.turtleParameters.push(distance);
							_this1.turtleParameters.push(distance2);
							_this1.turtleParameters.push(radius1);
						} else {
							var nx1 = _this1.x + distance * Math.cos(_this1.rotation);
							var ny1 = _this1.y + distance * Math.sin(_this1.rotation);
							if(_this1.penIsDown) {
								var thruX = _this1.x + distance2 * Math.cos(_this1.rotation) - radius1 * Math.cos(_this1.rotation + Math.PI / 2);
								var thruY = _this1.y + distance2 * Math.sin(_this1.rotation) - radius1 * Math.sin(_this1.rotation + Math.PI / 2);
								var newx = 2 * thruX - 0.5 * (_this1.x + nx1);
								var newy = 2 * thruY - 0.5 * (_this1.y + ny1);
								_this1.tempArr = [];
								var p = _this1.tempArr;
								var ax = _this1.x;
								var ay = _this1.y;
								var x = ax - newx;
								var y = ay - newy;
								var x1 = newx - nx1;
								var y1 = newy - ny1;
								var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
								if(approxDistance == 0) {
									approxDistance = 0.000001;
								}
								var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
								var l2 = p.length;
								p[l2++] = ax;
								p[l2++] = ay;
								var t = step;
								while(t < 1.) {
									var u = 1 - t;
									p[l2++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx1;
									var u1 = 1 - t;
									p[l2++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny1;
									t += step;
								}
								p[l2++] = nx1;
								p[l2++] = ny1;
								var arr1 = _this1.tempArr;
								var withMove = false;
								if(withMove == null) {
									withMove = true;
								}
								var l3 = arr1.length;
								var i3 = 2;
								if(withMove) {
									var x_ = arr1[0];
									var y_ = arr1[1];
									if(_this1.endLine == 2 || _this1.endLine == 3) {
										_this1.contour.end(_this1.width);
									}
									_this1.x = x_;
									_this1.y = y_;
									var l4 = _this1.points.length;
									_this1.points[l4] = [];
									_this1.points[l4][0] = x_;
									_this1.points[l4][1] = y_;
									_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
									_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
									_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d1 = _this1.dim[_this1.dim.length - 1];
									if(x_ < d1.minX) {
										d1.minX = x_;
									}
									if(x_ > d1.maxX) {
										d1.maxX = x_;
									}
									if(y_ < d1.minY) {
										d1.minY = y_;
									}
									if(y_ > d1.maxY) {
										d1.maxY = y_;
									}
									_this1.contour.reset();
								} else {
									_this1.lineTo(arr1[0],arr1[1]);
								}
								var cx1 = (arr1[0] + arr1[l3 - 2]) / 2;
								var cy1 = (arr1[1] + arr1[l3 - 1]) / 2;
								var ox1 = _this1.x;
								var oy1 = _this1.y;
								while(i3 < l3) {
									if(_this1.fill && _this1.penIsDown) {
										if(i3 > 0 && i3 < l3 - 2) {
											_this1.pen.triangle2DFill(arr1[i3 - 2],arr1[i3 - 1],arr1[i3],arr1[i3 + 1],cx1,cy1);
										}
									}
									_this1.lineTo(arr1[i3],arr1[i3 + 1]);
									i3 += 2;
								}
								if(_this1.fill && _this1.penIsDown) {
									if(_this1.endLine == 2 || _this1.endLine == 3) {
										_this1.contour.end(_this1.width);
									}
									_this1.x = ox1;
									_this1.y = oy1;
									var l5 = _this1.points.length;
									_this1.points[l5] = [];
									_this1.points[l5][0] = ox1;
									_this1.points[l5][1] = oy1;
									_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
									_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
									_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d2 = _this1.dim[_this1.dim.length - 1];
									if(ox1 < d2.minX) {
										d2.minX = ox1;
									}
									if(ox1 > d2.maxX) {
										d2.maxX = ox1;
									}
									if(oy1 < d2.minY) {
										d2.minY = oy1;
									}
									if(oy1 > d2.maxY) {
										d2.maxY = oy1;
									}
									_this1.contour.reset();
									_this1.lineTo(arr1[l3 - 2],arr1[l3 - 1]);
								}
								_this1.x = nx1;
								_this1.y = ny1;
							} else {
								if(_this1.endLine == 2 || _this1.endLine == 3) {
									_this1.contour.end(_this1.width);
								}
								_this1.x = nx1;
								_this1.y = ny1;
								var l6 = _this1.points.length;
								_this1.points[l6] = [];
								_this1.points[l6][0] = nx1;
								_this1.points[l6][1] = ny1;
								_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
								_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
								_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d3 = _this1.dim[_this1.dim.length - 1];
								if(nx1 < d3.minX) {
									d3.minX = nx1;
								}
								if(nx1 > d3.maxX) {
									d3.maxX = nx1;
								}
								if(ny1 < d3.minY) {
									d3.minY = ny1;
								}
								if(ny1 > d3.maxY) {
									d3.maxY = ny1;
								}
								_this1.contour.reset();
							}
						}
						j += 3;
						break;
					case "ARC_SIDES":
						var radius2 = v[j];
						var degrees1 = v[j + 1];
						var sides = v[j + 2];
						if(sides == null) {
							sides = 24;
						}
						if(_this1.turtleHistoryOn) {
							if(sides == 24) {
								_this1.historyAdd("ARC");
								_this1.historyParameters.push(radius2);
								_this1.historyParameters.push(degrees1);
							} else {
								_this1.historyAdd("ARC_SIDES");
								_this1.historyParameters.push(radius2);
								_this1.historyParameters.push(degrees1);
								_this1.historyParameters.push(sides);
							}
						}
						if(radius2 != 0) {
							if(_this1.repeatCommands) {
								if(sides == 24) {
									_this1.turtleCommands.push("ARC");
									_this1.turtleParameters.push(radius2);
									_this1.turtleParameters.push(degrees1);
								} else {
									_this1.turtleCommands.push("ARC_SIDES");
									_this1.turtleParameters.push(radius2);
									_this1.turtleParameters.push(degrees1);
									_this1.turtleParameters.push(sides);
								}
							} else {
								var beta1 = degrees1 * Math.PI / 180 / sides;
								var alpha1 = (Math.PI - beta1) / 2;
								var rotate1 = -(Math.PI / 2 - alpha1);
								var baseLength1 = 0.5 * radius2 * Math.sin(beta1 / 2);
								var ox2 = _this1.x;
								var oy2 = _this1.y;
								var arr2 = [];
								arr2.push(_this1.x);
								arr2.push(_this1.y);
								var _g5 = 0;
								while(_g5 < 48) {
									var i4 = _g5++;
									_this1.rotation += rotate1;
									var wasHistoryOn2 = _this1.turtleHistoryOn;
									_this1.turtleHistoryOn = false;
									if(_this1.turtleHistoryOn) {
										_this1.historyAdd("FORWARD");
										_this1.historyParameters.push(baseLength1);
									}
									if(_this1.repeatCommands) {
										_this1.turtleCommands.push("FORWARD");
										_this1.turtleParameters.push(baseLength1);
									} else {
										var nx2 = _this1.x + baseLength1 * Math.cos(_this1.rotation);
										var ny2 = _this1.y + baseLength1 * Math.sin(_this1.rotation);
										if(_this1.penIsDown) {
											_this1.lastDistance = baseLength1;
											_this1.lineTo(nx2,ny2);
										} else {
											if(_this1.endLine == 2 || _this1.endLine == 3) {
												_this1.contour.end(_this1.width);
											}
											_this1.x = nx2;
											_this1.y = ny2;
											var l7 = _this1.points.length;
											_this1.points[l7] = [];
											_this1.points[l7][0] = nx2;
											_this1.points[l7][1] = ny2;
											_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
											_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
											_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d4 = _this1.dim[_this1.dim.length - 1];
											if(nx2 < d4.minX) {
												d4.minX = nx2;
											}
											if(nx2 > d4.maxX) {
												d4.maxX = nx2;
											}
											if(ny2 < d4.minY) {
												d4.minY = ny2;
											}
											if(ny2 > d4.maxY) {
												d4.maxY = ny2;
											}
											_this1.contour.reset();
										}
									}
									_this1.turtleHistoryOn = wasHistoryOn2;
									if(_this1.fill) {
										arr2.push(_this1.x);
										arr2.push(_this1.y);
									}
								}
								if(_this1.fill) {
									var cx2 = (ox2 + arr2[arr2.length - 2]) / 2;
									var cy2 = (oy2 + arr2[arr2.length - 1]) / 2;
									var l8 = arr2.length;
									var i5 = 2;
									var lx1 = 0.;
									var ly1 = 0.;
									_this1.pen.triangle2DFill(ox2,oy2,arr2[0],arr2[1],cx2,cy2);
									while(i5 < l8) {
										if(i5 > 2) {
											_this1.pen.triangle2DFill(lx1,ly1,arr2[i5],arr2[i5 + 1],cx2,cy2);
										}
										lx1 = arr2[i5];
										ly1 = arr2[i5 + 1];
										i5 += 2;
									}
								}
								arr2.length = 0;
							}
						}
						j += 3;
						break;
					case "BACKWARD":
						var distance1 = v[j];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("BACKWARD");
							_this1.historyParameters.push(distance1);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("BACKWARD");
							_this1.turtleParameters.push(distance1);
						} else {
							var nx3 = _this1.x + distance1 * Math.cos(_this1.rotation + Math.PI);
							var ny3 = _this1.y + distance1 * Math.sin(_this1.rotation + Math.PI);
							if(_this1.penIsDown) {
								_this1.lineTo(nx3,ny3);
							} else {
								if(_this1.endLine == 2 || _this1.endLine == 3) {
									_this1.contour.end(_this1.width);
								}
								_this1.x = nx3;
								_this1.y = ny3;
								var l9 = _this1.points.length;
								_this1.points[l9] = [];
								_this1.points[l9][0] = nx3;
								_this1.points[l9][1] = ny3;
								_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
								_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
								_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d5 = _this1.dim[_this1.dim.length - 1];
								if(nx3 < d5.minX) {
									d5.minX = nx3;
								}
								if(nx3 > d5.maxX) {
									d5.maxX = nx3;
								}
								if(ny3 < d5.minY) {
									d5.minY = ny3;
								}
								if(ny3 > d5.maxY) {
									d5.maxY = ny3;
								}
								_this1.contour.reset();
							}
						}
						++j;
						break;
					case "BEGIN_REPEAT":
						break;
					case "BLACK":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("BLACK");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("BLACK");
						} else {
							_this1.pen.currentColor = -16777216;
						}
						break;
					case "BLUE":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("BLUE");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("BLUE");
						} else {
							_this1.pen.currentColor = -16776961;
						}
						break;
					case "BROWN":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("BROWN");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("BROWN");
						} else {
							_this1.pen.currentColor = -6594501;
						}
						break;
					case "CIRCLE":
						var radius3 = v[j];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("CIRCLE");
							_this1.historyParameters.push(radius3);
						}
						if(radius3 != 0) {
							if(_this1.repeatCommands) {
								_this1.turtleCommands.push("CIRCLE");
								_this1.turtleParameters.push(radius3);
							} else {
								var beta2 = 2 * Math.PI / 24;
								var alpha2 = (Math.PI - beta2) / 2;
								var rotate2 = -(Math.PI / 2 - alpha2);
								var baseLength2 = 0.5 * radius3 * Math.sin(beta2 / 2);
								var ox3 = _this1.x;
								var oy3 = _this1.y;
								var arr3 = [];
								var _g6 = 0;
								while(_g6 < 48) {
									var i6 = _g6++;
									_this1.rotation += rotate2;
									var wasHistoryOn3 = _this1.turtleHistoryOn;
									_this1.turtleHistoryOn = false;
									if(_this1.turtleHistoryOn) {
										_this1.historyAdd("FORWARD");
										_this1.historyParameters.push(baseLength2);
									}
									if(_this1.repeatCommands) {
										_this1.turtleCommands.push("FORWARD");
										_this1.turtleParameters.push(baseLength2);
									} else {
										var nx4 = _this1.x + baseLength2 * Math.cos(_this1.rotation);
										var ny4 = _this1.y + baseLength2 * Math.sin(_this1.rotation);
										if(_this1.penIsDown) {
											_this1.lastDistance = baseLength2;
											_this1.lineTo(nx4,ny4);
										} else {
											if(_this1.endLine == 2 || _this1.endLine == 3) {
												_this1.contour.end(_this1.width);
											}
											_this1.x = nx4;
											_this1.y = ny4;
											var l10 = _this1.points.length;
											_this1.points[l10] = [];
											_this1.points[l10][0] = nx4;
											_this1.points[l10][1] = ny4;
											_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
											_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
											_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d6 = _this1.dim[_this1.dim.length - 1];
											if(nx4 < d6.minX) {
												d6.minX = nx4;
											}
											if(nx4 > d6.maxX) {
												d6.maxX = nx4;
											}
											if(ny4 < d6.minY) {
												d6.minY = ny4;
											}
											if(ny4 > d6.maxY) {
												d6.maxY = ny4;
											}
											_this1.contour.reset();
										}
									}
									_this1.turtleHistoryOn = wasHistoryOn3;
									if(_this1.fill) {
										arr3.push(_this1.x);
										arr3.push(_this1.y);
									}
								}
								if(_this1.fill) {
									var cx3 = (ox3 + arr3[arr3.length - 2]) / 2;
									var cy3 = (oy3 + arr3[arr3.length - 1]) / 2;
									var l11 = arr3.length;
									var i7 = 2;
									var lx2 = 0.;
									var ly2 = 0.;
									while(i7 < l11) {
										if(i7 > 2) {
											_this1.pen.triangle2DFill(lx2,ly2,arr3[i7],arr3[i7 + 1],cx3,cy3);
										}
										lx2 = arr3[i7];
										ly2 = arr3[i7 + 1];
										i7 += 2;
									}
								}
								arr3.length = 0;
							}
						}
						++j;
						break;
					case "CIRCLE_SIDES":
						var radius4 = v[j];
						var sides1 = v[j + 1];
						if(sides1 == null) {
							sides1 = 24;
						}
						if(_this1.turtleHistoryOn) {
							if(sides1 == 24) {
								_this1.historyAdd("CIRCLE");
								_this1.historyParameters.push(radius4);
							} else {
								_this1.historyAdd("CIRCLE_SIDES");
								_this1.historyParameters.push(radius4);
								_this1.historyParameters.push(sides1);
							}
						}
						if(radius4 != 0) {
							if(_this1.repeatCommands) {
								if(sides1 == 24) {
									_this1.turtleCommands.push("CIRCLE");
									_this1.turtleParameters.push(radius4);
								} else {
									_this1.turtleCommands.push("CIRCLE_SIDES");
									_this1.turtleParameters.push(radius4);
									_this1.turtleParameters.push(sides1);
								}
							} else {
								var beta3 = 2 * Math.PI / sides1;
								var alpha3 = (Math.PI - beta3) / 2;
								var rotate3 = -(Math.PI / 2 - alpha3);
								var baseLength3 = 0.5 * radius4 * Math.sin(beta3 / 2);
								var ox4 = _this1.x;
								var oy4 = _this1.y;
								var arr4 = [];
								var _g7 = 0;
								while(_g7 < 48) {
									var i8 = _g7++;
									_this1.rotation += rotate3;
									var wasHistoryOn4 = _this1.turtleHistoryOn;
									_this1.turtleHistoryOn = false;
									if(_this1.turtleHistoryOn) {
										_this1.historyAdd("FORWARD");
										_this1.historyParameters.push(baseLength3);
									}
									if(_this1.repeatCommands) {
										_this1.turtleCommands.push("FORWARD");
										_this1.turtleParameters.push(baseLength3);
									} else {
										var nx5 = _this1.x + baseLength3 * Math.cos(_this1.rotation);
										var ny5 = _this1.y + baseLength3 * Math.sin(_this1.rotation);
										if(_this1.penIsDown) {
											_this1.lastDistance = baseLength3;
											_this1.lineTo(nx5,ny5);
										} else {
											if(_this1.endLine == 2 || _this1.endLine == 3) {
												_this1.contour.end(_this1.width);
											}
											_this1.x = nx5;
											_this1.y = ny5;
											var l12 = _this1.points.length;
											_this1.points[l12] = [];
											_this1.points[l12][0] = nx5;
											_this1.points[l12][1] = ny5;
											_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
											_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
											_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d7 = _this1.dim[_this1.dim.length - 1];
											if(nx5 < d7.minX) {
												d7.minX = nx5;
											}
											if(nx5 > d7.maxX) {
												d7.maxX = nx5;
											}
											if(ny5 < d7.minY) {
												d7.minY = ny5;
											}
											if(ny5 > d7.maxY) {
												d7.maxY = ny5;
											}
											_this1.contour.reset();
										}
									}
									_this1.turtleHistoryOn = wasHistoryOn4;
									if(_this1.fill) {
										arr4.push(_this1.x);
										arr4.push(_this1.y);
									}
								}
								if(_this1.fill) {
									var cx4 = (ox4 + arr4[arr4.length - 2]) / 2;
									var cy4 = (oy4 + arr4[arr4.length - 1]) / 2;
									var l13 = arr4.length;
									var i9 = 2;
									var lx3 = 0.;
									var ly3 = 0.;
									while(i9 < l13) {
										if(i9 > 2) {
											_this1.pen.triangle2DFill(lx3,ly3,arr4[i9],arr4[i9 + 1],cx4,cy4);
										}
										lx3 = arr4[i9];
										ly3 = arr4[i9 + 1];
										i9 += 2;
									}
								}
								arr4.length = 0;
							}
						}
						j += 2;
						break;
					case "CYAN":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("CYAN");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("CYAN");
						} else {
							_this1.pen.currentColor = -16711681;
						}
						break;
					case "DARKISH_BLUE":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("DARKISH_BLUE");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("DARKISH_BLUE");
						} else {
							_this1.pen.currentColor = -8864837;
						}
						break;
					case "DARK_GREEN":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("DARK_GREEN");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("DARK_GREEN");
						} else {
							_this1.pen.currentColor = -10182080;
						}
						break;
					case "EAST":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("WEST");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("EAST");
						} else {
							_this1.rotation = Math.PI;
						}
						break;
					case "END_REPEAT":
						break;
					case "FILL_OFF":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("FILL_OFF");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("FILL_OFF");
						} else {
							_this1.fill = false;
						}
						break;
					case "FILL_ON":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("FILL_ON");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("FILL_ON");
						} else {
							_this1.fill = true;
						}
						break;
					case "FORWARD":
						var distance3 = v[j];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("FORWARD");
							_this1.historyParameters.push(distance3);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("FORWARD");
							_this1.turtleParameters.push(distance3);
						} else {
							var nx6 = _this1.x + distance3 * Math.cos(_this1.rotation);
							var ny6 = _this1.y + distance3 * Math.sin(_this1.rotation);
							if(_this1.penIsDown) {
								_this1.lastDistance = distance3;
								_this1.lineTo(nx6,ny6);
							} else {
								if(_this1.endLine == 2 || _this1.endLine == 3) {
									_this1.contour.end(_this1.width);
								}
								_this1.x = nx6;
								_this1.y = ny6;
								var l14 = _this1.points.length;
								_this1.points[l14] = [];
								_this1.points[l14][0] = nx6;
								_this1.points[l14][1] = ny6;
								_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
								_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
								_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d8 = _this1.dim[_this1.dim.length - 1];
								if(nx6 < d8.minX) {
									d8.minX = nx6;
								}
								if(nx6 > d8.maxX) {
									d8.maxX = nx6;
								}
								if(ny6 < d8.minY) {
									d8.minY = ny6;
								}
								if(ny6 > d8.maxY) {
									d8.maxY = ny6;
								}
								_this1.contour.reset();
							}
						}
						++j;
						break;
					case "FORWARD_CHANGE":
						var deltaDistance = v[j];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("FORWARD_CHANGE");
							_this1.historyParameters.push(deltaDistance);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("FORWARD_CHANGE");
							_this1.turtleParameters.push(deltaDistance);
						} else {
							var distance4 = _this1.lastDistance + deltaDistance;
							var nx7 = _this1.x + distance4 * Math.cos(_this1.rotation);
							var ny7 = _this1.y + distance4 * Math.sin(_this1.rotation);
							if(_this1.penIsDown) {
								_this1.lastDistance = distance4 + deltaDistance;
								_this1.lineTo(nx7,ny7);
							} else {
								if(_this1.endLine == 2 || _this1.endLine == 3) {
									_this1.contour.end(_this1.width);
								}
								_this1.x = nx7;
								_this1.y = ny7;
								var l15 = _this1.points.length;
								_this1.points[l15] = [];
								_this1.points[l15][0] = nx7;
								_this1.points[l15][1] = ny7;
								_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
								_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
								_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d9 = _this1.dim[_this1.dim.length - 1];
								if(nx7 < d9.minX) {
									d9.minX = nx7;
								}
								if(nx7 > d9.maxX) {
									d9.maxX = nx7;
								}
								if(ny7 < d9.minY) {
									d9.minY = ny7;
								}
								if(ny7 > d9.maxY) {
									d9.maxY = ny7;
								}
								_this1.contour.reset();
							}
						}
						++j;
						break;
					case "FORWARD_FACTOR":
						var factor = v[j];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("FORWARD_FACTOR");
							_this1.historyParameters.push(factor);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("FORWARD_FACTOR");
							_this1.turtleParameters.push(factor);
						} else {
							var distance5 = _this1.lastDistance * factor;
							var nx8 = _this1.x + distance5 * Math.cos(_this1.rotation);
							var ny8 = _this1.y + distance5 * Math.sin(_this1.rotation);
							if(_this1.penIsDown) {
								_this1.lastDistance = distance5;
								_this1.lineTo(nx8,ny8);
							} else {
								if(_this1.endLine == 2 || _this1.endLine == 3) {
									_this1.contour.end(_this1.width);
								}
								_this1.x = nx8;
								_this1.y = ny8;
								var l16 = _this1.points.length;
								_this1.points[l16] = [];
								_this1.points[l16][0] = nx8;
								_this1.points[l16][1] = ny8;
								_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
								_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
								_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d10 = _this1.dim[_this1.dim.length - 1];
								if(nx8 < d10.minX) {
									d10.minX = nx8;
								}
								if(nx8 > d10.maxX) {
									d10.maxX = nx8;
								}
								if(ny8 < d10.minY) {
									d10.minY = ny8;
								}
								if(ny8 > d10.maxY) {
									d10.maxY = ny8;
								}
								_this1.contour.reset();
							}
						}
						++j;
						break;
					case "GREEN":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("GREEN");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("GREEN");
						} else {
							_this1.pen.currentColor = -16711936;
						}
						break;
					case "GREY":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("GREY");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("GREY");
						} else {
							_this1.pen.currentColor = -4737097;
						}
						break;
					case "LEFT":
						var degrees2 = v[j];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("LEFT");
							_this1.historyParameters.push(degrees2);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("LEFT");
							_this1.turtleParameters.push(degrees2);
						} else {
							_this1.rotation -= degrees2 * Math.PI / 180;
						}
						++j;
						break;
					case "LIGHT_BROWN":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("LIGHT_BROWN");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("LIGHT_BROWN");
						} else {
							_this1.pen.currentColor = -3831790;
						}
						break;
					case "MAGENTA":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("MAGENTA");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("MAGENTA");
						} else {
							_this1.pen.currentColor = -65281;
						}
						break;
					case "MOVE_PEN":
						var distance6 = v[j];
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("MOVE_PEN");
							_this1.turtleParameters.push(distance6);
						} else if(_this1.penIsDown) {
							if(_this1.turtleHistoryOn) {
								_this1.historyAdd("PEN_UP");
							}
							if(_this1.repeatCommands) {
								_this1.turtleCommands.push("PEN_UP");
							} else {
								_this1.penIsDown = false;
							}
							if(_this1.turtleHistoryOn) {
								_this1.historyAdd("FORWARD");
								_this1.historyParameters.push(distance6);
							}
							if(_this1.repeatCommands) {
								_this1.turtleCommands.push("FORWARD");
								_this1.turtleParameters.push(distance6);
							} else {
								var nx9 = _this1.x + distance6 * Math.cos(_this1.rotation);
								var ny9 = _this1.y + distance6 * Math.sin(_this1.rotation);
								if(_this1.penIsDown) {
									_this1.lastDistance = distance6;
									_this1.lineTo(nx9,ny9);
								} else {
									if(_this1.endLine == 2 || _this1.endLine == 3) {
										_this1.contour.end(_this1.width);
									}
									_this1.x = nx9;
									_this1.y = ny9;
									var l17 = _this1.points.length;
									_this1.points[l17] = [];
									_this1.points[l17][0] = nx9;
									_this1.points[l17][1] = ny9;
									_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
									_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
									_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d11 = _this1.dim[_this1.dim.length - 1];
									if(nx9 < d11.minX) {
										d11.minX = nx9;
									}
									if(nx9 > d11.maxX) {
										d11.maxX = nx9;
									}
									if(ny9 < d11.minY) {
										d11.minY = ny9;
									}
									if(ny9 > d11.maxY) {
										d11.maxY = ny9;
									}
									_this1.contour.reset();
								}
							}
							if(_this1.turtleHistoryOn) {
								_this1.historyAdd("PEN_DOWN");
							}
							if(_this1.repeatCommands) {
								_this1.turtleCommands.push("PEN_DOWN");
							} else {
								_this1.penIsDown = true;
							}
						} else {
							if(_this1.turtleHistoryOn) {
								_this1.historyAdd("FORWARD");
								_this1.historyParameters.push(distance6);
							}
							if(_this1.repeatCommands) {
								_this1.turtleCommands.push("FORWARD");
								_this1.turtleParameters.push(distance6);
							} else {
								var nx10 = _this1.x + distance6 * Math.cos(_this1.rotation);
								var ny10 = _this1.y + distance6 * Math.sin(_this1.rotation);
								if(_this1.penIsDown) {
									_this1.lastDistance = distance6;
									_this1.lineTo(nx10,ny10);
								} else {
									if(_this1.endLine == 2 || _this1.endLine == 3) {
										_this1.contour.end(_this1.width);
									}
									_this1.x = nx10;
									_this1.y = ny10;
									var l18 = _this1.points.length;
									_this1.points[l18] = [];
									_this1.points[l18][0] = nx10;
									_this1.points[l18][1] = ny10;
									_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
									_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
									_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d12 = _this1.dim[_this1.dim.length - 1];
									if(nx10 < d12.minX) {
										d12.minX = nx10;
									}
									if(nx10 > d12.maxX) {
										d12.maxX = nx10;
									}
									if(ny10 < d12.minY) {
										d12.minY = ny10;
									}
									if(ny10 > d12.maxY) {
										d12.maxY = ny10;
									}
									_this1.contour.reset();
								}
							}
						}
						++j;
						break;
					case "NORTH":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("NORTH");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("NORTH");
						} else {
							_this1.rotation = -Math.PI / 2;
						}
						break;
					case "ORANGE":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("ORANGE");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("ORANGE");
						} else {
							_this1.pen.currentColor = -23808;
						}
						break;
					case "PEN_COLOR":
						var r = v[j];
						var g = v[j + 1];
						var b1 = v[j + 2];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_COLOR");
							_this1.historyParameters.push(r);
							_this1.historyParameters.push(g);
							_this1.historyParameters.push(b1);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_COLOR");
							_this1.turtleParameters.push(r);
							_this1.turtleParameters.push(g);
							_this1.turtleParameters.push(b1);
						} else {
							_this1.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b1 * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_B":
						var r1 = v[j];
						var g1 = v[j + 1];
						var b2 = v[j + 2];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_COLOR_B");
							_this1.historyParameters.push(r1);
							_this1.historyParameters.push(g1);
							_this1.historyParameters.push(b2);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_COLOR_B");
							_this1.turtleParameters.push(r1);
							_this1.turtleParameters.push(g1);
							_this1.turtleParameters.push(b2);
						} else {
							_this1.pen.colorB = Math.round(255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b2 * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_C":
						var r2 = v[j];
						var g2 = v[j + 1];
						var b3 = v[j + 2];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_COLOR_C");
							_this1.historyParameters.push(r2);
							_this1.historyParameters.push(g2);
							_this1.historyParameters.push(b3);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_COLOR_C");
							_this1.turtleParameters.push(r2);
							_this1.turtleParameters.push(g2);
							_this1.turtleParameters.push(b3);
						} else {
							_this1.pen.colorC = Math.round(255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b3 * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE":
						var r3 = v[j];
						var g3 = v[j + 1];
						var b4 = v[j + 2];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_COLOR_CHANGE");
							_this1.historyParameters.push(r3);
							_this1.historyParameters.push(g3);
							_this1.historyParameters.push(b4);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_COLOR_CHANGE");
							_this1.turtleParameters.push(r3);
							_this1.turtleParameters.push(g3);
							_this1.turtleParameters.push(b4);
						} else {
							var c = _this1.pen.currentColor;
							var r0 = (c >> 16 & 255) / 255;
							var g0 = (c >> 8 & 255) / 255;
							var b0 = (c & 255) / 255;
							_this1.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r3) * 255) << 16 | Math.round((g0 + g3) * 255) << 8 | Math.round((b0 + b4) * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE_B":
						var r4 = v[j];
						var g4 = v[j + 1];
						var b5 = v[j + 2];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_COLOR_CHANGE_B");
							_this1.historyParameters.push(r4);
							_this1.historyParameters.push(g4);
							_this1.historyParameters.push(b5);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_COLOR_CHANGE_B");
							_this1.turtleParameters.push(r4);
							_this1.turtleParameters.push(g4);
							_this1.turtleParameters.push(b5);
						} else {
							var c1 = _this1.pen.colorB;
							var r01 = (c1 >> 16 & 255) / 255;
							var g01 = (c1 >> 8 & 255) / 255;
							var b01 = (c1 & 255) / 255;
							_this1.pen.colorB = Math.round(255) << 24 | Math.round((r01 + r4) * 255) << 16 | Math.round((g01 + g4) * 255) << 8 | Math.round((b01 + b5) * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE_C":
						var r5 = v[j];
						var g5 = v[j + 1];
						var b6 = v[j + 2];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_COLOR_CHANGE_C");
							_this1.historyParameters.push(r5);
							_this1.historyParameters.push(g5);
							_this1.historyParameters.push(b6);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_COLOR_CHANGE_C");
							_this1.turtleParameters.push(r5);
							_this1.turtleParameters.push(g5);
							_this1.turtleParameters.push(b6);
						} else {
							var c2 = _this1.pen.colorC;
							var r02 = (c2 >> 16 & 255) / 255;
							var g02 = (c2 >> 8 & 255) / 255;
							var b02 = (c2 & 255) / 255;
							_this1.pen.colorC = Math.round(255) << 24 | Math.round((r02 + r5) * 255) << 16 | Math.round((g02 + g5) * 255) << 8 | Math.round((b02 + b6) * 255);
						}
						j += 3;
						break;
					case "PEN_DOWN":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_DOWN");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_DOWN");
						} else {
							_this1.penIsDown = true;
						}
						break;
					case "PEN_SIZE":
						var w = v[j];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_SIZE");
							_this1.historyParameters.push(w);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_SIZE");
							_this1.turtleParameters.push(w);
						} else {
							_this1.width = w;
						}
						++j;
						break;
					case "PEN_SIZE_CHANGE":
						var dw = v[j];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_SIZE_CHANGE");
							_this1.historyParameters.push(dw);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_SIZE_CHANGE");
							_this1.turtleParameters.push(dw);
						} else {
							_this1.width += dw;
						}
						++j;
						break;
					case "PEN_SIZE_FACTOR":
						var factor1 = v[j];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_SIZE_FACTOR");
							_this1.historyParameters.push(factor1);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_SIZE_FACTOR");
							_this1.turtleParameters.push(factor1);
						} else {
							_this1.width *= factor1;
						}
						++j;
						break;
					case "PEN_UP":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_UP");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_UP");
						} else {
							_this1.penIsDown = false;
						}
						break;
					case "PLUM":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PLUM");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PLUM");
						} else {
							_this1.pen.currentColor = -7310896;
						}
						break;
					case "RED":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("RED");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("RED");
						} else {
							_this1.pen.currentColor = -65536;
						}
						break;
					case "RIGHT":
						var degrees3 = v[j];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("RIGHT");
							_this1.historyParameters.push(degrees3);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("RIGHT");
							_this1.turtleParameters.push(degrees3);
						} else {
							_this1.rotation += degrees3 * Math.PI / 180;
						}
						++j;
						break;
					case "SET_ANGLE":
						var degrees4 = v[j];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("SET_ANGLE");
							_this1.historyParameters.push(degrees4);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("SET_ANGLE");
							_this1.turtleParameters.push(degrees4);
						} else {
							_this1.rotation = -Math.PI / 2;
							_this1.rotation += degrees4 * Math.PI / 180;
						}
						++j;
						break;
					case "SET_POSITION":
						var x2 = v[j];
						var y2 = v[j + 1];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("SET_POSITION");
							_this1.historyParameters.push(x2);
							_this1.historyParameters.push(y2);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("SET_POSITION");
							_this1.turtleParameters.push(x2);
							_this1.turtleParameters.push(y2);
						} else {
							if(_this1.endLine == 2 || _this1.endLine == 3) {
								_this1.contour.end(_this1.width);
							}
							_this1.x = x2;
							_this1.y = y2;
							var l19 = _this1.points.length;
							_this1.points[l19] = [];
							_this1.points[l19][0] = x2;
							_this1.points[l19][1] = y2;
							_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
							_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
							_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d13 = _this1.dim[_this1.dim.length - 1];
							if(x2 < d13.minX) {
								d13.minX = x2;
							}
							if(x2 > d13.maxX) {
								d13.maxX = x2;
							}
							if(y2 < d13.minY) {
								d13.minY = y2;
							}
							if(y2 > d13.maxY) {
								d13.maxY = y2;
							}
							_this1.contour.reset();
						}
						j += 2;
						break;
					case "SOUTH":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("SOUTH");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("SOUTH");
						} else {
							_this1.rotation = Math.PI / 2;
						}
						break;
					case "TAN":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("TAN");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("TAN");
						} else {
							_this1.pen.currentColor = -27273;
						}
						break;
					case "TRIANGLE_ARCH":
						var distance7 = v[j];
						var distance21 = v[j + 1];
						var radius5 = v[j + 2];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("TRIANGLE_ARCH");
							_this1.historyParameters.push(distance7);
							_this1.historyParameters.push(distance21);
							_this1.historyParameters.push(radius5);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("TRIANGLE_ARCH");
							_this1.turtleParameters.push(distance7);
							_this1.turtleParameters.push(distance21);
							_this1.turtleParameters.push(radius5);
						} else {
							var nx11 = _this1.x + distance7 * Math.cos(_this1.rotation);
							var ny11 = _this1.y + distance7 * Math.sin(_this1.rotation);
							if(_this1.penIsDown) {
								var thruX1 = _this1.x + distance21 * Math.cos(_this1.rotation) - radius5 * Math.cos(_this1.rotation + Math.PI / 2);
								var thruY1 = _this1.y + distance21 * Math.sin(_this1.rotation) - radius5 * Math.sin(_this1.rotation + Math.PI / 2);
								if(_this1.fill) {
									_this1.pen.triangle2DFill(_this1.x,_this1.y,thruX1,thruY1,nx11,ny11);
								}
								_this1.lineTo(thruX1,thruY1);
								_this1.lineTo(nx11,ny11);
								if(_this1.fill) {
									_this1.lineTo(_this1.x,_this1.y);
								}
								if(_this1.endLine == 2 || _this1.endLine == 3) {
									_this1.contour.end(_this1.width);
								}
								_this1.x = nx11;
								_this1.y = ny11;
								var l20 = _this1.points.length;
								_this1.points[l20] = [];
								_this1.points[l20][0] = nx11;
								_this1.points[l20][1] = ny11;
								_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
								_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
								_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d14 = _this1.dim[_this1.dim.length - 1];
								if(nx11 < d14.minX) {
									d14.minX = nx11;
								}
								if(nx11 > d14.maxX) {
									d14.maxX = nx11;
								}
								if(ny11 < d14.minY) {
									d14.minY = ny11;
								}
								if(ny11 > d14.maxY) {
									d14.maxY = ny11;
								}
								_this1.contour.reset();
							} else {
								if(_this1.endLine == 2 || _this1.endLine == 3) {
									_this1.contour.end(_this1.width);
								}
								_this1.x = nx11;
								_this1.y = ny11;
								var l21 = _this1.points.length;
								_this1.points[l21] = [];
								_this1.points[l21][0] = nx11;
								_this1.points[l21][1] = ny11;
								_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
								_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
								_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d15 = _this1.dim[_this1.dim.length - 1];
								if(nx11 < d15.minX) {
									d15.minX = nx11;
								}
								if(nx11 > d15.maxX) {
									d15.maxX = nx11;
								}
								if(ny11 < d15.minY) {
									d15.minY = ny11;
								}
								if(ny11 > d15.maxY) {
									d15.maxY = ny11;
								}
								_this1.contour.reset();
							}
						}
						j += 3;
						break;
					case "WEST":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("WEST");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("WEST");
						} else {
							_this1.rotation = 0;
						}
						break;
					case "WHITE":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("WHITE");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("WHITE");
						} else {
							_this1.pen.currentColor = -1;
						}
						break;
					case "YELLOW":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("YELLOW");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("YELLOW");
						} else {
							_this1.pen.currentColor = -256;
						}
						break;
					}
				}
				j = 0;
			}
			_this1.turtleHistoryOn = wasHistoryOn;
			_this1.turtleCommands.length = 0;
			_this1.turtleParameters.length = 0;
		}
		_this1.repeatCount = Math.round(40);
		_this1.repeatCommands = true;
		_this1.turtleCommands.length = 0;
		_this1.turtleParameters.length = 0;
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("RIGHT");
			_this.historyParameters.push(a);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("RIGHT");
			_this.turtleParameters.push(a);
		} else {
			_this.rotation += a * Math.PI / 180;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("FORWARD_FACTOR");
			_this1.historyParameters.push(.98);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("FORWARD_FACTOR");
			_this1.turtleParameters.push(.98);
		} else {
			var distance = _this1.lastDistance * .98;
			var nx = _this1.x + distance * Math.cos(_this1.rotation);
			var ny = _this1.y + distance * Math.sin(_this1.rotation);
			if(_this1.penIsDown) {
				_this1.lastDistance = distance;
				_this1.lineTo(nx,ny);
			} else {
				if(_this1.endLine == 2 || _this1.endLine == 3) {
					_this1.contour.end(_this1.width);
				}
				_this1.x = nx;
				_this1.y = ny;
				var l = _this1.points.length;
				_this1.points[l] = [];
				_this1.points[l][0] = nx;
				_this1.points[l][1] = ny;
				_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
				_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
				_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this1.dim[_this1.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this1.contour.reset();
			}
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("RIGHT");
			_this.historyParameters.push(b);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("RIGHT");
			_this.turtleParameters.push(b);
		} else {
			_this.rotation += b * Math.PI / 180;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("FORWARD_FACTOR");
			_this1.historyParameters.push(.98);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("FORWARD_FACTOR");
			_this1.turtleParameters.push(.98);
		} else {
			var distance = _this1.lastDistance * .98;
			var nx = _this1.x + distance * Math.cos(_this1.rotation);
			var ny = _this1.y + distance * Math.sin(_this1.rotation);
			if(_this1.penIsDown) {
				_this1.lastDistance = distance;
				_this1.lineTo(nx,ny);
			} else {
				if(_this1.endLine == 2 || _this1.endLine == 3) {
					_this1.contour.end(_this1.width);
				}
				_this1.x = nx;
				_this1.y = ny;
				var l = _this1.points.length;
				_this1.points[l] = [];
				_this1.points[l][0] = nx;
				_this1.points[l][1] = ny;
				_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
				_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
				_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this1.dim[_this1.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this1.contour.reset();
			}
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("PEN_SIZE_CHANGE");
			_this.historyParameters.push(-0.18);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("PEN_SIZE_CHANGE");
			_this.turtleParameters.push(-0.18);
		} else {
			_this.width += -0.18;
		}
		var _this1 = _this;
		var degrees = a * 2 + b;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("RIGHT");
			_this1.historyParameters.push(degrees);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("RIGHT");
			_this1.turtleParameters.push(degrees);
		} else {
			_this1.rotation += degrees * Math.PI / 180;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("RIGHT");
			_this.historyParameters.push(a);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("RIGHT");
			_this.turtleParameters.push(a);
		} else {
			_this.rotation += a * Math.PI / 180;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("FORWARD_FACTOR");
			_this1.historyParameters.push(.98);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("FORWARD_FACTOR");
			_this1.turtleParameters.push(.98);
		} else {
			var distance = _this1.lastDistance * .98;
			var nx = _this1.x + distance * Math.cos(_this1.rotation);
			var ny = _this1.y + distance * Math.sin(_this1.rotation);
			if(_this1.penIsDown) {
				_this1.lastDistance = distance;
				_this1.lineTo(nx,ny);
			} else {
				if(_this1.endLine == 2 || _this1.endLine == 3) {
					_this1.contour.end(_this1.width);
				}
				_this1.x = nx;
				_this1.y = ny;
				var l = _this1.points.length;
				_this1.points[l] = [];
				_this1.points[l][0] = nx;
				_this1.points[l][1] = ny;
				_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
				_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
				_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this1.dim[_this1.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this1.contour.reset();
			}
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("RIGHT");
			_this.historyParameters.push(b);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("RIGHT");
			_this.turtleParameters.push(b);
		} else {
			_this.rotation += b * Math.PI / 180;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("FORWARD_FACTOR");
			_this1.historyParameters.push(.98);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("FORWARD_FACTOR");
			_this1.turtleParameters.push(.98);
		} else {
			var distance = _this1.lastDistance * .98;
			var nx = _this1.x + distance * Math.cos(_this1.rotation);
			var ny = _this1.y + distance * Math.sin(_this1.rotation);
			if(_this1.penIsDown) {
				_this1.lastDistance = distance;
				_this1.lineTo(nx,ny);
			} else {
				if(_this1.endLine == 2 || _this1.endLine == 3) {
					_this1.contour.end(_this1.width);
				}
				_this1.x = nx;
				_this1.y = ny;
				var l = _this1.points.length;
				_this1.points[l] = [];
				_this1.points[l][0] = nx;
				_this1.points[l][1] = ny;
				_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
				_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
				_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this1.dim[_this1.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this1.contour.reset();
			}
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("LEFT");
			_this.historyParameters.push(92);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("LEFT");
			_this.turtleParameters.push(92);
		} else {
			_this.rotation -= 92 * Math.PI / 180;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("PEN_SIZE_CHANGE");
			_this1.historyParameters.push(-0.18);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("PEN_SIZE_CHANGE");
			_this1.turtleParameters.push(-0.18);
		} else {
			_this1.width += -0.18;
		}
		var _this = _this1;
		_this.repeatCommands = false;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("END_REPEAT");
		}
		var wasHistoryOn = _this.turtleHistoryOn;
		_this.turtleHistoryOn = false;
		var v = _this.turtleParameters;
		var j = 0;
		var _g = 0;
		var _g1 = _this.repeatCount;
		while(_g < _g1) {
			var k = _g++;
			var _g2 = 0;
			var _g3 = _this.turtleCommands.length;
			while(_g2 < _g3) {
				var i = _g2++;
				var command = _this.turtleCommands[i];
				switch(command) {
				case "ARC":
					var radius = v[j];
					var degrees = v[j + 1];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("ARC");
						_this.historyParameters.push(radius);
						_this.historyParameters.push(degrees);
					}
					if(radius != 0) {
						if(_this.repeatCommands) {
							_this.turtleCommands.push("ARC");
							_this.turtleParameters.push(radius);
							_this.turtleParameters.push(degrees);
						} else {
							var beta = degrees * Math.PI / 180 / 24;
							var alpha = (Math.PI - beta) / 2;
							var rotate = -(Math.PI / 2 - alpha);
							var baseLength = 0.5 * radius * Math.sin(beta / 2);
							var ox = _this.x;
							var oy = _this.y;
							var arr = [];
							arr.push(_this.x);
							arr.push(_this.y);
							var _g4 = 0;
							while(_g4 < 48) {
								var i1 = _g4++;
								_this.rotation += rotate;
								var wasHistoryOn1 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength);
								} else {
									var nx = _this.x + baseLength * Math.cos(_this.rotation);
									var ny = _this.y + baseLength * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength;
										_this.lineTo(nx,ny);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx;
										_this.y = ny;
										var l = _this.points.length;
										_this.points[l] = [];
										_this.points[l][0] = nx;
										_this.points[l][1] = ny;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d = _this.dim[_this.dim.length - 1];
										if(nx < d.minX) {
											d.minX = nx;
										}
										if(nx > d.maxX) {
											d.maxX = nx;
										}
										if(ny < d.minY) {
											d.minY = ny;
										}
										if(ny > d.maxY) {
											d.maxY = ny;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn1;
								if(_this.fill) {
									arr.push(_this.x);
									arr.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx = (ox + arr[arr.length - 2]) / 2;
								var cy = (oy + arr[arr.length - 1]) / 2;
								var l1 = arr.length;
								var i2 = 2;
								var lx = 0.;
								var ly = 0.;
								_this.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
								while(i2 < l1) {
									if(i2 > 2) {
										_this.pen.triangle2DFill(lx,ly,arr[i2],arr[i2 + 1],cx,cy);
									}
									lx = arr[i2];
									ly = arr[i2 + 1];
									i2 += 2;
								}
							}
							arr.length = 0;
						}
					}
					j += 2;
					break;
				case "ARCH_BEZIER":
					var distance = v[j];
					var distance2 = v[j + 1];
					var radius1 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("ARCH_BEZIER");
						_this.historyParameters.push(distance);
						_this.historyParameters.push(distance2);
						_this.historyParameters.push(radius1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("ARCH_BEZIER");
						_this.turtleParameters.push(distance);
						_this.turtleParameters.push(distance2);
						_this.turtleParameters.push(radius1);
					} else {
						var nx1 = _this.x + distance * Math.cos(_this.rotation);
						var ny1 = _this.y + distance * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							var thruX = _this.x + distance2 * Math.cos(_this.rotation) - radius1 * Math.cos(_this.rotation + Math.PI / 2);
							var thruY = _this.y + distance2 * Math.sin(_this.rotation) - radius1 * Math.sin(_this.rotation + Math.PI / 2);
							var newx = 2 * thruX - 0.5 * (_this.x + nx1);
							var newy = 2 * thruY - 0.5 * (_this.y + ny1);
							_this.tempArr = [];
							var p = _this.tempArr;
							var ax = _this.x;
							var ay = _this.y;
							var x = ax - newx;
							var y = ay - newy;
							var x1 = newx - nx1;
							var y1 = newy - ny1;
							var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
							if(approxDistance == 0) {
								approxDistance = 0.000001;
							}
							var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
							var l2 = p.length;
							p[l2++] = ax;
							p[l2++] = ay;
							var t = step;
							while(t < 1.) {
								var u = 1 - t;
								p[l2++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx1;
								var u1 = 1 - t;
								p[l2++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny1;
								t += step;
							}
							p[l2++] = nx1;
							p[l2++] = ny1;
							var arr1 = _this.tempArr;
							var withMove = false;
							if(withMove == null) {
								withMove = true;
							}
							var l3 = arr1.length;
							var i3 = 2;
							if(withMove) {
								var x_ = arr1[0];
								var y_ = arr1[1];
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = x_;
								_this.y = y_;
								var l4 = _this.points.length;
								_this.points[l4] = [];
								_this.points[l4][0] = x_;
								_this.points[l4][1] = y_;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d1 = _this.dim[_this.dim.length - 1];
								if(x_ < d1.minX) {
									d1.minX = x_;
								}
								if(x_ > d1.maxX) {
									d1.maxX = x_;
								}
								if(y_ < d1.minY) {
									d1.minY = y_;
								}
								if(y_ > d1.maxY) {
									d1.maxY = y_;
								}
								_this.contour.reset();
							} else {
								_this.lineTo(arr1[0],arr1[1]);
							}
							var cx1 = (arr1[0] + arr1[l3 - 2]) / 2;
							var cy1 = (arr1[1] + arr1[l3 - 1]) / 2;
							var ox1 = _this.x;
							var oy1 = _this.y;
							while(i3 < l3) {
								if(_this.fill && _this.penIsDown) {
									if(i3 > 0 && i3 < l3 - 2) {
										_this.pen.triangle2DFill(arr1[i3 - 2],arr1[i3 - 1],arr1[i3],arr1[i3 + 1],cx1,cy1);
									}
								}
								_this.lineTo(arr1[i3],arr1[i3 + 1]);
								i3 += 2;
							}
							if(_this.fill && _this.penIsDown) {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = ox1;
								_this.y = oy1;
								var l5 = _this.points.length;
								_this.points[l5] = [];
								_this.points[l5][0] = ox1;
								_this.points[l5][1] = oy1;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d2 = _this.dim[_this.dim.length - 1];
								if(ox1 < d2.minX) {
									d2.minX = ox1;
								}
								if(ox1 > d2.maxX) {
									d2.maxX = ox1;
								}
								if(oy1 < d2.minY) {
									d2.minY = oy1;
								}
								if(oy1 > d2.maxY) {
									d2.maxY = oy1;
								}
								_this.contour.reset();
								_this.lineTo(arr1[l3 - 2],arr1[l3 - 1]);
							}
							_this.x = nx1;
							_this.y = ny1;
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx1;
							_this.y = ny1;
							var l6 = _this.points.length;
							_this.points[l6] = [];
							_this.points[l6][0] = nx1;
							_this.points[l6][1] = ny1;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d3 = _this.dim[_this.dim.length - 1];
							if(nx1 < d3.minX) {
								d3.minX = nx1;
							}
							if(nx1 > d3.maxX) {
								d3.maxX = nx1;
							}
							if(ny1 < d3.minY) {
								d3.minY = ny1;
							}
							if(ny1 > d3.maxY) {
								d3.maxY = ny1;
							}
							_this.contour.reset();
						}
					}
					j += 3;
					break;
				case "ARC_SIDES":
					var radius2 = v[j];
					var degrees1 = v[j + 1];
					var sides = v[j + 2];
					if(sides == null) {
						sides = 24;
					}
					if(_this.turtleHistoryOn) {
						if(sides == 24) {
							_this.historyAdd("ARC");
							_this.historyParameters.push(radius2);
							_this.historyParameters.push(degrees1);
						} else {
							_this.historyAdd("ARC_SIDES");
							_this.historyParameters.push(radius2);
							_this.historyParameters.push(degrees1);
							_this.historyParameters.push(sides);
						}
					}
					if(radius2 != 0) {
						if(_this.repeatCommands) {
							if(sides == 24) {
								_this.turtleCommands.push("ARC");
								_this.turtleParameters.push(radius2);
								_this.turtleParameters.push(degrees1);
							} else {
								_this.turtleCommands.push("ARC_SIDES");
								_this.turtleParameters.push(radius2);
								_this.turtleParameters.push(degrees1);
								_this.turtleParameters.push(sides);
							}
						} else {
							var beta1 = degrees1 * Math.PI / 180 / sides;
							var alpha1 = (Math.PI - beta1) / 2;
							var rotate1 = -(Math.PI / 2 - alpha1);
							var baseLength1 = 0.5 * radius2 * Math.sin(beta1 / 2);
							var ox2 = _this.x;
							var oy2 = _this.y;
							var arr2 = [];
							arr2.push(_this.x);
							arr2.push(_this.y);
							var _g5 = 0;
							while(_g5 < 48) {
								var i4 = _g5++;
								_this.rotation += rotate1;
								var wasHistoryOn2 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength1);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength1);
								} else {
									var nx2 = _this.x + baseLength1 * Math.cos(_this.rotation);
									var ny2 = _this.y + baseLength1 * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength1;
										_this.lineTo(nx2,ny2);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx2;
										_this.y = ny2;
										var l7 = _this.points.length;
										_this.points[l7] = [];
										_this.points[l7][0] = nx2;
										_this.points[l7][1] = ny2;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d4 = _this.dim[_this.dim.length - 1];
										if(nx2 < d4.minX) {
											d4.minX = nx2;
										}
										if(nx2 > d4.maxX) {
											d4.maxX = nx2;
										}
										if(ny2 < d4.minY) {
											d4.minY = ny2;
										}
										if(ny2 > d4.maxY) {
											d4.maxY = ny2;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn2;
								if(_this.fill) {
									arr2.push(_this.x);
									arr2.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx2 = (ox2 + arr2[arr2.length - 2]) / 2;
								var cy2 = (oy2 + arr2[arr2.length - 1]) / 2;
								var l8 = arr2.length;
								var i5 = 2;
								var lx1 = 0.;
								var ly1 = 0.;
								_this.pen.triangle2DFill(ox2,oy2,arr2[0],arr2[1],cx2,cy2);
								while(i5 < l8) {
									if(i5 > 2) {
										_this.pen.triangle2DFill(lx1,ly1,arr2[i5],arr2[i5 + 1],cx2,cy2);
									}
									lx1 = arr2[i5];
									ly1 = arr2[i5 + 1];
									i5 += 2;
								}
							}
							arr2.length = 0;
						}
					}
					j += 3;
					break;
				case "BACKWARD":
					var distance1 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BACKWARD");
						_this.historyParameters.push(distance1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BACKWARD");
						_this.turtleParameters.push(distance1);
					} else {
						var nx3 = _this.x + distance1 * Math.cos(_this.rotation + Math.PI);
						var ny3 = _this.y + distance1 * Math.sin(_this.rotation + Math.PI);
						if(_this.penIsDown) {
							_this.lineTo(nx3,ny3);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx3;
							_this.y = ny3;
							var l9 = _this.points.length;
							_this.points[l9] = [];
							_this.points[l9][0] = nx3;
							_this.points[l9][1] = ny3;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d5 = _this.dim[_this.dim.length - 1];
							if(nx3 < d5.minX) {
								d5.minX = nx3;
							}
							if(nx3 > d5.maxX) {
								d5.maxX = nx3;
							}
							if(ny3 < d5.minY) {
								d5.minY = ny3;
							}
							if(ny3 > d5.maxY) {
								d5.maxY = ny3;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "BEGIN_REPEAT":
					break;
				case "BLACK":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BLACK");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BLACK");
					} else {
						_this.pen.currentColor = -16777216;
					}
					break;
				case "BLUE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BLUE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BLUE");
					} else {
						_this.pen.currentColor = -16776961;
					}
					break;
				case "BROWN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BROWN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BROWN");
					} else {
						_this.pen.currentColor = -6594501;
					}
					break;
				case "CIRCLE":
					var radius3 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("CIRCLE");
						_this.historyParameters.push(radius3);
					}
					if(radius3 != 0) {
						if(_this.repeatCommands) {
							_this.turtleCommands.push("CIRCLE");
							_this.turtleParameters.push(radius3);
						} else {
							var beta2 = 2 * Math.PI / 24;
							var alpha2 = (Math.PI - beta2) / 2;
							var rotate2 = -(Math.PI / 2 - alpha2);
							var baseLength2 = 0.5 * radius3 * Math.sin(beta2 / 2);
							var ox3 = _this.x;
							var oy3 = _this.y;
							var arr3 = [];
							var _g6 = 0;
							while(_g6 < 48) {
								var i6 = _g6++;
								_this.rotation += rotate2;
								var wasHistoryOn3 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength2);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength2);
								} else {
									var nx4 = _this.x + baseLength2 * Math.cos(_this.rotation);
									var ny4 = _this.y + baseLength2 * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength2;
										_this.lineTo(nx4,ny4);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx4;
										_this.y = ny4;
										var l10 = _this.points.length;
										_this.points[l10] = [];
										_this.points[l10][0] = nx4;
										_this.points[l10][1] = ny4;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d6 = _this.dim[_this.dim.length - 1];
										if(nx4 < d6.minX) {
											d6.minX = nx4;
										}
										if(nx4 > d6.maxX) {
											d6.maxX = nx4;
										}
										if(ny4 < d6.minY) {
											d6.minY = ny4;
										}
										if(ny4 > d6.maxY) {
											d6.maxY = ny4;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn3;
								if(_this.fill) {
									arr3.push(_this.x);
									arr3.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx3 = (ox3 + arr3[arr3.length - 2]) / 2;
								var cy3 = (oy3 + arr3[arr3.length - 1]) / 2;
								var l11 = arr3.length;
								var i7 = 2;
								var lx2 = 0.;
								var ly2 = 0.;
								while(i7 < l11) {
									if(i7 > 2) {
										_this.pen.triangle2DFill(lx2,ly2,arr3[i7],arr3[i7 + 1],cx3,cy3);
									}
									lx2 = arr3[i7];
									ly2 = arr3[i7 + 1];
									i7 += 2;
								}
							}
							arr3.length = 0;
						}
					}
					++j;
					break;
				case "CIRCLE_SIDES":
					var radius4 = v[j];
					var sides1 = v[j + 1];
					if(sides1 == null) {
						sides1 = 24;
					}
					if(_this.turtleHistoryOn) {
						if(sides1 == 24) {
							_this.historyAdd("CIRCLE");
							_this.historyParameters.push(radius4);
						} else {
							_this.historyAdd("CIRCLE_SIDES");
							_this.historyParameters.push(radius4);
							_this.historyParameters.push(sides1);
						}
					}
					if(radius4 != 0) {
						if(_this.repeatCommands) {
							if(sides1 == 24) {
								_this.turtleCommands.push("CIRCLE");
								_this.turtleParameters.push(radius4);
							} else {
								_this.turtleCommands.push("CIRCLE_SIDES");
								_this.turtleParameters.push(radius4);
								_this.turtleParameters.push(sides1);
							}
						} else {
							var beta3 = 2 * Math.PI / sides1;
							var alpha3 = (Math.PI - beta3) / 2;
							var rotate3 = -(Math.PI / 2 - alpha3);
							var baseLength3 = 0.5 * radius4 * Math.sin(beta3 / 2);
							var ox4 = _this.x;
							var oy4 = _this.y;
							var arr4 = [];
							var _g7 = 0;
							while(_g7 < 48) {
								var i8 = _g7++;
								_this.rotation += rotate3;
								var wasHistoryOn4 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength3);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength3);
								} else {
									var nx5 = _this.x + baseLength3 * Math.cos(_this.rotation);
									var ny5 = _this.y + baseLength3 * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength3;
										_this.lineTo(nx5,ny5);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx5;
										_this.y = ny5;
										var l12 = _this.points.length;
										_this.points[l12] = [];
										_this.points[l12][0] = nx5;
										_this.points[l12][1] = ny5;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d7 = _this.dim[_this.dim.length - 1];
										if(nx5 < d7.minX) {
											d7.minX = nx5;
										}
										if(nx5 > d7.maxX) {
											d7.maxX = nx5;
										}
										if(ny5 < d7.minY) {
											d7.minY = ny5;
										}
										if(ny5 > d7.maxY) {
											d7.maxY = ny5;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn4;
								if(_this.fill) {
									arr4.push(_this.x);
									arr4.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx4 = (ox4 + arr4[arr4.length - 2]) / 2;
								var cy4 = (oy4 + arr4[arr4.length - 1]) / 2;
								var l13 = arr4.length;
								var i9 = 2;
								var lx3 = 0.;
								var ly3 = 0.;
								while(i9 < l13) {
									if(i9 > 2) {
										_this.pen.triangle2DFill(lx3,ly3,arr4[i9],arr4[i9 + 1],cx4,cy4);
									}
									lx3 = arr4[i9];
									ly3 = arr4[i9 + 1];
									i9 += 2;
								}
							}
							arr4.length = 0;
						}
					}
					j += 2;
					break;
				case "CYAN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("CYAN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("CYAN");
					} else {
						_this.pen.currentColor = -16711681;
					}
					break;
				case "DARKISH_BLUE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("DARKISH_BLUE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("DARKISH_BLUE");
					} else {
						_this.pen.currentColor = -8864837;
					}
					break;
				case "DARK_GREEN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("DARK_GREEN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("DARK_GREEN");
					} else {
						_this.pen.currentColor = -10182080;
					}
					break;
				case "EAST":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("WEST");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("EAST");
					} else {
						_this.rotation = Math.PI;
					}
					break;
				case "END_REPEAT":
					break;
				case "FILL_OFF":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FILL_OFF");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FILL_OFF");
					} else {
						_this.fill = false;
					}
					break;
				case "FILL_ON":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FILL_ON");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FILL_ON");
					} else {
						_this.fill = true;
					}
					break;
				case "FORWARD":
					var distance3 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FORWARD");
						_this.historyParameters.push(distance3);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FORWARD");
						_this.turtleParameters.push(distance3);
					} else {
						var nx6 = _this.x + distance3 * Math.cos(_this.rotation);
						var ny6 = _this.y + distance3 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							_this.lastDistance = distance3;
							_this.lineTo(nx6,ny6);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx6;
							_this.y = ny6;
							var l14 = _this.points.length;
							_this.points[l14] = [];
							_this.points[l14][0] = nx6;
							_this.points[l14][1] = ny6;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d8 = _this.dim[_this.dim.length - 1];
							if(nx6 < d8.minX) {
								d8.minX = nx6;
							}
							if(nx6 > d8.maxX) {
								d8.maxX = nx6;
							}
							if(ny6 < d8.minY) {
								d8.minY = ny6;
							}
							if(ny6 > d8.maxY) {
								d8.maxY = ny6;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "FORWARD_CHANGE":
					var deltaDistance = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FORWARD_CHANGE");
						_this.historyParameters.push(deltaDistance);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FORWARD_CHANGE");
						_this.turtleParameters.push(deltaDistance);
					} else {
						var distance4 = _this.lastDistance + deltaDistance;
						var nx7 = _this.x + distance4 * Math.cos(_this.rotation);
						var ny7 = _this.y + distance4 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							_this.lastDistance = distance4 + deltaDistance;
							_this.lineTo(nx7,ny7);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx7;
							_this.y = ny7;
							var l15 = _this.points.length;
							_this.points[l15] = [];
							_this.points[l15][0] = nx7;
							_this.points[l15][1] = ny7;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d9 = _this.dim[_this.dim.length - 1];
							if(nx7 < d9.minX) {
								d9.minX = nx7;
							}
							if(nx7 > d9.maxX) {
								d9.maxX = nx7;
							}
							if(ny7 < d9.minY) {
								d9.minY = ny7;
							}
							if(ny7 > d9.maxY) {
								d9.maxY = ny7;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "FORWARD_FACTOR":
					var factor = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FORWARD_FACTOR");
						_this.historyParameters.push(factor);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FORWARD_FACTOR");
						_this.turtleParameters.push(factor);
					} else {
						var distance5 = _this.lastDistance * factor;
						var nx8 = _this.x + distance5 * Math.cos(_this.rotation);
						var ny8 = _this.y + distance5 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							_this.lastDistance = distance5;
							_this.lineTo(nx8,ny8);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx8;
							_this.y = ny8;
							var l16 = _this.points.length;
							_this.points[l16] = [];
							_this.points[l16][0] = nx8;
							_this.points[l16][1] = ny8;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d10 = _this.dim[_this.dim.length - 1];
							if(nx8 < d10.minX) {
								d10.minX = nx8;
							}
							if(nx8 > d10.maxX) {
								d10.maxX = nx8;
							}
							if(ny8 < d10.minY) {
								d10.minY = ny8;
							}
							if(ny8 > d10.maxY) {
								d10.maxY = ny8;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "GREEN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("GREEN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("GREEN");
					} else {
						_this.pen.currentColor = -16711936;
					}
					break;
				case "GREY":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("GREY");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("GREY");
					} else {
						_this.pen.currentColor = -4737097;
					}
					break;
				case "LEFT":
					var degrees2 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("LEFT");
						_this.historyParameters.push(degrees2);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("LEFT");
						_this.turtleParameters.push(degrees2);
					} else {
						_this.rotation -= degrees2 * Math.PI / 180;
					}
					++j;
					break;
				case "LIGHT_BROWN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("LIGHT_BROWN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("LIGHT_BROWN");
					} else {
						_this.pen.currentColor = -3831790;
					}
					break;
				case "MAGENTA":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("MAGENTA");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("MAGENTA");
					} else {
						_this.pen.currentColor = -65281;
					}
					break;
				case "MOVE_PEN":
					var distance6 = v[j];
					if(_this.repeatCommands) {
						_this.turtleCommands.push("MOVE_PEN");
						_this.turtleParameters.push(distance6);
					} else if(_this.penIsDown) {
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_UP");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_UP");
						} else {
							_this.penIsDown = false;
						}
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD");
							_this.historyParameters.push(distance6);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD");
							_this.turtleParameters.push(distance6);
						} else {
							var nx9 = _this.x + distance6 * Math.cos(_this.rotation);
							var ny9 = _this.y + distance6 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance6;
								_this.lineTo(nx9,ny9);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx9;
								_this.y = ny9;
								var l17 = _this.points.length;
								_this.points[l17] = [];
								_this.points[l17][0] = nx9;
								_this.points[l17][1] = ny9;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d11 = _this.dim[_this.dim.length - 1];
								if(nx9 < d11.minX) {
									d11.minX = nx9;
								}
								if(nx9 > d11.maxX) {
									d11.maxX = nx9;
								}
								if(ny9 < d11.minY) {
									d11.minY = ny9;
								}
								if(ny9 > d11.maxY) {
									d11.maxY = ny9;
								}
								_this.contour.reset();
							}
						}
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_DOWN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_DOWN");
						} else {
							_this.penIsDown = true;
						}
					} else {
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD");
							_this.historyParameters.push(distance6);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD");
							_this.turtleParameters.push(distance6);
						} else {
							var nx10 = _this.x + distance6 * Math.cos(_this.rotation);
							var ny10 = _this.y + distance6 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance6;
								_this.lineTo(nx10,ny10);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx10;
								_this.y = ny10;
								var l18 = _this.points.length;
								_this.points[l18] = [];
								_this.points[l18][0] = nx10;
								_this.points[l18][1] = ny10;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d12 = _this.dim[_this.dim.length - 1];
								if(nx10 < d12.minX) {
									d12.minX = nx10;
								}
								if(nx10 > d12.maxX) {
									d12.maxX = nx10;
								}
								if(ny10 < d12.minY) {
									d12.minY = ny10;
								}
								if(ny10 > d12.maxY) {
									d12.maxY = ny10;
								}
								_this.contour.reset();
							}
						}
					}
					++j;
					break;
				case "NORTH":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("NORTH");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("NORTH");
					} else {
						_this.rotation = -Math.PI / 2;
					}
					break;
				case "ORANGE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("ORANGE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("ORANGE");
					} else {
						_this.pen.currentColor = -23808;
					}
					break;
				case "PEN_COLOR":
					var r = v[j];
					var g = v[j + 1];
					var b = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR");
						_this.historyParameters.push(r);
						_this.historyParameters.push(g);
						_this.historyParameters.push(b);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR");
						_this.turtleParameters.push(r);
						_this.turtleParameters.push(g);
						_this.turtleParameters.push(b);
					} else {
						_this.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_B":
					var r1 = v[j];
					var g1 = v[j + 1];
					var b1 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_B");
						_this.historyParameters.push(r1);
						_this.historyParameters.push(g1);
						_this.historyParameters.push(b1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_B");
						_this.turtleParameters.push(r1);
						_this.turtleParameters.push(g1);
						_this.turtleParameters.push(b1);
					} else {
						_this.pen.colorB = Math.round(255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_C":
					var r2 = v[j];
					var g2 = v[j + 1];
					var b2 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_C");
						_this.historyParameters.push(r2);
						_this.historyParameters.push(g2);
						_this.historyParameters.push(b2);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_C");
						_this.turtleParameters.push(r2);
						_this.turtleParameters.push(g2);
						_this.turtleParameters.push(b2);
					} else {
						_this.pen.colorC = Math.round(255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE":
					var r3 = v[j];
					var g3 = v[j + 1];
					var b3 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_CHANGE");
						_this.historyParameters.push(r3);
						_this.historyParameters.push(g3);
						_this.historyParameters.push(b3);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_CHANGE");
						_this.turtleParameters.push(r3);
						_this.turtleParameters.push(g3);
						_this.turtleParameters.push(b3);
					} else {
						var c = _this.pen.currentColor;
						var r0 = (c >> 16 & 255) / 255;
						var g0 = (c >> 8 & 255) / 255;
						var b0 = (c & 255) / 255;
						_this.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r3) * 255) << 16 | Math.round((g0 + g3) * 255) << 8 | Math.round((b0 + b3) * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE_B":
					var r4 = v[j];
					var g4 = v[j + 1];
					var b4 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_CHANGE_B");
						_this.historyParameters.push(r4);
						_this.historyParameters.push(g4);
						_this.historyParameters.push(b4);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_CHANGE_B");
						_this.turtleParameters.push(r4);
						_this.turtleParameters.push(g4);
						_this.turtleParameters.push(b4);
					} else {
						var c1 = _this.pen.colorB;
						var r01 = (c1 >> 16 & 255) / 255;
						var g01 = (c1 >> 8 & 255) / 255;
						var b01 = (c1 & 255) / 255;
						_this.pen.colorB = Math.round(255) << 24 | Math.round((r01 + r4) * 255) << 16 | Math.round((g01 + g4) * 255) << 8 | Math.round((b01 + b4) * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE_C":
					var r5 = v[j];
					var g5 = v[j + 1];
					var b5 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_CHANGE_C");
						_this.historyParameters.push(r5);
						_this.historyParameters.push(g5);
						_this.historyParameters.push(b5);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_CHANGE_C");
						_this.turtleParameters.push(r5);
						_this.turtleParameters.push(g5);
						_this.turtleParameters.push(b5);
					} else {
						var c2 = _this.pen.colorC;
						var r02 = (c2 >> 16 & 255) / 255;
						var g02 = (c2 >> 8 & 255) / 255;
						var b02 = (c2 & 255) / 255;
						_this.pen.colorC = Math.round(255) << 24 | Math.round((r02 + r5) * 255) << 16 | Math.round((g02 + g5) * 255) << 8 | Math.round((b02 + b5) * 255);
					}
					j += 3;
					break;
				case "PEN_DOWN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_DOWN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_DOWN");
					} else {
						_this.penIsDown = true;
					}
					break;
				case "PEN_SIZE":
					var w = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_SIZE");
						_this.historyParameters.push(w);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_SIZE");
						_this.turtleParameters.push(w);
					} else {
						_this.width = w;
					}
					++j;
					break;
				case "PEN_SIZE_CHANGE":
					var dw = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_SIZE_CHANGE");
						_this.historyParameters.push(dw);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_SIZE_CHANGE");
						_this.turtleParameters.push(dw);
					} else {
						_this.width += dw;
					}
					++j;
					break;
				case "PEN_SIZE_FACTOR":
					var factor1 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_SIZE_FACTOR");
						_this.historyParameters.push(factor1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_SIZE_FACTOR");
						_this.turtleParameters.push(factor1);
					} else {
						_this.width *= factor1;
					}
					++j;
					break;
				case "PEN_UP":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_UP");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_UP");
					} else {
						_this.penIsDown = false;
					}
					break;
				case "PLUM":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PLUM");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PLUM");
					} else {
						_this.pen.currentColor = -7310896;
					}
					break;
				case "RED":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("RED");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("RED");
					} else {
						_this.pen.currentColor = -65536;
					}
					break;
				case "RIGHT":
					var degrees3 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("RIGHT");
						_this.historyParameters.push(degrees3);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("RIGHT");
						_this.turtleParameters.push(degrees3);
					} else {
						_this.rotation += degrees3 * Math.PI / 180;
					}
					++j;
					break;
				case "SET_ANGLE":
					var degrees4 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("SET_ANGLE");
						_this.historyParameters.push(degrees4);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("SET_ANGLE");
						_this.turtleParameters.push(degrees4);
					} else {
						_this.rotation = -Math.PI / 2;
						_this.rotation += degrees4 * Math.PI / 180;
					}
					++j;
					break;
				case "SET_POSITION":
					var x2 = v[j];
					var y2 = v[j + 1];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("SET_POSITION");
						_this.historyParameters.push(x2);
						_this.historyParameters.push(y2);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("SET_POSITION");
						_this.turtleParameters.push(x2);
						_this.turtleParameters.push(y2);
					} else {
						if(_this.endLine == 2 || _this.endLine == 3) {
							_this.contour.end(_this.width);
						}
						_this.x = x2;
						_this.y = y2;
						var l19 = _this.points.length;
						_this.points[l19] = [];
						_this.points[l19][0] = x2;
						_this.points[l19][1] = y2;
						_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
						_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
						_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d13 = _this.dim[_this.dim.length - 1];
						if(x2 < d13.minX) {
							d13.minX = x2;
						}
						if(x2 > d13.maxX) {
							d13.maxX = x2;
						}
						if(y2 < d13.minY) {
							d13.minY = y2;
						}
						if(y2 > d13.maxY) {
							d13.maxY = y2;
						}
						_this.contour.reset();
					}
					j += 2;
					break;
				case "SOUTH":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("SOUTH");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("SOUTH");
					} else {
						_this.rotation = Math.PI / 2;
					}
					break;
				case "TAN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("TAN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("TAN");
					} else {
						_this.pen.currentColor = -27273;
					}
					break;
				case "TRIANGLE_ARCH":
					var distance7 = v[j];
					var distance21 = v[j + 1];
					var radius5 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("TRIANGLE_ARCH");
						_this.historyParameters.push(distance7);
						_this.historyParameters.push(distance21);
						_this.historyParameters.push(radius5);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("TRIANGLE_ARCH");
						_this.turtleParameters.push(distance7);
						_this.turtleParameters.push(distance21);
						_this.turtleParameters.push(radius5);
					} else {
						var nx11 = _this.x + distance7 * Math.cos(_this.rotation);
						var ny11 = _this.y + distance7 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							var thruX1 = _this.x + distance21 * Math.cos(_this.rotation) - radius5 * Math.cos(_this.rotation + Math.PI / 2);
							var thruY1 = _this.y + distance21 * Math.sin(_this.rotation) - radius5 * Math.sin(_this.rotation + Math.PI / 2);
							if(_this.fill) {
								_this.pen.triangle2DFill(_this.x,_this.y,thruX1,thruY1,nx11,ny11);
							}
							_this.lineTo(thruX1,thruY1);
							_this.lineTo(nx11,ny11);
							if(_this.fill) {
								_this.lineTo(_this.x,_this.y);
							}
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx11;
							_this.y = ny11;
							var l20 = _this.points.length;
							_this.points[l20] = [];
							_this.points[l20][0] = nx11;
							_this.points[l20][1] = ny11;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d14 = _this.dim[_this.dim.length - 1];
							if(nx11 < d14.minX) {
								d14.minX = nx11;
							}
							if(nx11 > d14.maxX) {
								d14.maxX = nx11;
							}
							if(ny11 < d14.minY) {
								d14.minY = ny11;
							}
							if(ny11 > d14.maxY) {
								d14.maxY = ny11;
							}
							_this.contour.reset();
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx11;
							_this.y = ny11;
							var l21 = _this.points.length;
							_this.points[l21] = [];
							_this.points[l21][0] = nx11;
							_this.points[l21][1] = ny11;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d15 = _this.dim[_this.dim.length - 1];
							if(nx11 < d15.minX) {
								d15.minX = nx11;
							}
							if(nx11 > d15.maxX) {
								d15.maxX = nx11;
							}
							if(ny11 < d15.minY) {
								d15.minY = ny11;
							}
							if(ny11 > d15.maxY) {
								d15.maxY = ny11;
							}
							_this.contour.reset();
						}
					}
					j += 3;
					break;
				case "WEST":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("WEST");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("WEST");
					} else {
						_this.rotation = 0;
					}
					break;
				case "WHITE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("WHITE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("WHITE");
					} else {
						_this.pen.currentColor = -1;
					}
					break;
				case "YELLOW":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("YELLOW");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("YELLOW");
					} else {
						_this.pen.currentColor = -256;
					}
					break;
				}
			}
			j = 0;
		}
		_this.turtleHistoryOn = wasHistoryOn;
		_this.turtleCommands.length = 0;
		_this.turtleParameters.length = 0;
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("ORANGE");
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("ORANGE");
		} else {
			_this1.pen.currentColor = -23808;
		}
		sketcher.turtleHistoryOn = false;
		if(sketcher.turtleHistoryOn) {
			sketcher.historyAdd("SET_POSITION");
			sketcher.historyParameters.push(300);
			sketcher.historyParameters.push(500);
		}
		if(sketcher.repeatCommands) {
			sketcher.turtleCommands.push("SET_POSITION");
			sketcher.turtleParameters.push(300);
			sketcher.turtleParameters.push(500);
		} else {
			if(sketcher.endLine == 2 || sketcher.endLine == 3) {
				sketcher.contour.end(sketcher.width);
			}
			sketcher.x = 300;
			sketcher.y = 500;
			var l = sketcher.points.length;
			sketcher.points[l] = [];
			sketcher.points[l][0] = 300;
			sketcher.points[l][1] = 500;
			sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
			sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
			sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = sketcher.dim[sketcher.dim.length - 1];
			if(300 < d.minX) {
				d.minX = 300;
			}
			if(300 > d.maxX) {
				d.maxX = 300;
			}
			if(500 < d.minY) {
				d.minY = 500;
			}
			if(500 > d.maxY) {
				d.maxY = 500;
			}
			sketcher.contour.reset();
		}
		if(sketcher.turtleHistoryOn) {
			sketcher.historyAdd("NORTH");
		}
		if(sketcher.repeatCommands) {
			sketcher.turtleCommands.push("NORTH");
		} else {
			sketcher.rotation = -Math.PI / 2;
		}
		sketcher.traceHistory();
		sketcher.playHistory(0);
	}
	,enneagram: function() {
		var sketcher = new cornerContour_Sketcher(this.pen2D,4,0);
		var sides = 9;
		var angle = 200.;
		if(sketcher.turtleHistoryOn) {
			sketcher.historyAdd("SET_POSITION");
			sketcher.historyParameters.push(700);
			sketcher.historyParameters.push(180);
		}
		if(sketcher.repeatCommands) {
			sketcher.turtleCommands.push("SET_POSITION");
			sketcher.turtleParameters.push(700);
			sketcher.turtleParameters.push(180);
		} else {
			if(sketcher.endLine == 2 || sketcher.endLine == 3) {
				sketcher.contour.end(sketcher.width);
			}
			sketcher.x = 700;
			sketcher.y = 180;
			var l = sketcher.points.length;
			sketcher.points[l] = [];
			sketcher.points[l][0] = 700;
			sketcher.points[l][1] = 180;
			sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
			sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
			sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = sketcher.dim[sketcher.dim.length - 1];
			if(700 < d.minX) {
				d.minX = 700;
			}
			if(700 > d.maxX) {
				d.maxX = 700;
			}
			if(180 < d.minY) {
				d.minY = 180;
			}
			if(180 > d.maxY) {
				d.maxY = 180;
			}
			sketcher.contour.reset();
		}
		var _this = sketcher;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("PEN_SIZE");
			_this.historyParameters.push(10);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("PEN_SIZE");
			_this.turtleParameters.push(10);
		} else {
			_this.width = 10;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("YELLOW");
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("YELLOW");
		} else {
			_this1.pen.currentColor = -256;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("PEN_COLOR_CHANGE");
			_this.historyParameters.push(-0.09);
			_this.historyParameters.push(0.01);
			_this.historyParameters.push(0.09);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("PEN_COLOR_CHANGE");
			_this.turtleParameters.push(-0.09);
			_this.turtleParameters.push(0.01);
			_this.turtleParameters.push(0.09);
		} else {
			var c = _this.pen.currentColor;
			var r0 = (c >> 16 & 255) / 255;
			var g0 = (c >> 8 & 255) / 255;
			var b0 = (c & 255) / 255;
			_this.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + (-0.09)) * 255) << 16 | Math.round((g0 + 0.01) * 255) << 8 | Math.round((b0 + 0.09) * 255);
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("WEST");
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("WEST");
		} else {
			_this1.rotation = 0;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("FILL_OFF");
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("FILL_OFF");
		} else {
			_this.fill = false;
		}
		var _this1 = _this;
		var repeatCount_ = sides + 1;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("BEGIN_REPEAT");
			_this1.historyParameters.push(Math.round(repeatCount_));
		}
		if(_this1.repeatCommands == true) {
			_this1.repeatCommands = false;
			if(_this1.turtleHistoryOn) {
				_this1.historyAdd("END_REPEAT");
			}
			var wasHistoryOn = _this1.turtleHistoryOn;
			_this1.turtleHistoryOn = false;
			var v = _this1.turtleParameters;
			var j = 0;
			var _g = 0;
			var _g1 = _this1.repeatCount;
			while(_g < _g1) {
				var k = _g++;
				var _g2 = 0;
				var _g3 = _this1.turtleCommands.length;
				while(_g2 < _g3) {
					var i = _g2++;
					var command = _this1.turtleCommands[i];
					switch(command) {
					case "ARC":
						var radius = v[j];
						var degrees = v[j + 1];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("ARC");
							_this1.historyParameters.push(radius);
							_this1.historyParameters.push(degrees);
						}
						if(radius != 0) {
							if(_this1.repeatCommands) {
								_this1.turtleCommands.push("ARC");
								_this1.turtleParameters.push(radius);
								_this1.turtleParameters.push(degrees);
							} else {
								var beta = degrees * Math.PI / 180 / 24;
								var alpha = (Math.PI - beta) / 2;
								var rotate = -(Math.PI / 2 - alpha);
								var baseLength = 0.5 * radius * Math.sin(beta / 2);
								var ox = _this1.x;
								var oy = _this1.y;
								var arr = [];
								arr.push(_this1.x);
								arr.push(_this1.y);
								var _g4 = 0;
								while(_g4 < 48) {
									var i1 = _g4++;
									_this1.rotation += rotate;
									var wasHistoryOn1 = _this1.turtleHistoryOn;
									_this1.turtleHistoryOn = false;
									if(_this1.turtleHistoryOn) {
										_this1.historyAdd("FORWARD");
										_this1.historyParameters.push(baseLength);
									}
									if(_this1.repeatCommands) {
										_this1.turtleCommands.push("FORWARD");
										_this1.turtleParameters.push(baseLength);
									} else {
										var nx = _this1.x + baseLength * Math.cos(_this1.rotation);
										var ny = _this1.y + baseLength * Math.sin(_this1.rotation);
										if(_this1.penIsDown) {
											_this1.lastDistance = baseLength;
											_this1.lineTo(nx,ny);
										} else {
											if(_this1.endLine == 2 || _this1.endLine == 3) {
												_this1.contour.end(_this1.width);
											}
											_this1.x = nx;
											_this1.y = ny;
											var l = _this1.points.length;
											_this1.points[l] = [];
											_this1.points[l][0] = nx;
											_this1.points[l][1] = ny;
											_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
											_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
											_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d = _this1.dim[_this1.dim.length - 1];
											if(nx < d.minX) {
												d.minX = nx;
											}
											if(nx > d.maxX) {
												d.maxX = nx;
											}
											if(ny < d.minY) {
												d.minY = ny;
											}
											if(ny > d.maxY) {
												d.maxY = ny;
											}
											_this1.contour.reset();
										}
									}
									_this1.turtleHistoryOn = wasHistoryOn1;
									if(_this1.fill) {
										arr.push(_this1.x);
										arr.push(_this1.y);
									}
								}
								if(_this1.fill) {
									var cx = (ox + arr[arr.length - 2]) / 2;
									var cy = (oy + arr[arr.length - 1]) / 2;
									var l1 = arr.length;
									var i2 = 2;
									var lx = 0.;
									var ly = 0.;
									_this1.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
									while(i2 < l1) {
										if(i2 > 2) {
											_this1.pen.triangle2DFill(lx,ly,arr[i2],arr[i2 + 1],cx,cy);
										}
										lx = arr[i2];
										ly = arr[i2 + 1];
										i2 += 2;
									}
								}
								arr.length = 0;
							}
						}
						j += 2;
						break;
					case "ARCH_BEZIER":
						var distance = v[j];
						var distance2 = v[j + 1];
						var radius1 = v[j + 2];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("ARCH_BEZIER");
							_this1.historyParameters.push(distance);
							_this1.historyParameters.push(distance2);
							_this1.historyParameters.push(radius1);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("ARCH_BEZIER");
							_this1.turtleParameters.push(distance);
							_this1.turtleParameters.push(distance2);
							_this1.turtleParameters.push(radius1);
						} else {
							var nx1 = _this1.x + distance * Math.cos(_this1.rotation);
							var ny1 = _this1.y + distance * Math.sin(_this1.rotation);
							if(_this1.penIsDown) {
								var thruX = _this1.x + distance2 * Math.cos(_this1.rotation) - radius1 * Math.cos(_this1.rotation + Math.PI / 2);
								var thruY = _this1.y + distance2 * Math.sin(_this1.rotation) - radius1 * Math.sin(_this1.rotation + Math.PI / 2);
								var newx = 2 * thruX - 0.5 * (_this1.x + nx1);
								var newy = 2 * thruY - 0.5 * (_this1.y + ny1);
								_this1.tempArr = [];
								var p = _this1.tempArr;
								var ax = _this1.x;
								var ay = _this1.y;
								var x = ax - newx;
								var y = ay - newy;
								var x1 = newx - nx1;
								var y1 = newy - ny1;
								var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
								if(approxDistance == 0) {
									approxDistance = 0.000001;
								}
								var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
								var l2 = p.length;
								p[l2++] = ax;
								p[l2++] = ay;
								var t = step;
								while(t < 1.) {
									var u = 1 - t;
									p[l2++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx1;
									var u1 = 1 - t;
									p[l2++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny1;
									t += step;
								}
								p[l2++] = nx1;
								p[l2++] = ny1;
								var arr1 = _this1.tempArr;
								var withMove = false;
								if(withMove == null) {
									withMove = true;
								}
								var l3 = arr1.length;
								var i3 = 2;
								if(withMove) {
									var x_ = arr1[0];
									var y_ = arr1[1];
									if(_this1.endLine == 2 || _this1.endLine == 3) {
										_this1.contour.end(_this1.width);
									}
									_this1.x = x_;
									_this1.y = y_;
									var l4 = _this1.points.length;
									_this1.points[l4] = [];
									_this1.points[l4][0] = x_;
									_this1.points[l4][1] = y_;
									_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
									_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
									_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d1 = _this1.dim[_this1.dim.length - 1];
									if(x_ < d1.minX) {
										d1.minX = x_;
									}
									if(x_ > d1.maxX) {
										d1.maxX = x_;
									}
									if(y_ < d1.minY) {
										d1.minY = y_;
									}
									if(y_ > d1.maxY) {
										d1.maxY = y_;
									}
									_this1.contour.reset();
								} else {
									_this1.lineTo(arr1[0],arr1[1]);
								}
								var cx1 = (arr1[0] + arr1[l3 - 2]) / 2;
								var cy1 = (arr1[1] + arr1[l3 - 1]) / 2;
								var ox1 = _this1.x;
								var oy1 = _this1.y;
								while(i3 < l3) {
									if(_this1.fill && _this1.penIsDown) {
										if(i3 > 0 && i3 < l3 - 2) {
											_this1.pen.triangle2DFill(arr1[i3 - 2],arr1[i3 - 1],arr1[i3],arr1[i3 + 1],cx1,cy1);
										}
									}
									_this1.lineTo(arr1[i3],arr1[i3 + 1]);
									i3 += 2;
								}
								if(_this1.fill && _this1.penIsDown) {
									if(_this1.endLine == 2 || _this1.endLine == 3) {
										_this1.contour.end(_this1.width);
									}
									_this1.x = ox1;
									_this1.y = oy1;
									var l5 = _this1.points.length;
									_this1.points[l5] = [];
									_this1.points[l5][0] = ox1;
									_this1.points[l5][1] = oy1;
									_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
									_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
									_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d2 = _this1.dim[_this1.dim.length - 1];
									if(ox1 < d2.minX) {
										d2.minX = ox1;
									}
									if(ox1 > d2.maxX) {
										d2.maxX = ox1;
									}
									if(oy1 < d2.minY) {
										d2.minY = oy1;
									}
									if(oy1 > d2.maxY) {
										d2.maxY = oy1;
									}
									_this1.contour.reset();
									_this1.lineTo(arr1[l3 - 2],arr1[l3 - 1]);
								}
								_this1.x = nx1;
								_this1.y = ny1;
							} else {
								if(_this1.endLine == 2 || _this1.endLine == 3) {
									_this1.contour.end(_this1.width);
								}
								_this1.x = nx1;
								_this1.y = ny1;
								var l6 = _this1.points.length;
								_this1.points[l6] = [];
								_this1.points[l6][0] = nx1;
								_this1.points[l6][1] = ny1;
								_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
								_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
								_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d3 = _this1.dim[_this1.dim.length - 1];
								if(nx1 < d3.minX) {
									d3.minX = nx1;
								}
								if(nx1 > d3.maxX) {
									d3.maxX = nx1;
								}
								if(ny1 < d3.minY) {
									d3.minY = ny1;
								}
								if(ny1 > d3.maxY) {
									d3.maxY = ny1;
								}
								_this1.contour.reset();
							}
						}
						j += 3;
						break;
					case "ARC_SIDES":
						var radius2 = v[j];
						var degrees1 = v[j + 1];
						var sides = v[j + 2];
						if(sides == null) {
							sides = 24;
						}
						if(_this1.turtleHistoryOn) {
							if(sides == 24) {
								_this1.historyAdd("ARC");
								_this1.historyParameters.push(radius2);
								_this1.historyParameters.push(degrees1);
							} else {
								_this1.historyAdd("ARC_SIDES");
								_this1.historyParameters.push(radius2);
								_this1.historyParameters.push(degrees1);
								_this1.historyParameters.push(sides);
							}
						}
						if(radius2 != 0) {
							if(_this1.repeatCommands) {
								if(sides == 24) {
									_this1.turtleCommands.push("ARC");
									_this1.turtleParameters.push(radius2);
									_this1.turtleParameters.push(degrees1);
								} else {
									_this1.turtleCommands.push("ARC_SIDES");
									_this1.turtleParameters.push(radius2);
									_this1.turtleParameters.push(degrees1);
									_this1.turtleParameters.push(sides);
								}
							} else {
								var beta1 = degrees1 * Math.PI / 180 / sides;
								var alpha1 = (Math.PI - beta1) / 2;
								var rotate1 = -(Math.PI / 2 - alpha1);
								var baseLength1 = 0.5 * radius2 * Math.sin(beta1 / 2);
								var ox2 = _this1.x;
								var oy2 = _this1.y;
								var arr2 = [];
								arr2.push(_this1.x);
								arr2.push(_this1.y);
								var _g5 = 0;
								while(_g5 < 48) {
									var i4 = _g5++;
									_this1.rotation += rotate1;
									var wasHistoryOn2 = _this1.turtleHistoryOn;
									_this1.turtleHistoryOn = false;
									if(_this1.turtleHistoryOn) {
										_this1.historyAdd("FORWARD");
										_this1.historyParameters.push(baseLength1);
									}
									if(_this1.repeatCommands) {
										_this1.turtleCommands.push("FORWARD");
										_this1.turtleParameters.push(baseLength1);
									} else {
										var nx2 = _this1.x + baseLength1 * Math.cos(_this1.rotation);
										var ny2 = _this1.y + baseLength1 * Math.sin(_this1.rotation);
										if(_this1.penIsDown) {
											_this1.lastDistance = baseLength1;
											_this1.lineTo(nx2,ny2);
										} else {
											if(_this1.endLine == 2 || _this1.endLine == 3) {
												_this1.contour.end(_this1.width);
											}
											_this1.x = nx2;
											_this1.y = ny2;
											var l7 = _this1.points.length;
											_this1.points[l7] = [];
											_this1.points[l7][0] = nx2;
											_this1.points[l7][1] = ny2;
											_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
											_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
											_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d4 = _this1.dim[_this1.dim.length - 1];
											if(nx2 < d4.minX) {
												d4.minX = nx2;
											}
											if(nx2 > d4.maxX) {
												d4.maxX = nx2;
											}
											if(ny2 < d4.minY) {
												d4.minY = ny2;
											}
											if(ny2 > d4.maxY) {
												d4.maxY = ny2;
											}
											_this1.contour.reset();
										}
									}
									_this1.turtleHistoryOn = wasHistoryOn2;
									if(_this1.fill) {
										arr2.push(_this1.x);
										arr2.push(_this1.y);
									}
								}
								if(_this1.fill) {
									var cx2 = (ox2 + arr2[arr2.length - 2]) / 2;
									var cy2 = (oy2 + arr2[arr2.length - 1]) / 2;
									var l8 = arr2.length;
									var i5 = 2;
									var lx1 = 0.;
									var ly1 = 0.;
									_this1.pen.triangle2DFill(ox2,oy2,arr2[0],arr2[1],cx2,cy2);
									while(i5 < l8) {
										if(i5 > 2) {
											_this1.pen.triangle2DFill(lx1,ly1,arr2[i5],arr2[i5 + 1],cx2,cy2);
										}
										lx1 = arr2[i5];
										ly1 = arr2[i5 + 1];
										i5 += 2;
									}
								}
								arr2.length = 0;
							}
						}
						j += 3;
						break;
					case "BACKWARD":
						var distance1 = v[j];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("BACKWARD");
							_this1.historyParameters.push(distance1);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("BACKWARD");
							_this1.turtleParameters.push(distance1);
						} else {
							var nx3 = _this1.x + distance1 * Math.cos(_this1.rotation + Math.PI);
							var ny3 = _this1.y + distance1 * Math.sin(_this1.rotation + Math.PI);
							if(_this1.penIsDown) {
								_this1.lineTo(nx3,ny3);
							} else {
								if(_this1.endLine == 2 || _this1.endLine == 3) {
									_this1.contour.end(_this1.width);
								}
								_this1.x = nx3;
								_this1.y = ny3;
								var l9 = _this1.points.length;
								_this1.points[l9] = [];
								_this1.points[l9][0] = nx3;
								_this1.points[l9][1] = ny3;
								_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
								_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
								_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d5 = _this1.dim[_this1.dim.length - 1];
								if(nx3 < d5.minX) {
									d5.minX = nx3;
								}
								if(nx3 > d5.maxX) {
									d5.maxX = nx3;
								}
								if(ny3 < d5.minY) {
									d5.minY = ny3;
								}
								if(ny3 > d5.maxY) {
									d5.maxY = ny3;
								}
								_this1.contour.reset();
							}
						}
						++j;
						break;
					case "BEGIN_REPEAT":
						break;
					case "BLACK":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("BLACK");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("BLACK");
						} else {
							_this1.pen.currentColor = -16777216;
						}
						break;
					case "BLUE":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("BLUE");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("BLUE");
						} else {
							_this1.pen.currentColor = -16776961;
						}
						break;
					case "BROWN":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("BROWN");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("BROWN");
						} else {
							_this1.pen.currentColor = -6594501;
						}
						break;
					case "CIRCLE":
						var radius3 = v[j];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("CIRCLE");
							_this1.historyParameters.push(radius3);
						}
						if(radius3 != 0) {
							if(_this1.repeatCommands) {
								_this1.turtleCommands.push("CIRCLE");
								_this1.turtleParameters.push(radius3);
							} else {
								var beta2 = 2 * Math.PI / 24;
								var alpha2 = (Math.PI - beta2) / 2;
								var rotate2 = -(Math.PI / 2 - alpha2);
								var baseLength2 = 0.5 * radius3 * Math.sin(beta2 / 2);
								var ox3 = _this1.x;
								var oy3 = _this1.y;
								var arr3 = [];
								var _g6 = 0;
								while(_g6 < 48) {
									var i6 = _g6++;
									_this1.rotation += rotate2;
									var wasHistoryOn3 = _this1.turtleHistoryOn;
									_this1.turtleHistoryOn = false;
									if(_this1.turtleHistoryOn) {
										_this1.historyAdd("FORWARD");
										_this1.historyParameters.push(baseLength2);
									}
									if(_this1.repeatCommands) {
										_this1.turtleCommands.push("FORWARD");
										_this1.turtleParameters.push(baseLength2);
									} else {
										var nx4 = _this1.x + baseLength2 * Math.cos(_this1.rotation);
										var ny4 = _this1.y + baseLength2 * Math.sin(_this1.rotation);
										if(_this1.penIsDown) {
											_this1.lastDistance = baseLength2;
											_this1.lineTo(nx4,ny4);
										} else {
											if(_this1.endLine == 2 || _this1.endLine == 3) {
												_this1.contour.end(_this1.width);
											}
											_this1.x = nx4;
											_this1.y = ny4;
											var l10 = _this1.points.length;
											_this1.points[l10] = [];
											_this1.points[l10][0] = nx4;
											_this1.points[l10][1] = ny4;
											_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
											_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
											_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d6 = _this1.dim[_this1.dim.length - 1];
											if(nx4 < d6.minX) {
												d6.minX = nx4;
											}
											if(nx4 > d6.maxX) {
												d6.maxX = nx4;
											}
											if(ny4 < d6.minY) {
												d6.minY = ny4;
											}
											if(ny4 > d6.maxY) {
												d6.maxY = ny4;
											}
											_this1.contour.reset();
										}
									}
									_this1.turtleHistoryOn = wasHistoryOn3;
									if(_this1.fill) {
										arr3.push(_this1.x);
										arr3.push(_this1.y);
									}
								}
								if(_this1.fill) {
									var cx3 = (ox3 + arr3[arr3.length - 2]) / 2;
									var cy3 = (oy3 + arr3[arr3.length - 1]) / 2;
									var l11 = arr3.length;
									var i7 = 2;
									var lx2 = 0.;
									var ly2 = 0.;
									while(i7 < l11) {
										if(i7 > 2) {
											_this1.pen.triangle2DFill(lx2,ly2,arr3[i7],arr3[i7 + 1],cx3,cy3);
										}
										lx2 = arr3[i7];
										ly2 = arr3[i7 + 1];
										i7 += 2;
									}
								}
								arr3.length = 0;
							}
						}
						++j;
						break;
					case "CIRCLE_SIDES":
						var radius4 = v[j];
						var sides1 = v[j + 1];
						if(sides1 == null) {
							sides1 = 24;
						}
						if(_this1.turtleHistoryOn) {
							if(sides1 == 24) {
								_this1.historyAdd("CIRCLE");
								_this1.historyParameters.push(radius4);
							} else {
								_this1.historyAdd("CIRCLE_SIDES");
								_this1.historyParameters.push(radius4);
								_this1.historyParameters.push(sides1);
							}
						}
						if(radius4 != 0) {
							if(_this1.repeatCommands) {
								if(sides1 == 24) {
									_this1.turtleCommands.push("CIRCLE");
									_this1.turtleParameters.push(radius4);
								} else {
									_this1.turtleCommands.push("CIRCLE_SIDES");
									_this1.turtleParameters.push(radius4);
									_this1.turtleParameters.push(sides1);
								}
							} else {
								var beta3 = 2 * Math.PI / sides1;
								var alpha3 = (Math.PI - beta3) / 2;
								var rotate3 = -(Math.PI / 2 - alpha3);
								var baseLength3 = 0.5 * radius4 * Math.sin(beta3 / 2);
								var ox4 = _this1.x;
								var oy4 = _this1.y;
								var arr4 = [];
								var _g7 = 0;
								while(_g7 < 48) {
									var i8 = _g7++;
									_this1.rotation += rotate3;
									var wasHistoryOn4 = _this1.turtleHistoryOn;
									_this1.turtleHistoryOn = false;
									if(_this1.turtleHistoryOn) {
										_this1.historyAdd("FORWARD");
										_this1.historyParameters.push(baseLength3);
									}
									if(_this1.repeatCommands) {
										_this1.turtleCommands.push("FORWARD");
										_this1.turtleParameters.push(baseLength3);
									} else {
										var nx5 = _this1.x + baseLength3 * Math.cos(_this1.rotation);
										var ny5 = _this1.y + baseLength3 * Math.sin(_this1.rotation);
										if(_this1.penIsDown) {
											_this1.lastDistance = baseLength3;
											_this1.lineTo(nx5,ny5);
										} else {
											if(_this1.endLine == 2 || _this1.endLine == 3) {
												_this1.contour.end(_this1.width);
											}
											_this1.x = nx5;
											_this1.y = ny5;
											var l12 = _this1.points.length;
											_this1.points[l12] = [];
											_this1.points[l12][0] = nx5;
											_this1.points[l12][1] = ny5;
											_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
											_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
											_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d7 = _this1.dim[_this1.dim.length - 1];
											if(nx5 < d7.minX) {
												d7.minX = nx5;
											}
											if(nx5 > d7.maxX) {
												d7.maxX = nx5;
											}
											if(ny5 < d7.minY) {
												d7.minY = ny5;
											}
											if(ny5 > d7.maxY) {
												d7.maxY = ny5;
											}
											_this1.contour.reset();
										}
									}
									_this1.turtleHistoryOn = wasHistoryOn4;
									if(_this1.fill) {
										arr4.push(_this1.x);
										arr4.push(_this1.y);
									}
								}
								if(_this1.fill) {
									var cx4 = (ox4 + arr4[arr4.length - 2]) / 2;
									var cy4 = (oy4 + arr4[arr4.length - 1]) / 2;
									var l13 = arr4.length;
									var i9 = 2;
									var lx3 = 0.;
									var ly3 = 0.;
									while(i9 < l13) {
										if(i9 > 2) {
											_this1.pen.triangle2DFill(lx3,ly3,arr4[i9],arr4[i9 + 1],cx4,cy4);
										}
										lx3 = arr4[i9];
										ly3 = arr4[i9 + 1];
										i9 += 2;
									}
								}
								arr4.length = 0;
							}
						}
						j += 2;
						break;
					case "CYAN":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("CYAN");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("CYAN");
						} else {
							_this1.pen.currentColor = -16711681;
						}
						break;
					case "DARKISH_BLUE":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("DARKISH_BLUE");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("DARKISH_BLUE");
						} else {
							_this1.pen.currentColor = -8864837;
						}
						break;
					case "DARK_GREEN":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("DARK_GREEN");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("DARK_GREEN");
						} else {
							_this1.pen.currentColor = -10182080;
						}
						break;
					case "EAST":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("WEST");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("EAST");
						} else {
							_this1.rotation = Math.PI;
						}
						break;
					case "END_REPEAT":
						break;
					case "FILL_OFF":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("FILL_OFF");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("FILL_OFF");
						} else {
							_this1.fill = false;
						}
						break;
					case "FILL_ON":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("FILL_ON");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("FILL_ON");
						} else {
							_this1.fill = true;
						}
						break;
					case "FORWARD":
						var distance3 = v[j];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("FORWARD");
							_this1.historyParameters.push(distance3);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("FORWARD");
							_this1.turtleParameters.push(distance3);
						} else {
							var nx6 = _this1.x + distance3 * Math.cos(_this1.rotation);
							var ny6 = _this1.y + distance3 * Math.sin(_this1.rotation);
							if(_this1.penIsDown) {
								_this1.lastDistance = distance3;
								_this1.lineTo(nx6,ny6);
							} else {
								if(_this1.endLine == 2 || _this1.endLine == 3) {
									_this1.contour.end(_this1.width);
								}
								_this1.x = nx6;
								_this1.y = ny6;
								var l14 = _this1.points.length;
								_this1.points[l14] = [];
								_this1.points[l14][0] = nx6;
								_this1.points[l14][1] = ny6;
								_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
								_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
								_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d8 = _this1.dim[_this1.dim.length - 1];
								if(nx6 < d8.minX) {
									d8.minX = nx6;
								}
								if(nx6 > d8.maxX) {
									d8.maxX = nx6;
								}
								if(ny6 < d8.minY) {
									d8.minY = ny6;
								}
								if(ny6 > d8.maxY) {
									d8.maxY = ny6;
								}
								_this1.contour.reset();
							}
						}
						++j;
						break;
					case "FORWARD_CHANGE":
						var deltaDistance = v[j];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("FORWARD_CHANGE");
							_this1.historyParameters.push(deltaDistance);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("FORWARD_CHANGE");
							_this1.turtleParameters.push(deltaDistance);
						} else {
							var distance4 = _this1.lastDistance + deltaDistance;
							var nx7 = _this1.x + distance4 * Math.cos(_this1.rotation);
							var ny7 = _this1.y + distance4 * Math.sin(_this1.rotation);
							if(_this1.penIsDown) {
								_this1.lastDistance = distance4 + deltaDistance;
								_this1.lineTo(nx7,ny7);
							} else {
								if(_this1.endLine == 2 || _this1.endLine == 3) {
									_this1.contour.end(_this1.width);
								}
								_this1.x = nx7;
								_this1.y = ny7;
								var l15 = _this1.points.length;
								_this1.points[l15] = [];
								_this1.points[l15][0] = nx7;
								_this1.points[l15][1] = ny7;
								_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
								_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
								_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d9 = _this1.dim[_this1.dim.length - 1];
								if(nx7 < d9.minX) {
									d9.minX = nx7;
								}
								if(nx7 > d9.maxX) {
									d9.maxX = nx7;
								}
								if(ny7 < d9.minY) {
									d9.minY = ny7;
								}
								if(ny7 > d9.maxY) {
									d9.maxY = ny7;
								}
								_this1.contour.reset();
							}
						}
						++j;
						break;
					case "FORWARD_FACTOR":
						var factor = v[j];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("FORWARD_FACTOR");
							_this1.historyParameters.push(factor);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("FORWARD_FACTOR");
							_this1.turtleParameters.push(factor);
						} else {
							var distance5 = _this1.lastDistance * factor;
							var nx8 = _this1.x + distance5 * Math.cos(_this1.rotation);
							var ny8 = _this1.y + distance5 * Math.sin(_this1.rotation);
							if(_this1.penIsDown) {
								_this1.lastDistance = distance5;
								_this1.lineTo(nx8,ny8);
							} else {
								if(_this1.endLine == 2 || _this1.endLine == 3) {
									_this1.contour.end(_this1.width);
								}
								_this1.x = nx8;
								_this1.y = ny8;
								var l16 = _this1.points.length;
								_this1.points[l16] = [];
								_this1.points[l16][0] = nx8;
								_this1.points[l16][1] = ny8;
								_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
								_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
								_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d10 = _this1.dim[_this1.dim.length - 1];
								if(nx8 < d10.minX) {
									d10.minX = nx8;
								}
								if(nx8 > d10.maxX) {
									d10.maxX = nx8;
								}
								if(ny8 < d10.minY) {
									d10.minY = ny8;
								}
								if(ny8 > d10.maxY) {
									d10.maxY = ny8;
								}
								_this1.contour.reset();
							}
						}
						++j;
						break;
					case "GREEN":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("GREEN");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("GREEN");
						} else {
							_this1.pen.currentColor = -16711936;
						}
						break;
					case "GREY":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("GREY");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("GREY");
						} else {
							_this1.pen.currentColor = -4737097;
						}
						break;
					case "LEFT":
						var degrees2 = v[j];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("LEFT");
							_this1.historyParameters.push(degrees2);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("LEFT");
							_this1.turtleParameters.push(degrees2);
						} else {
							_this1.rotation -= degrees2 * Math.PI / 180;
						}
						++j;
						break;
					case "LIGHT_BROWN":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("LIGHT_BROWN");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("LIGHT_BROWN");
						} else {
							_this1.pen.currentColor = -3831790;
						}
						break;
					case "MAGENTA":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("MAGENTA");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("MAGENTA");
						} else {
							_this1.pen.currentColor = -65281;
						}
						break;
					case "MOVE_PEN":
						var distance6 = v[j];
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("MOVE_PEN");
							_this1.turtleParameters.push(distance6);
						} else if(_this1.penIsDown) {
							if(_this1.turtleHistoryOn) {
								_this1.historyAdd("PEN_UP");
							}
							if(_this1.repeatCommands) {
								_this1.turtleCommands.push("PEN_UP");
							} else {
								_this1.penIsDown = false;
							}
							if(_this1.turtleHistoryOn) {
								_this1.historyAdd("FORWARD");
								_this1.historyParameters.push(distance6);
							}
							if(_this1.repeatCommands) {
								_this1.turtleCommands.push("FORWARD");
								_this1.turtleParameters.push(distance6);
							} else {
								var nx9 = _this1.x + distance6 * Math.cos(_this1.rotation);
								var ny9 = _this1.y + distance6 * Math.sin(_this1.rotation);
								if(_this1.penIsDown) {
									_this1.lastDistance = distance6;
									_this1.lineTo(nx9,ny9);
								} else {
									if(_this1.endLine == 2 || _this1.endLine == 3) {
										_this1.contour.end(_this1.width);
									}
									_this1.x = nx9;
									_this1.y = ny9;
									var l17 = _this1.points.length;
									_this1.points[l17] = [];
									_this1.points[l17][0] = nx9;
									_this1.points[l17][1] = ny9;
									_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
									_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
									_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d11 = _this1.dim[_this1.dim.length - 1];
									if(nx9 < d11.minX) {
										d11.minX = nx9;
									}
									if(nx9 > d11.maxX) {
										d11.maxX = nx9;
									}
									if(ny9 < d11.minY) {
										d11.minY = ny9;
									}
									if(ny9 > d11.maxY) {
										d11.maxY = ny9;
									}
									_this1.contour.reset();
								}
							}
							if(_this1.turtleHistoryOn) {
								_this1.historyAdd("PEN_DOWN");
							}
							if(_this1.repeatCommands) {
								_this1.turtleCommands.push("PEN_DOWN");
							} else {
								_this1.penIsDown = true;
							}
						} else {
							if(_this1.turtleHistoryOn) {
								_this1.historyAdd("FORWARD");
								_this1.historyParameters.push(distance6);
							}
							if(_this1.repeatCommands) {
								_this1.turtleCommands.push("FORWARD");
								_this1.turtleParameters.push(distance6);
							} else {
								var nx10 = _this1.x + distance6 * Math.cos(_this1.rotation);
								var ny10 = _this1.y + distance6 * Math.sin(_this1.rotation);
								if(_this1.penIsDown) {
									_this1.lastDistance = distance6;
									_this1.lineTo(nx10,ny10);
								} else {
									if(_this1.endLine == 2 || _this1.endLine == 3) {
										_this1.contour.end(_this1.width);
									}
									_this1.x = nx10;
									_this1.y = ny10;
									var l18 = _this1.points.length;
									_this1.points[l18] = [];
									_this1.points[l18][0] = nx10;
									_this1.points[l18][1] = ny10;
									_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
									_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
									_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d12 = _this1.dim[_this1.dim.length - 1];
									if(nx10 < d12.minX) {
										d12.minX = nx10;
									}
									if(nx10 > d12.maxX) {
										d12.maxX = nx10;
									}
									if(ny10 < d12.minY) {
										d12.minY = ny10;
									}
									if(ny10 > d12.maxY) {
										d12.maxY = ny10;
									}
									_this1.contour.reset();
								}
							}
						}
						++j;
						break;
					case "NORTH":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("NORTH");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("NORTH");
						} else {
							_this1.rotation = -Math.PI / 2;
						}
						break;
					case "ORANGE":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("ORANGE");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("ORANGE");
						} else {
							_this1.pen.currentColor = -23808;
						}
						break;
					case "PEN_COLOR":
						var r = v[j];
						var g = v[j + 1];
						var b = v[j + 2];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_COLOR");
							_this1.historyParameters.push(r);
							_this1.historyParameters.push(g);
							_this1.historyParameters.push(b);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_COLOR");
							_this1.turtleParameters.push(r);
							_this1.turtleParameters.push(g);
							_this1.turtleParameters.push(b);
						} else {
							_this1.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_B":
						var r1 = v[j];
						var g1 = v[j + 1];
						var b1 = v[j + 2];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_COLOR_B");
							_this1.historyParameters.push(r1);
							_this1.historyParameters.push(g1);
							_this1.historyParameters.push(b1);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_COLOR_B");
							_this1.turtleParameters.push(r1);
							_this1.turtleParameters.push(g1);
							_this1.turtleParameters.push(b1);
						} else {
							_this1.pen.colorB = Math.round(255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_C":
						var r2 = v[j];
						var g2 = v[j + 1];
						var b2 = v[j + 2];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_COLOR_C");
							_this1.historyParameters.push(r2);
							_this1.historyParameters.push(g2);
							_this1.historyParameters.push(b2);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_COLOR_C");
							_this1.turtleParameters.push(r2);
							_this1.turtleParameters.push(g2);
							_this1.turtleParameters.push(b2);
						} else {
							_this1.pen.colorC = Math.round(255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE":
						var r3 = v[j];
						var g3 = v[j + 1];
						var b3 = v[j + 2];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_COLOR_CHANGE");
							_this1.historyParameters.push(r3);
							_this1.historyParameters.push(g3);
							_this1.historyParameters.push(b3);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_COLOR_CHANGE");
							_this1.turtleParameters.push(r3);
							_this1.turtleParameters.push(g3);
							_this1.turtleParameters.push(b3);
						} else {
							var c = _this1.pen.currentColor;
							var r0 = (c >> 16 & 255) / 255;
							var g0 = (c >> 8 & 255) / 255;
							var b0 = (c & 255) / 255;
							_this1.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r3) * 255) << 16 | Math.round((g0 + g3) * 255) << 8 | Math.round((b0 + b3) * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE_B":
						var r4 = v[j];
						var g4 = v[j + 1];
						var b4 = v[j + 2];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_COLOR_CHANGE_B");
							_this1.historyParameters.push(r4);
							_this1.historyParameters.push(g4);
							_this1.historyParameters.push(b4);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_COLOR_CHANGE_B");
							_this1.turtleParameters.push(r4);
							_this1.turtleParameters.push(g4);
							_this1.turtleParameters.push(b4);
						} else {
							var c1 = _this1.pen.colorB;
							var r01 = (c1 >> 16 & 255) / 255;
							var g01 = (c1 >> 8 & 255) / 255;
							var b01 = (c1 & 255) / 255;
							_this1.pen.colorB = Math.round(255) << 24 | Math.round((r01 + r4) * 255) << 16 | Math.round((g01 + g4) * 255) << 8 | Math.round((b01 + b4) * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE_C":
						var r5 = v[j];
						var g5 = v[j + 1];
						var b5 = v[j + 2];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_COLOR_CHANGE_C");
							_this1.historyParameters.push(r5);
							_this1.historyParameters.push(g5);
							_this1.historyParameters.push(b5);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_COLOR_CHANGE_C");
							_this1.turtleParameters.push(r5);
							_this1.turtleParameters.push(g5);
							_this1.turtleParameters.push(b5);
						} else {
							var c2 = _this1.pen.colorC;
							var r02 = (c2 >> 16 & 255) / 255;
							var g02 = (c2 >> 8 & 255) / 255;
							var b02 = (c2 & 255) / 255;
							_this1.pen.colorC = Math.round(255) << 24 | Math.round((r02 + r5) * 255) << 16 | Math.round((g02 + g5) * 255) << 8 | Math.round((b02 + b5) * 255);
						}
						j += 3;
						break;
					case "PEN_DOWN":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_DOWN");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_DOWN");
						} else {
							_this1.penIsDown = true;
						}
						break;
					case "PEN_SIZE":
						var w = v[j];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_SIZE");
							_this1.historyParameters.push(w);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_SIZE");
							_this1.turtleParameters.push(w);
						} else {
							_this1.width = w;
						}
						++j;
						break;
					case "PEN_SIZE_CHANGE":
						var dw = v[j];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_SIZE_CHANGE");
							_this1.historyParameters.push(dw);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_SIZE_CHANGE");
							_this1.turtleParameters.push(dw);
						} else {
							_this1.width += dw;
						}
						++j;
						break;
					case "PEN_SIZE_FACTOR":
						var factor1 = v[j];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_SIZE_FACTOR");
							_this1.historyParameters.push(factor1);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_SIZE_FACTOR");
							_this1.turtleParameters.push(factor1);
						} else {
							_this1.width *= factor1;
						}
						++j;
						break;
					case "PEN_UP":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_UP");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_UP");
						} else {
							_this1.penIsDown = false;
						}
						break;
					case "PLUM":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PLUM");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PLUM");
						} else {
							_this1.pen.currentColor = -7310896;
						}
						break;
					case "RED":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("RED");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("RED");
						} else {
							_this1.pen.currentColor = -65536;
						}
						break;
					case "RIGHT":
						var degrees3 = v[j];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("RIGHT");
							_this1.historyParameters.push(degrees3);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("RIGHT");
							_this1.turtleParameters.push(degrees3);
						} else {
							_this1.rotation += degrees3 * Math.PI / 180;
						}
						++j;
						break;
					case "SET_ANGLE":
						var degrees4 = v[j];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("SET_ANGLE");
							_this1.historyParameters.push(degrees4);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("SET_ANGLE");
							_this1.turtleParameters.push(degrees4);
						} else {
							_this1.rotation = -Math.PI / 2;
							_this1.rotation += degrees4 * Math.PI / 180;
						}
						++j;
						break;
					case "SET_POSITION":
						var x2 = v[j];
						var y2 = v[j + 1];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("SET_POSITION");
							_this1.historyParameters.push(x2);
							_this1.historyParameters.push(y2);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("SET_POSITION");
							_this1.turtleParameters.push(x2);
							_this1.turtleParameters.push(y2);
						} else {
							if(_this1.endLine == 2 || _this1.endLine == 3) {
								_this1.contour.end(_this1.width);
							}
							_this1.x = x2;
							_this1.y = y2;
							var l19 = _this1.points.length;
							_this1.points[l19] = [];
							_this1.points[l19][0] = x2;
							_this1.points[l19][1] = y2;
							_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
							_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
							_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d13 = _this1.dim[_this1.dim.length - 1];
							if(x2 < d13.minX) {
								d13.minX = x2;
							}
							if(x2 > d13.maxX) {
								d13.maxX = x2;
							}
							if(y2 < d13.minY) {
								d13.minY = y2;
							}
							if(y2 > d13.maxY) {
								d13.maxY = y2;
							}
							_this1.contour.reset();
						}
						j += 2;
						break;
					case "SOUTH":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("SOUTH");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("SOUTH");
						} else {
							_this1.rotation = Math.PI / 2;
						}
						break;
					case "TAN":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("TAN");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("TAN");
						} else {
							_this1.pen.currentColor = -27273;
						}
						break;
					case "TRIANGLE_ARCH":
						var distance7 = v[j];
						var distance21 = v[j + 1];
						var radius5 = v[j + 2];
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("TRIANGLE_ARCH");
							_this1.historyParameters.push(distance7);
							_this1.historyParameters.push(distance21);
							_this1.historyParameters.push(radius5);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("TRIANGLE_ARCH");
							_this1.turtleParameters.push(distance7);
							_this1.turtleParameters.push(distance21);
							_this1.turtleParameters.push(radius5);
						} else {
							var nx11 = _this1.x + distance7 * Math.cos(_this1.rotation);
							var ny11 = _this1.y + distance7 * Math.sin(_this1.rotation);
							if(_this1.penIsDown) {
								var thruX1 = _this1.x + distance21 * Math.cos(_this1.rotation) - radius5 * Math.cos(_this1.rotation + Math.PI / 2);
								var thruY1 = _this1.y + distance21 * Math.sin(_this1.rotation) - radius5 * Math.sin(_this1.rotation + Math.PI / 2);
								if(_this1.fill) {
									_this1.pen.triangle2DFill(_this1.x,_this1.y,thruX1,thruY1,nx11,ny11);
								}
								_this1.lineTo(thruX1,thruY1);
								_this1.lineTo(nx11,ny11);
								if(_this1.fill) {
									_this1.lineTo(_this1.x,_this1.y);
								}
								if(_this1.endLine == 2 || _this1.endLine == 3) {
									_this1.contour.end(_this1.width);
								}
								_this1.x = nx11;
								_this1.y = ny11;
								var l20 = _this1.points.length;
								_this1.points[l20] = [];
								_this1.points[l20][0] = nx11;
								_this1.points[l20][1] = ny11;
								_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
								_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
								_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d14 = _this1.dim[_this1.dim.length - 1];
								if(nx11 < d14.minX) {
									d14.minX = nx11;
								}
								if(nx11 > d14.maxX) {
									d14.maxX = nx11;
								}
								if(ny11 < d14.minY) {
									d14.minY = ny11;
								}
								if(ny11 > d14.maxY) {
									d14.maxY = ny11;
								}
								_this1.contour.reset();
							} else {
								if(_this1.endLine == 2 || _this1.endLine == 3) {
									_this1.contour.end(_this1.width);
								}
								_this1.x = nx11;
								_this1.y = ny11;
								var l21 = _this1.points.length;
								_this1.points[l21] = [];
								_this1.points[l21][0] = nx11;
								_this1.points[l21][1] = ny11;
								_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
								_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
								_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d15 = _this1.dim[_this1.dim.length - 1];
								if(nx11 < d15.minX) {
									d15.minX = nx11;
								}
								if(nx11 > d15.maxX) {
									d15.maxX = nx11;
								}
								if(ny11 < d15.minY) {
									d15.minY = ny11;
								}
								if(ny11 > d15.maxY) {
									d15.maxY = ny11;
								}
								_this1.contour.reset();
							}
						}
						j += 3;
						break;
					case "WEST":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("WEST");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("WEST");
						} else {
							_this1.rotation = 0;
						}
						break;
					case "WHITE":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("WHITE");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("WHITE");
						} else {
							_this1.pen.currentColor = -1;
						}
						break;
					case "YELLOW":
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("YELLOW");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("YELLOW");
						} else {
							_this1.pen.currentColor = -256;
						}
						break;
					}
				}
				j = 0;
			}
			_this1.turtleHistoryOn = wasHistoryOn;
			_this1.turtleCommands.length = 0;
			_this1.turtleParameters.length = 0;
		}
		if(repeatCount_ > 0) {
			_this1.repeatCount = Math.round(repeatCount_);
			_this1.repeatCommands = true;
			_this1.turtleCommands.length = 0;
			_this1.turtleParameters.length = 0;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("ARCH_BEZIER");
			_this.historyParameters.push(300);
			_this.historyParameters.push(150);
			_this.historyParameters.push(-10);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("ARCH_BEZIER");
			_this.turtleParameters.push(300);
			_this.turtleParameters.push(150);
			_this.turtleParameters.push(-10);
		} else {
			var nx = _this.x + 300 * Math.cos(_this.rotation);
			var ny = _this.y + 300 * Math.sin(_this.rotation);
			if(_this.penIsDown) {
				var thruX = _this.x + 150 * Math.cos(_this.rotation) - -10 * Math.cos(_this.rotation + Math.PI / 2);
				var thruY = _this.y + 150 * Math.sin(_this.rotation) - -10 * Math.sin(_this.rotation + Math.PI / 2);
				var newx = 2 * thruX - 0.5 * (_this.x + nx);
				var newy = 2 * thruY - 0.5 * (_this.y + ny);
				_this.tempArr = [];
				var p = _this.tempArr;
				var ax = _this.x;
				var ay = _this.y;
				var x = ax - newx;
				var y = ay - newy;
				var x1 = newx - nx;
				var y1 = newy - ny;
				var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
				if(approxDistance == 0) {
					approxDistance = 0.000001;
				}
				var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
				var l = p.length;
				p[l++] = ax;
				p[l++] = ay;
				var t = step;
				while(t < 1.) {
					var u = 1 - t;
					p[l++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx;
					var u1 = 1 - t;
					p[l++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny;
					t += step;
				}
				p[l++] = nx;
				p[l++] = ny;
				var arr = _this.tempArr;
				var withMove = false;
				if(withMove == null) {
					withMove = true;
				}
				var l = arr.length;
				var i = 2;
				if(withMove) {
					var x_ = arr[0];
					var y_ = arr[1];
					if(_this.endLine == 2 || _this.endLine == 3) {
						_this.contour.end(_this.width);
					}
					_this.x = x_;
					_this.y = y_;
					var l1 = _this.points.length;
					_this.points[l1] = [];
					_this.points[l1][0] = x_;
					_this.points[l1][1] = y_;
					_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
					_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
					_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
					var d = _this.dim[_this.dim.length - 1];
					if(x_ < d.minX) {
						d.minX = x_;
					}
					if(x_ > d.maxX) {
						d.maxX = x_;
					}
					if(y_ < d.minY) {
						d.minY = y_;
					}
					if(y_ > d.maxY) {
						d.maxY = y_;
					}
					_this.contour.reset();
				} else {
					_this.lineTo(arr[0],arr[1]);
				}
				var cx = (arr[0] + arr[l - 2]) / 2;
				var cy = (arr[1] + arr[l - 1]) / 2;
				var ox = _this.x;
				var oy = _this.y;
				while(i < l) {
					if(_this.fill && _this.penIsDown) {
						if(i > 0 && i < l - 2) {
							_this.pen.triangle2DFill(arr[i - 2],arr[i - 1],arr[i],arr[i + 1],cx,cy);
						}
					}
					_this.lineTo(arr[i],arr[i + 1]);
					i += 2;
				}
				if(_this.fill && _this.penIsDown) {
					if(_this.endLine == 2 || _this.endLine == 3) {
						_this.contour.end(_this.width);
					}
					_this.x = ox;
					_this.y = oy;
					var l1 = _this.points.length;
					_this.points[l1] = [];
					_this.points[l1][0] = ox;
					_this.points[l1][1] = oy;
					_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
					_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
					_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
					var d = _this.dim[_this.dim.length - 1];
					if(ox < d.minX) {
						d.minX = ox;
					}
					if(ox > d.maxX) {
						d.maxX = ox;
					}
					if(oy < d.minY) {
						d.minY = oy;
					}
					if(oy > d.maxY) {
						d.maxY = oy;
					}
					_this.contour.reset();
					_this.lineTo(arr[l - 2],arr[l - 1]);
				}
				_this.x = nx;
				_this.y = ny;
			} else {
				if(_this.endLine == 2 || _this.endLine == 3) {
					_this.contour.end(_this.width);
				}
				_this.x = nx;
				_this.y = ny;
				var l = _this.points.length;
				_this.points[l] = [];
				_this.points[l][0] = nx;
				_this.points[l][1] = ny;
				_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
				_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
				_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this.dim[_this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this.contour.reset();
			}
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("RIGHT");
			_this1.historyParameters.push(angle);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("RIGHT");
			_this1.turtleParameters.push(angle);
		} else {
			_this1.rotation += angle * Math.PI / 180;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("PEN_COLOR_CHANGE");
			_this.historyParameters.push(-0.09);
			_this.historyParameters.push(0.01);
			_this.historyParameters.push(0.09);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("PEN_COLOR_CHANGE");
			_this.turtleParameters.push(-0.09);
			_this.turtleParameters.push(0.01);
			_this.turtleParameters.push(0.09);
		} else {
			var c = _this.pen.currentColor;
			var r0 = (c >> 16 & 255) / 255;
			var g0 = (c >> 8 & 255) / 255;
			var b0 = (c & 255) / 255;
			_this.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + (-0.09)) * 255) << 16 | Math.round((g0 + 0.01) * 255) << 8 | Math.round((b0 + 0.09) * 255);
		}
		var _this1 = _this;
		_this1.repeatCommands = false;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("END_REPEAT");
		}
		var wasHistoryOn = _this1.turtleHistoryOn;
		_this1.turtleHistoryOn = false;
		var v = _this1.turtleParameters;
		var j = 0;
		var _g = 0;
		var _g1 = _this1.repeatCount;
		while(_g < _g1) {
			var k = _g++;
			var _g2 = 0;
			var _g3 = _this1.turtleCommands.length;
			while(_g2 < _g3) {
				var i = _g2++;
				var command = _this1.turtleCommands[i];
				switch(command) {
				case "ARC":
					var radius = v[j];
					var degrees = v[j + 1];
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("ARC");
						_this1.historyParameters.push(radius);
						_this1.historyParameters.push(degrees);
					}
					if(radius != 0) {
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("ARC");
							_this1.turtleParameters.push(radius);
							_this1.turtleParameters.push(degrees);
						} else {
							var beta = degrees * Math.PI / 180 / 24;
							var alpha = (Math.PI - beta) / 2;
							var rotate = -(Math.PI / 2 - alpha);
							var baseLength = 0.5 * radius * Math.sin(beta / 2);
							var ox = _this1.x;
							var oy = _this1.y;
							var arr = [];
							arr.push(_this1.x);
							arr.push(_this1.y);
							var _g4 = 0;
							while(_g4 < 48) {
								var i1 = _g4++;
								_this1.rotation += rotate;
								var wasHistoryOn1 = _this1.turtleHistoryOn;
								_this1.turtleHistoryOn = false;
								if(_this1.turtleHistoryOn) {
									_this1.historyAdd("FORWARD");
									_this1.historyParameters.push(baseLength);
								}
								if(_this1.repeatCommands) {
									_this1.turtleCommands.push("FORWARD");
									_this1.turtleParameters.push(baseLength);
								} else {
									var nx = _this1.x + baseLength * Math.cos(_this1.rotation);
									var ny = _this1.y + baseLength * Math.sin(_this1.rotation);
									if(_this1.penIsDown) {
										_this1.lastDistance = baseLength;
										_this1.lineTo(nx,ny);
									} else {
										if(_this1.endLine == 2 || _this1.endLine == 3) {
											_this1.contour.end(_this1.width);
										}
										_this1.x = nx;
										_this1.y = ny;
										var l = _this1.points.length;
										_this1.points[l] = [];
										_this1.points[l][0] = nx;
										_this1.points[l][1] = ny;
										_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
										_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
										_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d = _this1.dim[_this1.dim.length - 1];
										if(nx < d.minX) {
											d.minX = nx;
										}
										if(nx > d.maxX) {
											d.maxX = nx;
										}
										if(ny < d.minY) {
											d.minY = ny;
										}
										if(ny > d.maxY) {
											d.maxY = ny;
										}
										_this1.contour.reset();
									}
								}
								_this1.turtleHistoryOn = wasHistoryOn1;
								if(_this1.fill) {
									arr.push(_this1.x);
									arr.push(_this1.y);
								}
							}
							if(_this1.fill) {
								var cx = (ox + arr[arr.length - 2]) / 2;
								var cy = (oy + arr[arr.length - 1]) / 2;
								var l1 = arr.length;
								var i2 = 2;
								var lx = 0.;
								var ly = 0.;
								_this1.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
								while(i2 < l1) {
									if(i2 > 2) {
										_this1.pen.triangle2DFill(lx,ly,arr[i2],arr[i2 + 1],cx,cy);
									}
									lx = arr[i2];
									ly = arr[i2 + 1];
									i2 += 2;
								}
							}
							arr.length = 0;
						}
					}
					j += 2;
					break;
				case "ARCH_BEZIER":
					var distance = v[j];
					var distance2 = v[j + 1];
					var radius1 = v[j + 2];
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("ARCH_BEZIER");
						_this1.historyParameters.push(distance);
						_this1.historyParameters.push(distance2);
						_this1.historyParameters.push(radius1);
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("ARCH_BEZIER");
						_this1.turtleParameters.push(distance);
						_this1.turtleParameters.push(distance2);
						_this1.turtleParameters.push(radius1);
					} else {
						var nx1 = _this1.x + distance * Math.cos(_this1.rotation);
						var ny1 = _this1.y + distance * Math.sin(_this1.rotation);
						if(_this1.penIsDown) {
							var thruX = _this1.x + distance2 * Math.cos(_this1.rotation) - radius1 * Math.cos(_this1.rotation + Math.PI / 2);
							var thruY = _this1.y + distance2 * Math.sin(_this1.rotation) - radius1 * Math.sin(_this1.rotation + Math.PI / 2);
							var newx = 2 * thruX - 0.5 * (_this1.x + nx1);
							var newy = 2 * thruY - 0.5 * (_this1.y + ny1);
							_this1.tempArr = [];
							var p = _this1.tempArr;
							var ax = _this1.x;
							var ay = _this1.y;
							var x = ax - newx;
							var y = ay - newy;
							var x1 = newx - nx1;
							var y1 = newy - ny1;
							var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
							if(approxDistance == 0) {
								approxDistance = 0.000001;
							}
							var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
							var l2 = p.length;
							p[l2++] = ax;
							p[l2++] = ay;
							var t = step;
							while(t < 1.) {
								var u = 1 - t;
								p[l2++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx1;
								var u1 = 1 - t;
								p[l2++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny1;
								t += step;
							}
							p[l2++] = nx1;
							p[l2++] = ny1;
							var arr1 = _this1.tempArr;
							var withMove = false;
							if(withMove == null) {
								withMove = true;
							}
							var l3 = arr1.length;
							var i3 = 2;
							if(withMove) {
								var x_ = arr1[0];
								var y_ = arr1[1];
								if(_this1.endLine == 2 || _this1.endLine == 3) {
									_this1.contour.end(_this1.width);
								}
								_this1.x = x_;
								_this1.y = y_;
								var l4 = _this1.points.length;
								_this1.points[l4] = [];
								_this1.points[l4][0] = x_;
								_this1.points[l4][1] = y_;
								_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
								_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
								_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d1 = _this1.dim[_this1.dim.length - 1];
								if(x_ < d1.minX) {
									d1.minX = x_;
								}
								if(x_ > d1.maxX) {
									d1.maxX = x_;
								}
								if(y_ < d1.minY) {
									d1.minY = y_;
								}
								if(y_ > d1.maxY) {
									d1.maxY = y_;
								}
								_this1.contour.reset();
							} else {
								_this1.lineTo(arr1[0],arr1[1]);
							}
							var cx1 = (arr1[0] + arr1[l3 - 2]) / 2;
							var cy1 = (arr1[1] + arr1[l3 - 1]) / 2;
							var ox1 = _this1.x;
							var oy1 = _this1.y;
							while(i3 < l3) {
								if(_this1.fill && _this1.penIsDown) {
									if(i3 > 0 && i3 < l3 - 2) {
										_this1.pen.triangle2DFill(arr1[i3 - 2],arr1[i3 - 1],arr1[i3],arr1[i3 + 1],cx1,cy1);
									}
								}
								_this1.lineTo(arr1[i3],arr1[i3 + 1]);
								i3 += 2;
							}
							if(_this1.fill && _this1.penIsDown) {
								if(_this1.endLine == 2 || _this1.endLine == 3) {
									_this1.contour.end(_this1.width);
								}
								_this1.x = ox1;
								_this1.y = oy1;
								var l5 = _this1.points.length;
								_this1.points[l5] = [];
								_this1.points[l5][0] = ox1;
								_this1.points[l5][1] = oy1;
								_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
								_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
								_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d2 = _this1.dim[_this1.dim.length - 1];
								if(ox1 < d2.minX) {
									d2.minX = ox1;
								}
								if(ox1 > d2.maxX) {
									d2.maxX = ox1;
								}
								if(oy1 < d2.minY) {
									d2.minY = oy1;
								}
								if(oy1 > d2.maxY) {
									d2.maxY = oy1;
								}
								_this1.contour.reset();
								_this1.lineTo(arr1[l3 - 2],arr1[l3 - 1]);
							}
							_this1.x = nx1;
							_this1.y = ny1;
						} else {
							if(_this1.endLine == 2 || _this1.endLine == 3) {
								_this1.contour.end(_this1.width);
							}
							_this1.x = nx1;
							_this1.y = ny1;
							var l6 = _this1.points.length;
							_this1.points[l6] = [];
							_this1.points[l6][0] = nx1;
							_this1.points[l6][1] = ny1;
							_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
							_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
							_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d3 = _this1.dim[_this1.dim.length - 1];
							if(nx1 < d3.minX) {
								d3.minX = nx1;
							}
							if(nx1 > d3.maxX) {
								d3.maxX = nx1;
							}
							if(ny1 < d3.minY) {
								d3.minY = ny1;
							}
							if(ny1 > d3.maxY) {
								d3.maxY = ny1;
							}
							_this1.contour.reset();
						}
					}
					j += 3;
					break;
				case "ARC_SIDES":
					var radius2 = v[j];
					var degrees1 = v[j + 1];
					var sides = v[j + 2];
					if(sides == null) {
						sides = 24;
					}
					if(_this1.turtleHistoryOn) {
						if(sides == 24) {
							_this1.historyAdd("ARC");
							_this1.historyParameters.push(radius2);
							_this1.historyParameters.push(degrees1);
						} else {
							_this1.historyAdd("ARC_SIDES");
							_this1.historyParameters.push(radius2);
							_this1.historyParameters.push(degrees1);
							_this1.historyParameters.push(sides);
						}
					}
					if(radius2 != 0) {
						if(_this1.repeatCommands) {
							if(sides == 24) {
								_this1.turtleCommands.push("ARC");
								_this1.turtleParameters.push(radius2);
								_this1.turtleParameters.push(degrees1);
							} else {
								_this1.turtleCommands.push("ARC_SIDES");
								_this1.turtleParameters.push(radius2);
								_this1.turtleParameters.push(degrees1);
								_this1.turtleParameters.push(sides);
							}
						} else {
							var beta1 = degrees1 * Math.PI / 180 / sides;
							var alpha1 = (Math.PI - beta1) / 2;
							var rotate1 = -(Math.PI / 2 - alpha1);
							var baseLength1 = 0.5 * radius2 * Math.sin(beta1 / 2);
							var ox2 = _this1.x;
							var oy2 = _this1.y;
							var arr2 = [];
							arr2.push(_this1.x);
							arr2.push(_this1.y);
							var _g5 = 0;
							while(_g5 < 48) {
								var i4 = _g5++;
								_this1.rotation += rotate1;
								var wasHistoryOn2 = _this1.turtleHistoryOn;
								_this1.turtleHistoryOn = false;
								if(_this1.turtleHistoryOn) {
									_this1.historyAdd("FORWARD");
									_this1.historyParameters.push(baseLength1);
								}
								if(_this1.repeatCommands) {
									_this1.turtleCommands.push("FORWARD");
									_this1.turtleParameters.push(baseLength1);
								} else {
									var nx2 = _this1.x + baseLength1 * Math.cos(_this1.rotation);
									var ny2 = _this1.y + baseLength1 * Math.sin(_this1.rotation);
									if(_this1.penIsDown) {
										_this1.lastDistance = baseLength1;
										_this1.lineTo(nx2,ny2);
									} else {
										if(_this1.endLine == 2 || _this1.endLine == 3) {
											_this1.contour.end(_this1.width);
										}
										_this1.x = nx2;
										_this1.y = ny2;
										var l7 = _this1.points.length;
										_this1.points[l7] = [];
										_this1.points[l7][0] = nx2;
										_this1.points[l7][1] = ny2;
										_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
										_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
										_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d4 = _this1.dim[_this1.dim.length - 1];
										if(nx2 < d4.minX) {
											d4.minX = nx2;
										}
										if(nx2 > d4.maxX) {
											d4.maxX = nx2;
										}
										if(ny2 < d4.minY) {
											d4.minY = ny2;
										}
										if(ny2 > d4.maxY) {
											d4.maxY = ny2;
										}
										_this1.contour.reset();
									}
								}
								_this1.turtleHistoryOn = wasHistoryOn2;
								if(_this1.fill) {
									arr2.push(_this1.x);
									arr2.push(_this1.y);
								}
							}
							if(_this1.fill) {
								var cx2 = (ox2 + arr2[arr2.length - 2]) / 2;
								var cy2 = (oy2 + arr2[arr2.length - 1]) / 2;
								var l8 = arr2.length;
								var i5 = 2;
								var lx1 = 0.;
								var ly1 = 0.;
								_this1.pen.triangle2DFill(ox2,oy2,arr2[0],arr2[1],cx2,cy2);
								while(i5 < l8) {
									if(i5 > 2) {
										_this1.pen.triangle2DFill(lx1,ly1,arr2[i5],arr2[i5 + 1],cx2,cy2);
									}
									lx1 = arr2[i5];
									ly1 = arr2[i5 + 1];
									i5 += 2;
								}
							}
							arr2.length = 0;
						}
					}
					j += 3;
					break;
				case "BACKWARD":
					var distance1 = v[j];
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("BACKWARD");
						_this1.historyParameters.push(distance1);
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("BACKWARD");
						_this1.turtleParameters.push(distance1);
					} else {
						var nx3 = _this1.x + distance1 * Math.cos(_this1.rotation + Math.PI);
						var ny3 = _this1.y + distance1 * Math.sin(_this1.rotation + Math.PI);
						if(_this1.penIsDown) {
							_this1.lineTo(nx3,ny3);
						} else {
							if(_this1.endLine == 2 || _this1.endLine == 3) {
								_this1.contour.end(_this1.width);
							}
							_this1.x = nx3;
							_this1.y = ny3;
							var l9 = _this1.points.length;
							_this1.points[l9] = [];
							_this1.points[l9][0] = nx3;
							_this1.points[l9][1] = ny3;
							_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
							_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
							_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d5 = _this1.dim[_this1.dim.length - 1];
							if(nx3 < d5.minX) {
								d5.minX = nx3;
							}
							if(nx3 > d5.maxX) {
								d5.maxX = nx3;
							}
							if(ny3 < d5.minY) {
								d5.minY = ny3;
							}
							if(ny3 > d5.maxY) {
								d5.maxY = ny3;
							}
							_this1.contour.reset();
						}
					}
					++j;
					break;
				case "BEGIN_REPEAT":
					break;
				case "BLACK":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("BLACK");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("BLACK");
					} else {
						_this1.pen.currentColor = -16777216;
					}
					break;
				case "BLUE":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("BLUE");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("BLUE");
					} else {
						_this1.pen.currentColor = -16776961;
					}
					break;
				case "BROWN":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("BROWN");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("BROWN");
					} else {
						_this1.pen.currentColor = -6594501;
					}
					break;
				case "CIRCLE":
					var radius3 = v[j];
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("CIRCLE");
						_this1.historyParameters.push(radius3);
					}
					if(radius3 != 0) {
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("CIRCLE");
							_this1.turtleParameters.push(radius3);
						} else {
							var beta2 = 2 * Math.PI / 24;
							var alpha2 = (Math.PI - beta2) / 2;
							var rotate2 = -(Math.PI / 2 - alpha2);
							var baseLength2 = 0.5 * radius3 * Math.sin(beta2 / 2);
							var ox3 = _this1.x;
							var oy3 = _this1.y;
							var arr3 = [];
							var _g6 = 0;
							while(_g6 < 48) {
								var i6 = _g6++;
								_this1.rotation += rotate2;
								var wasHistoryOn3 = _this1.turtleHistoryOn;
								_this1.turtleHistoryOn = false;
								if(_this1.turtleHistoryOn) {
									_this1.historyAdd("FORWARD");
									_this1.historyParameters.push(baseLength2);
								}
								if(_this1.repeatCommands) {
									_this1.turtleCommands.push("FORWARD");
									_this1.turtleParameters.push(baseLength2);
								} else {
									var nx4 = _this1.x + baseLength2 * Math.cos(_this1.rotation);
									var ny4 = _this1.y + baseLength2 * Math.sin(_this1.rotation);
									if(_this1.penIsDown) {
										_this1.lastDistance = baseLength2;
										_this1.lineTo(nx4,ny4);
									} else {
										if(_this1.endLine == 2 || _this1.endLine == 3) {
											_this1.contour.end(_this1.width);
										}
										_this1.x = nx4;
										_this1.y = ny4;
										var l10 = _this1.points.length;
										_this1.points[l10] = [];
										_this1.points[l10][0] = nx4;
										_this1.points[l10][1] = ny4;
										_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
										_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
										_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d6 = _this1.dim[_this1.dim.length - 1];
										if(nx4 < d6.minX) {
											d6.minX = nx4;
										}
										if(nx4 > d6.maxX) {
											d6.maxX = nx4;
										}
										if(ny4 < d6.minY) {
											d6.minY = ny4;
										}
										if(ny4 > d6.maxY) {
											d6.maxY = ny4;
										}
										_this1.contour.reset();
									}
								}
								_this1.turtleHistoryOn = wasHistoryOn3;
								if(_this1.fill) {
									arr3.push(_this1.x);
									arr3.push(_this1.y);
								}
							}
							if(_this1.fill) {
								var cx3 = (ox3 + arr3[arr3.length - 2]) / 2;
								var cy3 = (oy3 + arr3[arr3.length - 1]) / 2;
								var l11 = arr3.length;
								var i7 = 2;
								var lx2 = 0.;
								var ly2 = 0.;
								while(i7 < l11) {
									if(i7 > 2) {
										_this1.pen.triangle2DFill(lx2,ly2,arr3[i7],arr3[i7 + 1],cx3,cy3);
									}
									lx2 = arr3[i7];
									ly2 = arr3[i7 + 1];
									i7 += 2;
								}
							}
							arr3.length = 0;
						}
					}
					++j;
					break;
				case "CIRCLE_SIDES":
					var radius4 = v[j];
					var sides1 = v[j + 1];
					if(sides1 == null) {
						sides1 = 24;
					}
					if(_this1.turtleHistoryOn) {
						if(sides1 == 24) {
							_this1.historyAdd("CIRCLE");
							_this1.historyParameters.push(radius4);
						} else {
							_this1.historyAdd("CIRCLE_SIDES");
							_this1.historyParameters.push(radius4);
							_this1.historyParameters.push(sides1);
						}
					}
					if(radius4 != 0) {
						if(_this1.repeatCommands) {
							if(sides1 == 24) {
								_this1.turtleCommands.push("CIRCLE");
								_this1.turtleParameters.push(radius4);
							} else {
								_this1.turtleCommands.push("CIRCLE_SIDES");
								_this1.turtleParameters.push(radius4);
								_this1.turtleParameters.push(sides1);
							}
						} else {
							var beta3 = 2 * Math.PI / sides1;
							var alpha3 = (Math.PI - beta3) / 2;
							var rotate3 = -(Math.PI / 2 - alpha3);
							var baseLength3 = 0.5 * radius4 * Math.sin(beta3 / 2);
							var ox4 = _this1.x;
							var oy4 = _this1.y;
							var arr4 = [];
							var _g7 = 0;
							while(_g7 < 48) {
								var i8 = _g7++;
								_this1.rotation += rotate3;
								var wasHistoryOn4 = _this1.turtleHistoryOn;
								_this1.turtleHistoryOn = false;
								if(_this1.turtleHistoryOn) {
									_this1.historyAdd("FORWARD");
									_this1.historyParameters.push(baseLength3);
								}
								if(_this1.repeatCommands) {
									_this1.turtleCommands.push("FORWARD");
									_this1.turtleParameters.push(baseLength3);
								} else {
									var nx5 = _this1.x + baseLength3 * Math.cos(_this1.rotation);
									var ny5 = _this1.y + baseLength3 * Math.sin(_this1.rotation);
									if(_this1.penIsDown) {
										_this1.lastDistance = baseLength3;
										_this1.lineTo(nx5,ny5);
									} else {
										if(_this1.endLine == 2 || _this1.endLine == 3) {
											_this1.contour.end(_this1.width);
										}
										_this1.x = nx5;
										_this1.y = ny5;
										var l12 = _this1.points.length;
										_this1.points[l12] = [];
										_this1.points[l12][0] = nx5;
										_this1.points[l12][1] = ny5;
										_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
										_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
										_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d7 = _this1.dim[_this1.dim.length - 1];
										if(nx5 < d7.minX) {
											d7.minX = nx5;
										}
										if(nx5 > d7.maxX) {
											d7.maxX = nx5;
										}
										if(ny5 < d7.minY) {
											d7.minY = ny5;
										}
										if(ny5 > d7.maxY) {
											d7.maxY = ny5;
										}
										_this1.contour.reset();
									}
								}
								_this1.turtleHistoryOn = wasHistoryOn4;
								if(_this1.fill) {
									arr4.push(_this1.x);
									arr4.push(_this1.y);
								}
							}
							if(_this1.fill) {
								var cx4 = (ox4 + arr4[arr4.length - 2]) / 2;
								var cy4 = (oy4 + arr4[arr4.length - 1]) / 2;
								var l13 = arr4.length;
								var i9 = 2;
								var lx3 = 0.;
								var ly3 = 0.;
								while(i9 < l13) {
									if(i9 > 2) {
										_this1.pen.triangle2DFill(lx3,ly3,arr4[i9],arr4[i9 + 1],cx4,cy4);
									}
									lx3 = arr4[i9];
									ly3 = arr4[i9 + 1];
									i9 += 2;
								}
							}
							arr4.length = 0;
						}
					}
					j += 2;
					break;
				case "CYAN":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("CYAN");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("CYAN");
					} else {
						_this1.pen.currentColor = -16711681;
					}
					break;
				case "DARKISH_BLUE":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("DARKISH_BLUE");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("DARKISH_BLUE");
					} else {
						_this1.pen.currentColor = -8864837;
					}
					break;
				case "DARK_GREEN":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("DARK_GREEN");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("DARK_GREEN");
					} else {
						_this1.pen.currentColor = -10182080;
					}
					break;
				case "EAST":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("WEST");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("EAST");
					} else {
						_this1.rotation = Math.PI;
					}
					break;
				case "END_REPEAT":
					break;
				case "FILL_OFF":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("FILL_OFF");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("FILL_OFF");
					} else {
						_this1.fill = false;
					}
					break;
				case "FILL_ON":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("FILL_ON");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("FILL_ON");
					} else {
						_this1.fill = true;
					}
					break;
				case "FORWARD":
					var distance3 = v[j];
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("FORWARD");
						_this1.historyParameters.push(distance3);
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("FORWARD");
						_this1.turtleParameters.push(distance3);
					} else {
						var nx6 = _this1.x + distance3 * Math.cos(_this1.rotation);
						var ny6 = _this1.y + distance3 * Math.sin(_this1.rotation);
						if(_this1.penIsDown) {
							_this1.lastDistance = distance3;
							_this1.lineTo(nx6,ny6);
						} else {
							if(_this1.endLine == 2 || _this1.endLine == 3) {
								_this1.contour.end(_this1.width);
							}
							_this1.x = nx6;
							_this1.y = ny6;
							var l14 = _this1.points.length;
							_this1.points[l14] = [];
							_this1.points[l14][0] = nx6;
							_this1.points[l14][1] = ny6;
							_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
							_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
							_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d8 = _this1.dim[_this1.dim.length - 1];
							if(nx6 < d8.minX) {
								d8.minX = nx6;
							}
							if(nx6 > d8.maxX) {
								d8.maxX = nx6;
							}
							if(ny6 < d8.minY) {
								d8.minY = ny6;
							}
							if(ny6 > d8.maxY) {
								d8.maxY = ny6;
							}
							_this1.contour.reset();
						}
					}
					++j;
					break;
				case "FORWARD_CHANGE":
					var deltaDistance = v[j];
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("FORWARD_CHANGE");
						_this1.historyParameters.push(deltaDistance);
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("FORWARD_CHANGE");
						_this1.turtleParameters.push(deltaDistance);
					} else {
						var distance4 = _this1.lastDistance + deltaDistance;
						var nx7 = _this1.x + distance4 * Math.cos(_this1.rotation);
						var ny7 = _this1.y + distance4 * Math.sin(_this1.rotation);
						if(_this1.penIsDown) {
							_this1.lastDistance = distance4 + deltaDistance;
							_this1.lineTo(nx7,ny7);
						} else {
							if(_this1.endLine == 2 || _this1.endLine == 3) {
								_this1.contour.end(_this1.width);
							}
							_this1.x = nx7;
							_this1.y = ny7;
							var l15 = _this1.points.length;
							_this1.points[l15] = [];
							_this1.points[l15][0] = nx7;
							_this1.points[l15][1] = ny7;
							_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
							_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
							_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d9 = _this1.dim[_this1.dim.length - 1];
							if(nx7 < d9.minX) {
								d9.minX = nx7;
							}
							if(nx7 > d9.maxX) {
								d9.maxX = nx7;
							}
							if(ny7 < d9.minY) {
								d9.minY = ny7;
							}
							if(ny7 > d9.maxY) {
								d9.maxY = ny7;
							}
							_this1.contour.reset();
						}
					}
					++j;
					break;
				case "FORWARD_FACTOR":
					var factor = v[j];
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("FORWARD_FACTOR");
						_this1.historyParameters.push(factor);
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("FORWARD_FACTOR");
						_this1.turtleParameters.push(factor);
					} else {
						var distance5 = _this1.lastDistance * factor;
						var nx8 = _this1.x + distance5 * Math.cos(_this1.rotation);
						var ny8 = _this1.y + distance5 * Math.sin(_this1.rotation);
						if(_this1.penIsDown) {
							_this1.lastDistance = distance5;
							_this1.lineTo(nx8,ny8);
						} else {
							if(_this1.endLine == 2 || _this1.endLine == 3) {
								_this1.contour.end(_this1.width);
							}
							_this1.x = nx8;
							_this1.y = ny8;
							var l16 = _this1.points.length;
							_this1.points[l16] = [];
							_this1.points[l16][0] = nx8;
							_this1.points[l16][1] = ny8;
							_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
							_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
							_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d10 = _this1.dim[_this1.dim.length - 1];
							if(nx8 < d10.minX) {
								d10.minX = nx8;
							}
							if(nx8 > d10.maxX) {
								d10.maxX = nx8;
							}
							if(ny8 < d10.minY) {
								d10.minY = ny8;
							}
							if(ny8 > d10.maxY) {
								d10.maxY = ny8;
							}
							_this1.contour.reset();
						}
					}
					++j;
					break;
				case "GREEN":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("GREEN");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("GREEN");
					} else {
						_this1.pen.currentColor = -16711936;
					}
					break;
				case "GREY":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("GREY");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("GREY");
					} else {
						_this1.pen.currentColor = -4737097;
					}
					break;
				case "LEFT":
					var degrees2 = v[j];
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("LEFT");
						_this1.historyParameters.push(degrees2);
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("LEFT");
						_this1.turtleParameters.push(degrees2);
					} else {
						_this1.rotation -= degrees2 * Math.PI / 180;
					}
					++j;
					break;
				case "LIGHT_BROWN":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("LIGHT_BROWN");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("LIGHT_BROWN");
					} else {
						_this1.pen.currentColor = -3831790;
					}
					break;
				case "MAGENTA":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("MAGENTA");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("MAGENTA");
					} else {
						_this1.pen.currentColor = -65281;
					}
					break;
				case "MOVE_PEN":
					var distance6 = v[j];
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("MOVE_PEN");
						_this1.turtleParameters.push(distance6);
					} else if(_this1.penIsDown) {
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_UP");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_UP");
						} else {
							_this1.penIsDown = false;
						}
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("FORWARD");
							_this1.historyParameters.push(distance6);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("FORWARD");
							_this1.turtleParameters.push(distance6);
						} else {
							var nx9 = _this1.x + distance6 * Math.cos(_this1.rotation);
							var ny9 = _this1.y + distance6 * Math.sin(_this1.rotation);
							if(_this1.penIsDown) {
								_this1.lastDistance = distance6;
								_this1.lineTo(nx9,ny9);
							} else {
								if(_this1.endLine == 2 || _this1.endLine == 3) {
									_this1.contour.end(_this1.width);
								}
								_this1.x = nx9;
								_this1.y = ny9;
								var l17 = _this1.points.length;
								_this1.points[l17] = [];
								_this1.points[l17][0] = nx9;
								_this1.points[l17][1] = ny9;
								_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
								_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
								_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d11 = _this1.dim[_this1.dim.length - 1];
								if(nx9 < d11.minX) {
									d11.minX = nx9;
								}
								if(nx9 > d11.maxX) {
									d11.maxX = nx9;
								}
								if(ny9 < d11.minY) {
									d11.minY = ny9;
								}
								if(ny9 > d11.maxY) {
									d11.maxY = ny9;
								}
								_this1.contour.reset();
							}
						}
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("PEN_DOWN");
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("PEN_DOWN");
						} else {
							_this1.penIsDown = true;
						}
					} else {
						if(_this1.turtleHistoryOn) {
							_this1.historyAdd("FORWARD");
							_this1.historyParameters.push(distance6);
						}
						if(_this1.repeatCommands) {
							_this1.turtleCommands.push("FORWARD");
							_this1.turtleParameters.push(distance6);
						} else {
							var nx10 = _this1.x + distance6 * Math.cos(_this1.rotation);
							var ny10 = _this1.y + distance6 * Math.sin(_this1.rotation);
							if(_this1.penIsDown) {
								_this1.lastDistance = distance6;
								_this1.lineTo(nx10,ny10);
							} else {
								if(_this1.endLine == 2 || _this1.endLine == 3) {
									_this1.contour.end(_this1.width);
								}
								_this1.x = nx10;
								_this1.y = ny10;
								var l18 = _this1.points.length;
								_this1.points[l18] = [];
								_this1.points[l18][0] = nx10;
								_this1.points[l18][1] = ny10;
								_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
								_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
								_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d12 = _this1.dim[_this1.dim.length - 1];
								if(nx10 < d12.minX) {
									d12.minX = nx10;
								}
								if(nx10 > d12.maxX) {
									d12.maxX = nx10;
								}
								if(ny10 < d12.minY) {
									d12.minY = ny10;
								}
								if(ny10 > d12.maxY) {
									d12.maxY = ny10;
								}
								_this1.contour.reset();
							}
						}
					}
					++j;
					break;
				case "NORTH":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("NORTH");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("NORTH");
					} else {
						_this1.rotation = -Math.PI / 2;
					}
					break;
				case "ORANGE":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("ORANGE");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("ORANGE");
					} else {
						_this1.pen.currentColor = -23808;
					}
					break;
				case "PEN_COLOR":
					var r = v[j];
					var g = v[j + 1];
					var b = v[j + 2];
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("PEN_COLOR");
						_this1.historyParameters.push(r);
						_this1.historyParameters.push(g);
						_this1.historyParameters.push(b);
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("PEN_COLOR");
						_this1.turtleParameters.push(r);
						_this1.turtleParameters.push(g);
						_this1.turtleParameters.push(b);
					} else {
						_this1.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_B":
					var r1 = v[j];
					var g1 = v[j + 1];
					var b1 = v[j + 2];
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("PEN_COLOR_B");
						_this1.historyParameters.push(r1);
						_this1.historyParameters.push(g1);
						_this1.historyParameters.push(b1);
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("PEN_COLOR_B");
						_this1.turtleParameters.push(r1);
						_this1.turtleParameters.push(g1);
						_this1.turtleParameters.push(b1);
					} else {
						_this1.pen.colorB = Math.round(255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_C":
					var r2 = v[j];
					var g2 = v[j + 1];
					var b2 = v[j + 2];
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("PEN_COLOR_C");
						_this1.historyParameters.push(r2);
						_this1.historyParameters.push(g2);
						_this1.historyParameters.push(b2);
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("PEN_COLOR_C");
						_this1.turtleParameters.push(r2);
						_this1.turtleParameters.push(g2);
						_this1.turtleParameters.push(b2);
					} else {
						_this1.pen.colorC = Math.round(255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE":
					var r3 = v[j];
					var g3 = v[j + 1];
					var b3 = v[j + 2];
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("PEN_COLOR_CHANGE");
						_this1.historyParameters.push(r3);
						_this1.historyParameters.push(g3);
						_this1.historyParameters.push(b3);
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("PEN_COLOR_CHANGE");
						_this1.turtleParameters.push(r3);
						_this1.turtleParameters.push(g3);
						_this1.turtleParameters.push(b3);
					} else {
						var c = _this1.pen.currentColor;
						var r0 = (c >> 16 & 255) / 255;
						var g0 = (c >> 8 & 255) / 255;
						var b0 = (c & 255) / 255;
						_this1.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r3) * 255) << 16 | Math.round((g0 + g3) * 255) << 8 | Math.round((b0 + b3) * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE_B":
					var r4 = v[j];
					var g4 = v[j + 1];
					var b4 = v[j + 2];
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("PEN_COLOR_CHANGE_B");
						_this1.historyParameters.push(r4);
						_this1.historyParameters.push(g4);
						_this1.historyParameters.push(b4);
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("PEN_COLOR_CHANGE_B");
						_this1.turtleParameters.push(r4);
						_this1.turtleParameters.push(g4);
						_this1.turtleParameters.push(b4);
					} else {
						var c1 = _this1.pen.colorB;
						var r01 = (c1 >> 16 & 255) / 255;
						var g01 = (c1 >> 8 & 255) / 255;
						var b01 = (c1 & 255) / 255;
						_this1.pen.colorB = Math.round(255) << 24 | Math.round((r01 + r4) * 255) << 16 | Math.round((g01 + g4) * 255) << 8 | Math.round((b01 + b4) * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE_C":
					var r5 = v[j];
					var g5 = v[j + 1];
					var b5 = v[j + 2];
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("PEN_COLOR_CHANGE_C");
						_this1.historyParameters.push(r5);
						_this1.historyParameters.push(g5);
						_this1.historyParameters.push(b5);
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("PEN_COLOR_CHANGE_C");
						_this1.turtleParameters.push(r5);
						_this1.turtleParameters.push(g5);
						_this1.turtleParameters.push(b5);
					} else {
						var c2 = _this1.pen.colorC;
						var r02 = (c2 >> 16 & 255) / 255;
						var g02 = (c2 >> 8 & 255) / 255;
						var b02 = (c2 & 255) / 255;
						_this1.pen.colorC = Math.round(255) << 24 | Math.round((r02 + r5) * 255) << 16 | Math.round((g02 + g5) * 255) << 8 | Math.round((b02 + b5) * 255);
					}
					j += 3;
					break;
				case "PEN_DOWN":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("PEN_DOWN");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("PEN_DOWN");
					} else {
						_this1.penIsDown = true;
					}
					break;
				case "PEN_SIZE":
					var w = v[j];
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("PEN_SIZE");
						_this1.historyParameters.push(w);
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("PEN_SIZE");
						_this1.turtleParameters.push(w);
					} else {
						_this1.width = w;
					}
					++j;
					break;
				case "PEN_SIZE_CHANGE":
					var dw = v[j];
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("PEN_SIZE_CHANGE");
						_this1.historyParameters.push(dw);
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("PEN_SIZE_CHANGE");
						_this1.turtleParameters.push(dw);
					} else {
						_this1.width += dw;
					}
					++j;
					break;
				case "PEN_SIZE_FACTOR":
					var factor1 = v[j];
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("PEN_SIZE_FACTOR");
						_this1.historyParameters.push(factor1);
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("PEN_SIZE_FACTOR");
						_this1.turtleParameters.push(factor1);
					} else {
						_this1.width *= factor1;
					}
					++j;
					break;
				case "PEN_UP":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("PEN_UP");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("PEN_UP");
					} else {
						_this1.penIsDown = false;
					}
					break;
				case "PLUM":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("PLUM");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("PLUM");
					} else {
						_this1.pen.currentColor = -7310896;
					}
					break;
				case "RED":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("RED");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("RED");
					} else {
						_this1.pen.currentColor = -65536;
					}
					break;
				case "RIGHT":
					var degrees3 = v[j];
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("RIGHT");
						_this1.historyParameters.push(degrees3);
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("RIGHT");
						_this1.turtleParameters.push(degrees3);
					} else {
						_this1.rotation += degrees3 * Math.PI / 180;
					}
					++j;
					break;
				case "SET_ANGLE":
					var degrees4 = v[j];
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("SET_ANGLE");
						_this1.historyParameters.push(degrees4);
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("SET_ANGLE");
						_this1.turtleParameters.push(degrees4);
					} else {
						_this1.rotation = -Math.PI / 2;
						_this1.rotation += degrees4 * Math.PI / 180;
					}
					++j;
					break;
				case "SET_POSITION":
					var x2 = v[j];
					var y2 = v[j + 1];
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("SET_POSITION");
						_this1.historyParameters.push(x2);
						_this1.historyParameters.push(y2);
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("SET_POSITION");
						_this1.turtleParameters.push(x2);
						_this1.turtleParameters.push(y2);
					} else {
						if(_this1.endLine == 2 || _this1.endLine == 3) {
							_this1.contour.end(_this1.width);
						}
						_this1.x = x2;
						_this1.y = y2;
						var l19 = _this1.points.length;
						_this1.points[l19] = [];
						_this1.points[l19][0] = x2;
						_this1.points[l19][1] = y2;
						_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
						_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
						_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d13 = _this1.dim[_this1.dim.length - 1];
						if(x2 < d13.minX) {
							d13.minX = x2;
						}
						if(x2 > d13.maxX) {
							d13.maxX = x2;
						}
						if(y2 < d13.minY) {
							d13.minY = y2;
						}
						if(y2 > d13.maxY) {
							d13.maxY = y2;
						}
						_this1.contour.reset();
					}
					j += 2;
					break;
				case "SOUTH":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("SOUTH");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("SOUTH");
					} else {
						_this1.rotation = Math.PI / 2;
					}
					break;
				case "TAN":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("TAN");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("TAN");
					} else {
						_this1.pen.currentColor = -27273;
					}
					break;
				case "TRIANGLE_ARCH":
					var distance7 = v[j];
					var distance21 = v[j + 1];
					var radius5 = v[j + 2];
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("TRIANGLE_ARCH");
						_this1.historyParameters.push(distance7);
						_this1.historyParameters.push(distance21);
						_this1.historyParameters.push(radius5);
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("TRIANGLE_ARCH");
						_this1.turtleParameters.push(distance7);
						_this1.turtleParameters.push(distance21);
						_this1.turtleParameters.push(radius5);
					} else {
						var nx11 = _this1.x + distance7 * Math.cos(_this1.rotation);
						var ny11 = _this1.y + distance7 * Math.sin(_this1.rotation);
						if(_this1.penIsDown) {
							var thruX1 = _this1.x + distance21 * Math.cos(_this1.rotation) - radius5 * Math.cos(_this1.rotation + Math.PI / 2);
							var thruY1 = _this1.y + distance21 * Math.sin(_this1.rotation) - radius5 * Math.sin(_this1.rotation + Math.PI / 2);
							if(_this1.fill) {
								_this1.pen.triangle2DFill(_this1.x,_this1.y,thruX1,thruY1,nx11,ny11);
							}
							_this1.lineTo(thruX1,thruY1);
							_this1.lineTo(nx11,ny11);
							if(_this1.fill) {
								_this1.lineTo(_this1.x,_this1.y);
							}
							if(_this1.endLine == 2 || _this1.endLine == 3) {
								_this1.contour.end(_this1.width);
							}
							_this1.x = nx11;
							_this1.y = ny11;
							var l20 = _this1.points.length;
							_this1.points[l20] = [];
							_this1.points[l20][0] = nx11;
							_this1.points[l20][1] = ny11;
							_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
							_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
							_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d14 = _this1.dim[_this1.dim.length - 1];
							if(nx11 < d14.minX) {
								d14.minX = nx11;
							}
							if(nx11 > d14.maxX) {
								d14.maxX = nx11;
							}
							if(ny11 < d14.minY) {
								d14.minY = ny11;
							}
							if(ny11 > d14.maxY) {
								d14.maxY = ny11;
							}
							_this1.contour.reset();
						} else {
							if(_this1.endLine == 2 || _this1.endLine == 3) {
								_this1.contour.end(_this1.width);
							}
							_this1.x = nx11;
							_this1.y = ny11;
							var l21 = _this1.points.length;
							_this1.points[l21] = [];
							_this1.points[l21][0] = nx11;
							_this1.points[l21][1] = ny11;
							_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
							_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
							_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d15 = _this1.dim[_this1.dim.length - 1];
							if(nx11 < d15.minX) {
								d15.minX = nx11;
							}
							if(nx11 > d15.maxX) {
								d15.maxX = nx11;
							}
							if(ny11 < d15.minY) {
								d15.minY = ny11;
							}
							if(ny11 > d15.maxY) {
								d15.maxY = ny11;
							}
							_this1.contour.reset();
						}
					}
					j += 3;
					break;
				case "WEST":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("WEST");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("WEST");
					} else {
						_this1.rotation = 0;
					}
					break;
				case "WHITE":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("WHITE");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("WHITE");
					} else {
						_this1.pen.currentColor = -1;
					}
					break;
				case "YELLOW":
					if(_this1.turtleHistoryOn) {
						_this1.historyAdd("YELLOW");
					}
					if(_this1.repeatCommands) {
						_this1.turtleCommands.push("YELLOW");
					} else {
						_this1.pen.currentColor = -256;
					}
					break;
				}
			}
			j = 0;
		}
		_this1.turtleHistoryOn = wasHistoryOn;
		_this1.turtleCommands.length = 0;
		_this1.turtleParameters.length = 0;
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("BLUE");
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("BLUE");
		} else {
			_this.pen.currentColor = -16776961;
		}
	}
	,heptagram: function() {
		var sketcher = new cornerContour_Sketcher(this.pen2D,4,0);
		if(sketcher.turtleHistoryOn) {
			sketcher.historyAdd("SET_POSITION");
			sketcher.historyParameters.push(700);
			sketcher.historyParameters.push(400);
		}
		if(sketcher.repeatCommands) {
			sketcher.turtleCommands.push("SET_POSITION");
			sketcher.turtleParameters.push(700);
			sketcher.turtleParameters.push(400);
		} else {
			if(sketcher.endLine == 2 || sketcher.endLine == 3) {
				sketcher.contour.end(sketcher.width);
			}
			sketcher.x = 700;
			sketcher.y = 400;
			var l = sketcher.points.length;
			sketcher.points[l] = [];
			sketcher.points[l][0] = 700;
			sketcher.points[l][1] = 400;
			sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
			sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
			sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = sketcher.dim[sketcher.dim.length - 1];
			if(700 < d.minX) {
				d.minX = 700;
			}
			if(700 > d.maxX) {
				d.maxX = 700;
			}
			if(400 < d.minY) {
				d.minY = 400;
			}
			if(400 > d.maxY) {
				d.maxY = 400;
			}
			sketcher.contour.reset();
		}
		var _this = sketcher;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("PEN_SIZE");
			_this.historyParameters.push(10);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("PEN_SIZE");
			_this.turtleParameters.push(10);
		} else {
			_this.width = 10;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("PLUM");
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("PLUM");
		} else {
			_this1.pen.currentColor = -7310896;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("WEST");
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("WEST");
		} else {
			_this.rotation = 0;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("FILL_OFF");
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("FILL_OFF");
		} else {
			_this1.fill = false;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("BEGIN_REPEAT");
			_this.historyParameters.push(Math.round(8));
		}
		if(_this.repeatCommands == true) {
			_this.repeatCommands = false;
			if(_this.turtleHistoryOn) {
				_this.historyAdd("END_REPEAT");
			}
			var wasHistoryOn = _this.turtleHistoryOn;
			_this.turtleHistoryOn = false;
			var v = _this.turtleParameters;
			var j = 0;
			var _g = 0;
			var _g1 = _this.repeatCount;
			while(_g < _g1) {
				var k = _g++;
				var _g2 = 0;
				var _g3 = _this.turtleCommands.length;
				while(_g2 < _g3) {
					var i = _g2++;
					var command = _this.turtleCommands[i];
					switch(command) {
					case "ARC":
						var radius = v[j];
						var degrees = v[j + 1];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("ARC");
							_this.historyParameters.push(radius);
							_this.historyParameters.push(degrees);
						}
						if(radius != 0) {
							if(_this.repeatCommands) {
								_this.turtleCommands.push("ARC");
								_this.turtleParameters.push(radius);
								_this.turtleParameters.push(degrees);
							} else {
								var beta = degrees * Math.PI / 180 / 24;
								var alpha = (Math.PI - beta) / 2;
								var rotate = -(Math.PI / 2 - alpha);
								var baseLength = 0.5 * radius * Math.sin(beta / 2);
								var ox = _this.x;
								var oy = _this.y;
								var arr = [];
								arr.push(_this.x);
								arr.push(_this.y);
								var _g4 = 0;
								while(_g4 < 48) {
									var i1 = _g4++;
									_this.rotation += rotate;
									var wasHistoryOn1 = _this.turtleHistoryOn;
									_this.turtleHistoryOn = false;
									if(_this.turtleHistoryOn) {
										_this.historyAdd("FORWARD");
										_this.historyParameters.push(baseLength);
									}
									if(_this.repeatCommands) {
										_this.turtleCommands.push("FORWARD");
										_this.turtleParameters.push(baseLength);
									} else {
										var nx = _this.x + baseLength * Math.cos(_this.rotation);
										var ny = _this.y + baseLength * Math.sin(_this.rotation);
										if(_this.penIsDown) {
											_this.lastDistance = baseLength;
											_this.lineTo(nx,ny);
										} else {
											if(_this.endLine == 2 || _this.endLine == 3) {
												_this.contour.end(_this.width);
											}
											_this.x = nx;
											_this.y = ny;
											var l = _this.points.length;
											_this.points[l] = [];
											_this.points[l][0] = nx;
											_this.points[l][1] = ny;
											_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
											_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
											_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d = _this.dim[_this.dim.length - 1];
											if(nx < d.minX) {
												d.minX = nx;
											}
											if(nx > d.maxX) {
												d.maxX = nx;
											}
											if(ny < d.minY) {
												d.minY = ny;
											}
											if(ny > d.maxY) {
												d.maxY = ny;
											}
											_this.contour.reset();
										}
									}
									_this.turtleHistoryOn = wasHistoryOn1;
									if(_this.fill) {
										arr.push(_this.x);
										arr.push(_this.y);
									}
								}
								if(_this.fill) {
									var cx = (ox + arr[arr.length - 2]) / 2;
									var cy = (oy + arr[arr.length - 1]) / 2;
									var l1 = arr.length;
									var i2 = 2;
									var lx = 0.;
									var ly = 0.;
									_this.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
									while(i2 < l1) {
										if(i2 > 2) {
											_this.pen.triangle2DFill(lx,ly,arr[i2],arr[i2 + 1],cx,cy);
										}
										lx = arr[i2];
										ly = arr[i2 + 1];
										i2 += 2;
									}
								}
								arr.length = 0;
							}
						}
						j += 2;
						break;
					case "ARCH_BEZIER":
						var distance = v[j];
						var distance2 = v[j + 1];
						var radius1 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("ARCH_BEZIER");
							_this.historyParameters.push(distance);
							_this.historyParameters.push(distance2);
							_this.historyParameters.push(radius1);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("ARCH_BEZIER");
							_this.turtleParameters.push(distance);
							_this.turtleParameters.push(distance2);
							_this.turtleParameters.push(radius1);
						} else {
							var nx1 = _this.x + distance * Math.cos(_this.rotation);
							var ny1 = _this.y + distance * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								var thruX = _this.x + distance2 * Math.cos(_this.rotation) - radius1 * Math.cos(_this.rotation + Math.PI / 2);
								var thruY = _this.y + distance2 * Math.sin(_this.rotation) - radius1 * Math.sin(_this.rotation + Math.PI / 2);
								var newx = 2 * thruX - 0.5 * (_this.x + nx1);
								var newy = 2 * thruY - 0.5 * (_this.y + ny1);
								_this.tempArr = [];
								var p = _this.tempArr;
								var ax = _this.x;
								var ay = _this.y;
								var x = ax - newx;
								var y = ay - newy;
								var x1 = newx - nx1;
								var y1 = newy - ny1;
								var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
								if(approxDistance == 0) {
									approxDistance = 0.000001;
								}
								var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
								var l2 = p.length;
								p[l2++] = ax;
								p[l2++] = ay;
								var t = step;
								while(t < 1.) {
									var u = 1 - t;
									p[l2++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx1;
									var u1 = 1 - t;
									p[l2++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny1;
									t += step;
								}
								p[l2++] = nx1;
								p[l2++] = ny1;
								var arr1 = _this.tempArr;
								var withMove = false;
								if(withMove == null) {
									withMove = true;
								}
								var l3 = arr1.length;
								var i3 = 2;
								if(withMove) {
									var x_ = arr1[0];
									var y_ = arr1[1];
									if(_this.endLine == 2 || _this.endLine == 3) {
										_this.contour.end(_this.width);
									}
									_this.x = x_;
									_this.y = y_;
									var l4 = _this.points.length;
									_this.points[l4] = [];
									_this.points[l4][0] = x_;
									_this.points[l4][1] = y_;
									_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
									_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
									_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d1 = _this.dim[_this.dim.length - 1];
									if(x_ < d1.minX) {
										d1.minX = x_;
									}
									if(x_ > d1.maxX) {
										d1.maxX = x_;
									}
									if(y_ < d1.minY) {
										d1.minY = y_;
									}
									if(y_ > d1.maxY) {
										d1.maxY = y_;
									}
									_this.contour.reset();
								} else {
									_this.lineTo(arr1[0],arr1[1]);
								}
								var cx1 = (arr1[0] + arr1[l3 - 2]) / 2;
								var cy1 = (arr1[1] + arr1[l3 - 1]) / 2;
								var ox1 = _this.x;
								var oy1 = _this.y;
								while(i3 < l3) {
									if(_this.fill && _this.penIsDown) {
										if(i3 > 0 && i3 < l3 - 2) {
											_this.pen.triangle2DFill(arr1[i3 - 2],arr1[i3 - 1],arr1[i3],arr1[i3 + 1],cx1,cy1);
										}
									}
									_this.lineTo(arr1[i3],arr1[i3 + 1]);
									i3 += 2;
								}
								if(_this.fill && _this.penIsDown) {
									if(_this.endLine == 2 || _this.endLine == 3) {
										_this.contour.end(_this.width);
									}
									_this.x = ox1;
									_this.y = oy1;
									var l5 = _this.points.length;
									_this.points[l5] = [];
									_this.points[l5][0] = ox1;
									_this.points[l5][1] = oy1;
									_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
									_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
									_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d2 = _this.dim[_this.dim.length - 1];
									if(ox1 < d2.minX) {
										d2.minX = ox1;
									}
									if(ox1 > d2.maxX) {
										d2.maxX = ox1;
									}
									if(oy1 < d2.minY) {
										d2.minY = oy1;
									}
									if(oy1 > d2.maxY) {
										d2.maxY = oy1;
									}
									_this.contour.reset();
									_this.lineTo(arr1[l3 - 2],arr1[l3 - 1]);
								}
								_this.x = nx1;
								_this.y = ny1;
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx1;
								_this.y = ny1;
								var l6 = _this.points.length;
								_this.points[l6] = [];
								_this.points[l6][0] = nx1;
								_this.points[l6][1] = ny1;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d3 = _this.dim[_this.dim.length - 1];
								if(nx1 < d3.minX) {
									d3.minX = nx1;
								}
								if(nx1 > d3.maxX) {
									d3.maxX = nx1;
								}
								if(ny1 < d3.minY) {
									d3.minY = ny1;
								}
								if(ny1 > d3.maxY) {
									d3.maxY = ny1;
								}
								_this.contour.reset();
							}
						}
						j += 3;
						break;
					case "ARC_SIDES":
						var radius2 = v[j];
						var degrees1 = v[j + 1];
						var sides = v[j + 2];
						if(sides == null) {
							sides = 24;
						}
						if(_this.turtleHistoryOn) {
							if(sides == 24) {
								_this.historyAdd("ARC");
								_this.historyParameters.push(radius2);
								_this.historyParameters.push(degrees1);
							} else {
								_this.historyAdd("ARC_SIDES");
								_this.historyParameters.push(radius2);
								_this.historyParameters.push(degrees1);
								_this.historyParameters.push(sides);
							}
						}
						if(radius2 != 0) {
							if(_this.repeatCommands) {
								if(sides == 24) {
									_this.turtleCommands.push("ARC");
									_this.turtleParameters.push(radius2);
									_this.turtleParameters.push(degrees1);
								} else {
									_this.turtleCommands.push("ARC_SIDES");
									_this.turtleParameters.push(radius2);
									_this.turtleParameters.push(degrees1);
									_this.turtleParameters.push(sides);
								}
							} else {
								var beta1 = degrees1 * Math.PI / 180 / sides;
								var alpha1 = (Math.PI - beta1) / 2;
								var rotate1 = -(Math.PI / 2 - alpha1);
								var baseLength1 = 0.5 * radius2 * Math.sin(beta1 / 2);
								var ox2 = _this.x;
								var oy2 = _this.y;
								var arr2 = [];
								arr2.push(_this.x);
								arr2.push(_this.y);
								var _g5 = 0;
								while(_g5 < 48) {
									var i4 = _g5++;
									_this.rotation += rotate1;
									var wasHistoryOn2 = _this.turtleHistoryOn;
									_this.turtleHistoryOn = false;
									if(_this.turtleHistoryOn) {
										_this.historyAdd("FORWARD");
										_this.historyParameters.push(baseLength1);
									}
									if(_this.repeatCommands) {
										_this.turtleCommands.push("FORWARD");
										_this.turtleParameters.push(baseLength1);
									} else {
										var nx2 = _this.x + baseLength1 * Math.cos(_this.rotation);
										var ny2 = _this.y + baseLength1 * Math.sin(_this.rotation);
										if(_this.penIsDown) {
											_this.lastDistance = baseLength1;
											_this.lineTo(nx2,ny2);
										} else {
											if(_this.endLine == 2 || _this.endLine == 3) {
												_this.contour.end(_this.width);
											}
											_this.x = nx2;
											_this.y = ny2;
											var l7 = _this.points.length;
											_this.points[l7] = [];
											_this.points[l7][0] = nx2;
											_this.points[l7][1] = ny2;
											_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
											_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
											_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d4 = _this.dim[_this.dim.length - 1];
											if(nx2 < d4.minX) {
												d4.minX = nx2;
											}
											if(nx2 > d4.maxX) {
												d4.maxX = nx2;
											}
											if(ny2 < d4.minY) {
												d4.minY = ny2;
											}
											if(ny2 > d4.maxY) {
												d4.maxY = ny2;
											}
											_this.contour.reset();
										}
									}
									_this.turtleHistoryOn = wasHistoryOn2;
									if(_this.fill) {
										arr2.push(_this.x);
										arr2.push(_this.y);
									}
								}
								if(_this.fill) {
									var cx2 = (ox2 + arr2[arr2.length - 2]) / 2;
									var cy2 = (oy2 + arr2[arr2.length - 1]) / 2;
									var l8 = arr2.length;
									var i5 = 2;
									var lx1 = 0.;
									var ly1 = 0.;
									_this.pen.triangle2DFill(ox2,oy2,arr2[0],arr2[1],cx2,cy2);
									while(i5 < l8) {
										if(i5 > 2) {
											_this.pen.triangle2DFill(lx1,ly1,arr2[i5],arr2[i5 + 1],cx2,cy2);
										}
										lx1 = arr2[i5];
										ly1 = arr2[i5 + 1];
										i5 += 2;
									}
								}
								arr2.length = 0;
							}
						}
						j += 3;
						break;
					case "BACKWARD":
						var distance1 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("BACKWARD");
							_this.historyParameters.push(distance1);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("BACKWARD");
							_this.turtleParameters.push(distance1);
						} else {
							var nx3 = _this.x + distance1 * Math.cos(_this.rotation + Math.PI);
							var ny3 = _this.y + distance1 * Math.sin(_this.rotation + Math.PI);
							if(_this.penIsDown) {
								_this.lineTo(nx3,ny3);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx3;
								_this.y = ny3;
								var l9 = _this.points.length;
								_this.points[l9] = [];
								_this.points[l9][0] = nx3;
								_this.points[l9][1] = ny3;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d5 = _this.dim[_this.dim.length - 1];
								if(nx3 < d5.minX) {
									d5.minX = nx3;
								}
								if(nx3 > d5.maxX) {
									d5.maxX = nx3;
								}
								if(ny3 < d5.minY) {
									d5.minY = ny3;
								}
								if(ny3 > d5.maxY) {
									d5.maxY = ny3;
								}
								_this.contour.reset();
							}
						}
						++j;
						break;
					case "BEGIN_REPEAT":
						break;
					case "BLACK":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("BLACK");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("BLACK");
						} else {
							_this.pen.currentColor = -16777216;
						}
						break;
					case "BLUE":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("BLUE");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("BLUE");
						} else {
							_this.pen.currentColor = -16776961;
						}
						break;
					case "BROWN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("BROWN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("BROWN");
						} else {
							_this.pen.currentColor = -6594501;
						}
						break;
					case "CIRCLE":
						var radius3 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("CIRCLE");
							_this.historyParameters.push(radius3);
						}
						if(radius3 != 0) {
							if(_this.repeatCommands) {
								_this.turtleCommands.push("CIRCLE");
								_this.turtleParameters.push(radius3);
							} else {
								var beta2 = 2 * Math.PI / 24;
								var alpha2 = (Math.PI - beta2) / 2;
								var rotate2 = -(Math.PI / 2 - alpha2);
								var baseLength2 = 0.5 * radius3 * Math.sin(beta2 / 2);
								var ox3 = _this.x;
								var oy3 = _this.y;
								var arr3 = [];
								var _g6 = 0;
								while(_g6 < 48) {
									var i6 = _g6++;
									_this.rotation += rotate2;
									var wasHistoryOn3 = _this.turtleHistoryOn;
									_this.turtleHistoryOn = false;
									if(_this.turtleHistoryOn) {
										_this.historyAdd("FORWARD");
										_this.historyParameters.push(baseLength2);
									}
									if(_this.repeatCommands) {
										_this.turtleCommands.push("FORWARD");
										_this.turtleParameters.push(baseLength2);
									} else {
										var nx4 = _this.x + baseLength2 * Math.cos(_this.rotation);
										var ny4 = _this.y + baseLength2 * Math.sin(_this.rotation);
										if(_this.penIsDown) {
											_this.lastDistance = baseLength2;
											_this.lineTo(nx4,ny4);
										} else {
											if(_this.endLine == 2 || _this.endLine == 3) {
												_this.contour.end(_this.width);
											}
											_this.x = nx4;
											_this.y = ny4;
											var l10 = _this.points.length;
											_this.points[l10] = [];
											_this.points[l10][0] = nx4;
											_this.points[l10][1] = ny4;
											_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
											_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
											_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d6 = _this.dim[_this.dim.length - 1];
											if(nx4 < d6.minX) {
												d6.minX = nx4;
											}
											if(nx4 > d6.maxX) {
												d6.maxX = nx4;
											}
											if(ny4 < d6.minY) {
												d6.minY = ny4;
											}
											if(ny4 > d6.maxY) {
												d6.maxY = ny4;
											}
											_this.contour.reset();
										}
									}
									_this.turtleHistoryOn = wasHistoryOn3;
									if(_this.fill) {
										arr3.push(_this.x);
										arr3.push(_this.y);
									}
								}
								if(_this.fill) {
									var cx3 = (ox3 + arr3[arr3.length - 2]) / 2;
									var cy3 = (oy3 + arr3[arr3.length - 1]) / 2;
									var l11 = arr3.length;
									var i7 = 2;
									var lx2 = 0.;
									var ly2 = 0.;
									while(i7 < l11) {
										if(i7 > 2) {
											_this.pen.triangle2DFill(lx2,ly2,arr3[i7],arr3[i7 + 1],cx3,cy3);
										}
										lx2 = arr3[i7];
										ly2 = arr3[i7 + 1];
										i7 += 2;
									}
								}
								arr3.length = 0;
							}
						}
						++j;
						break;
					case "CIRCLE_SIDES":
						var radius4 = v[j];
						var sides1 = v[j + 1];
						if(sides1 == null) {
							sides1 = 24;
						}
						if(_this.turtleHistoryOn) {
							if(sides1 == 24) {
								_this.historyAdd("CIRCLE");
								_this.historyParameters.push(radius4);
							} else {
								_this.historyAdd("CIRCLE_SIDES");
								_this.historyParameters.push(radius4);
								_this.historyParameters.push(sides1);
							}
						}
						if(radius4 != 0) {
							if(_this.repeatCommands) {
								if(sides1 == 24) {
									_this.turtleCommands.push("CIRCLE");
									_this.turtleParameters.push(radius4);
								} else {
									_this.turtleCommands.push("CIRCLE_SIDES");
									_this.turtleParameters.push(radius4);
									_this.turtleParameters.push(sides1);
								}
							} else {
								var beta3 = 2 * Math.PI / sides1;
								var alpha3 = (Math.PI - beta3) / 2;
								var rotate3 = -(Math.PI / 2 - alpha3);
								var baseLength3 = 0.5 * radius4 * Math.sin(beta3 / 2);
								var ox4 = _this.x;
								var oy4 = _this.y;
								var arr4 = [];
								var _g7 = 0;
								while(_g7 < 48) {
									var i8 = _g7++;
									_this.rotation += rotate3;
									var wasHistoryOn4 = _this.turtleHistoryOn;
									_this.turtleHistoryOn = false;
									if(_this.turtleHistoryOn) {
										_this.historyAdd("FORWARD");
										_this.historyParameters.push(baseLength3);
									}
									if(_this.repeatCommands) {
										_this.turtleCommands.push("FORWARD");
										_this.turtleParameters.push(baseLength3);
									} else {
										var nx5 = _this.x + baseLength3 * Math.cos(_this.rotation);
										var ny5 = _this.y + baseLength3 * Math.sin(_this.rotation);
										if(_this.penIsDown) {
											_this.lastDistance = baseLength3;
											_this.lineTo(nx5,ny5);
										} else {
											if(_this.endLine == 2 || _this.endLine == 3) {
												_this.contour.end(_this.width);
											}
											_this.x = nx5;
											_this.y = ny5;
											var l12 = _this.points.length;
											_this.points[l12] = [];
											_this.points[l12][0] = nx5;
											_this.points[l12][1] = ny5;
											_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
											_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
											_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d7 = _this.dim[_this.dim.length - 1];
											if(nx5 < d7.minX) {
												d7.minX = nx5;
											}
											if(nx5 > d7.maxX) {
												d7.maxX = nx5;
											}
											if(ny5 < d7.minY) {
												d7.minY = ny5;
											}
											if(ny5 > d7.maxY) {
												d7.maxY = ny5;
											}
											_this.contour.reset();
										}
									}
									_this.turtleHistoryOn = wasHistoryOn4;
									if(_this.fill) {
										arr4.push(_this.x);
										arr4.push(_this.y);
									}
								}
								if(_this.fill) {
									var cx4 = (ox4 + arr4[arr4.length - 2]) / 2;
									var cy4 = (oy4 + arr4[arr4.length - 1]) / 2;
									var l13 = arr4.length;
									var i9 = 2;
									var lx3 = 0.;
									var ly3 = 0.;
									while(i9 < l13) {
										if(i9 > 2) {
											_this.pen.triangle2DFill(lx3,ly3,arr4[i9],arr4[i9 + 1],cx4,cy4);
										}
										lx3 = arr4[i9];
										ly3 = arr4[i9 + 1];
										i9 += 2;
									}
								}
								arr4.length = 0;
							}
						}
						j += 2;
						break;
					case "CYAN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("CYAN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("CYAN");
						} else {
							_this.pen.currentColor = -16711681;
						}
						break;
					case "DARKISH_BLUE":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("DARKISH_BLUE");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("DARKISH_BLUE");
						} else {
							_this.pen.currentColor = -8864837;
						}
						break;
					case "DARK_GREEN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("DARK_GREEN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("DARK_GREEN");
						} else {
							_this.pen.currentColor = -10182080;
						}
						break;
					case "EAST":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("WEST");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("EAST");
						} else {
							_this.rotation = Math.PI;
						}
						break;
					case "END_REPEAT":
						break;
					case "FILL_OFF":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FILL_OFF");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FILL_OFF");
						} else {
							_this.fill = false;
						}
						break;
					case "FILL_ON":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FILL_ON");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FILL_ON");
						} else {
							_this.fill = true;
						}
						break;
					case "FORWARD":
						var distance3 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD");
							_this.historyParameters.push(distance3);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD");
							_this.turtleParameters.push(distance3);
						} else {
							var nx6 = _this.x + distance3 * Math.cos(_this.rotation);
							var ny6 = _this.y + distance3 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance3;
								_this.lineTo(nx6,ny6);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx6;
								_this.y = ny6;
								var l14 = _this.points.length;
								_this.points[l14] = [];
								_this.points[l14][0] = nx6;
								_this.points[l14][1] = ny6;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d8 = _this.dim[_this.dim.length - 1];
								if(nx6 < d8.minX) {
									d8.minX = nx6;
								}
								if(nx6 > d8.maxX) {
									d8.maxX = nx6;
								}
								if(ny6 < d8.minY) {
									d8.minY = ny6;
								}
								if(ny6 > d8.maxY) {
									d8.maxY = ny6;
								}
								_this.contour.reset();
							}
						}
						++j;
						break;
					case "FORWARD_CHANGE":
						var deltaDistance = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD_CHANGE");
							_this.historyParameters.push(deltaDistance);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD_CHANGE");
							_this.turtleParameters.push(deltaDistance);
						} else {
							var distance4 = _this.lastDistance + deltaDistance;
							var nx7 = _this.x + distance4 * Math.cos(_this.rotation);
							var ny7 = _this.y + distance4 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance4 + deltaDistance;
								_this.lineTo(nx7,ny7);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx7;
								_this.y = ny7;
								var l15 = _this.points.length;
								_this.points[l15] = [];
								_this.points[l15][0] = nx7;
								_this.points[l15][1] = ny7;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d9 = _this.dim[_this.dim.length - 1];
								if(nx7 < d9.minX) {
									d9.minX = nx7;
								}
								if(nx7 > d9.maxX) {
									d9.maxX = nx7;
								}
								if(ny7 < d9.minY) {
									d9.minY = ny7;
								}
								if(ny7 > d9.maxY) {
									d9.maxY = ny7;
								}
								_this.contour.reset();
							}
						}
						++j;
						break;
					case "FORWARD_FACTOR":
						var factor = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD_FACTOR");
							_this.historyParameters.push(factor);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD_FACTOR");
							_this.turtleParameters.push(factor);
						} else {
							var distance5 = _this.lastDistance * factor;
							var nx8 = _this.x + distance5 * Math.cos(_this.rotation);
							var ny8 = _this.y + distance5 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance5;
								_this.lineTo(nx8,ny8);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx8;
								_this.y = ny8;
								var l16 = _this.points.length;
								_this.points[l16] = [];
								_this.points[l16][0] = nx8;
								_this.points[l16][1] = ny8;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d10 = _this.dim[_this.dim.length - 1];
								if(nx8 < d10.minX) {
									d10.minX = nx8;
								}
								if(nx8 > d10.maxX) {
									d10.maxX = nx8;
								}
								if(ny8 < d10.minY) {
									d10.minY = ny8;
								}
								if(ny8 > d10.maxY) {
									d10.maxY = ny8;
								}
								_this.contour.reset();
							}
						}
						++j;
						break;
					case "GREEN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("GREEN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("GREEN");
						} else {
							_this.pen.currentColor = -16711936;
						}
						break;
					case "GREY":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("GREY");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("GREY");
						} else {
							_this.pen.currentColor = -4737097;
						}
						break;
					case "LEFT":
						var degrees2 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("LEFT");
							_this.historyParameters.push(degrees2);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("LEFT");
							_this.turtleParameters.push(degrees2);
						} else {
							_this.rotation -= degrees2 * Math.PI / 180;
						}
						++j;
						break;
					case "LIGHT_BROWN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("LIGHT_BROWN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("LIGHT_BROWN");
						} else {
							_this.pen.currentColor = -3831790;
						}
						break;
					case "MAGENTA":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("MAGENTA");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("MAGENTA");
						} else {
							_this.pen.currentColor = -65281;
						}
						break;
					case "MOVE_PEN":
						var distance6 = v[j];
						if(_this.repeatCommands) {
							_this.turtleCommands.push("MOVE_PEN");
							_this.turtleParameters.push(distance6);
						} else if(_this.penIsDown) {
							if(_this.turtleHistoryOn) {
								_this.historyAdd("PEN_UP");
							}
							if(_this.repeatCommands) {
								_this.turtleCommands.push("PEN_UP");
							} else {
								_this.penIsDown = false;
							}
							if(_this.turtleHistoryOn) {
								_this.historyAdd("FORWARD");
								_this.historyParameters.push(distance6);
							}
							if(_this.repeatCommands) {
								_this.turtleCommands.push("FORWARD");
								_this.turtleParameters.push(distance6);
							} else {
								var nx9 = _this.x + distance6 * Math.cos(_this.rotation);
								var ny9 = _this.y + distance6 * Math.sin(_this.rotation);
								if(_this.penIsDown) {
									_this.lastDistance = distance6;
									_this.lineTo(nx9,ny9);
								} else {
									if(_this.endLine == 2 || _this.endLine == 3) {
										_this.contour.end(_this.width);
									}
									_this.x = nx9;
									_this.y = ny9;
									var l17 = _this.points.length;
									_this.points[l17] = [];
									_this.points[l17][0] = nx9;
									_this.points[l17][1] = ny9;
									_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
									_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
									_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d11 = _this.dim[_this.dim.length - 1];
									if(nx9 < d11.minX) {
										d11.minX = nx9;
									}
									if(nx9 > d11.maxX) {
										d11.maxX = nx9;
									}
									if(ny9 < d11.minY) {
										d11.minY = ny9;
									}
									if(ny9 > d11.maxY) {
										d11.maxY = ny9;
									}
									_this.contour.reset();
								}
							}
							if(_this.turtleHistoryOn) {
								_this.historyAdd("PEN_DOWN");
							}
							if(_this.repeatCommands) {
								_this.turtleCommands.push("PEN_DOWN");
							} else {
								_this.penIsDown = true;
							}
						} else {
							if(_this.turtleHistoryOn) {
								_this.historyAdd("FORWARD");
								_this.historyParameters.push(distance6);
							}
							if(_this.repeatCommands) {
								_this.turtleCommands.push("FORWARD");
								_this.turtleParameters.push(distance6);
							} else {
								var nx10 = _this.x + distance6 * Math.cos(_this.rotation);
								var ny10 = _this.y + distance6 * Math.sin(_this.rotation);
								if(_this.penIsDown) {
									_this.lastDistance = distance6;
									_this.lineTo(nx10,ny10);
								} else {
									if(_this.endLine == 2 || _this.endLine == 3) {
										_this.contour.end(_this.width);
									}
									_this.x = nx10;
									_this.y = ny10;
									var l18 = _this.points.length;
									_this.points[l18] = [];
									_this.points[l18][0] = nx10;
									_this.points[l18][1] = ny10;
									_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
									_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
									_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d12 = _this.dim[_this.dim.length - 1];
									if(nx10 < d12.minX) {
										d12.minX = nx10;
									}
									if(nx10 > d12.maxX) {
										d12.maxX = nx10;
									}
									if(ny10 < d12.minY) {
										d12.minY = ny10;
									}
									if(ny10 > d12.maxY) {
										d12.maxY = ny10;
									}
									_this.contour.reset();
								}
							}
						}
						++j;
						break;
					case "NORTH":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("NORTH");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("NORTH");
						} else {
							_this.rotation = -Math.PI / 2;
						}
						break;
					case "ORANGE":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("ORANGE");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("ORANGE");
						} else {
							_this.pen.currentColor = -23808;
						}
						break;
					case "PEN_COLOR":
						var r = v[j];
						var g = v[j + 1];
						var b = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR");
							_this.historyParameters.push(r);
							_this.historyParameters.push(g);
							_this.historyParameters.push(b);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR");
							_this.turtleParameters.push(r);
							_this.turtleParameters.push(g);
							_this.turtleParameters.push(b);
						} else {
							_this.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_B":
						var r1 = v[j];
						var g1 = v[j + 1];
						var b1 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_B");
							_this.historyParameters.push(r1);
							_this.historyParameters.push(g1);
							_this.historyParameters.push(b1);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_B");
							_this.turtleParameters.push(r1);
							_this.turtleParameters.push(g1);
							_this.turtleParameters.push(b1);
						} else {
							_this.pen.colorB = Math.round(255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_C":
						var r2 = v[j];
						var g2 = v[j + 1];
						var b2 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_C");
							_this.historyParameters.push(r2);
							_this.historyParameters.push(g2);
							_this.historyParameters.push(b2);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_C");
							_this.turtleParameters.push(r2);
							_this.turtleParameters.push(g2);
							_this.turtleParameters.push(b2);
						} else {
							_this.pen.colorC = Math.round(255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE":
						var r3 = v[j];
						var g3 = v[j + 1];
						var b3 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_CHANGE");
							_this.historyParameters.push(r3);
							_this.historyParameters.push(g3);
							_this.historyParameters.push(b3);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_CHANGE");
							_this.turtleParameters.push(r3);
							_this.turtleParameters.push(g3);
							_this.turtleParameters.push(b3);
						} else {
							var c = _this.pen.currentColor;
							var r0 = (c >> 16 & 255) / 255;
							var g0 = (c >> 8 & 255) / 255;
							var b0 = (c & 255) / 255;
							_this.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r3) * 255) << 16 | Math.round((g0 + g3) * 255) << 8 | Math.round((b0 + b3) * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE_B":
						var r4 = v[j];
						var g4 = v[j + 1];
						var b4 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_CHANGE_B");
							_this.historyParameters.push(r4);
							_this.historyParameters.push(g4);
							_this.historyParameters.push(b4);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_CHANGE_B");
							_this.turtleParameters.push(r4);
							_this.turtleParameters.push(g4);
							_this.turtleParameters.push(b4);
						} else {
							var c1 = _this.pen.colorB;
							var r01 = (c1 >> 16 & 255) / 255;
							var g01 = (c1 >> 8 & 255) / 255;
							var b01 = (c1 & 255) / 255;
							_this.pen.colorB = Math.round(255) << 24 | Math.round((r01 + r4) * 255) << 16 | Math.round((g01 + g4) * 255) << 8 | Math.round((b01 + b4) * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE_C":
						var r5 = v[j];
						var g5 = v[j + 1];
						var b5 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_CHANGE_C");
							_this.historyParameters.push(r5);
							_this.historyParameters.push(g5);
							_this.historyParameters.push(b5);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_CHANGE_C");
							_this.turtleParameters.push(r5);
							_this.turtleParameters.push(g5);
							_this.turtleParameters.push(b5);
						} else {
							var c2 = _this.pen.colorC;
							var r02 = (c2 >> 16 & 255) / 255;
							var g02 = (c2 >> 8 & 255) / 255;
							var b02 = (c2 & 255) / 255;
							_this.pen.colorC = Math.round(255) << 24 | Math.round((r02 + r5) * 255) << 16 | Math.round((g02 + g5) * 255) << 8 | Math.round((b02 + b5) * 255);
						}
						j += 3;
						break;
					case "PEN_DOWN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_DOWN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_DOWN");
						} else {
							_this.penIsDown = true;
						}
						break;
					case "PEN_SIZE":
						var w = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_SIZE");
							_this.historyParameters.push(w);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_SIZE");
							_this.turtleParameters.push(w);
						} else {
							_this.width = w;
						}
						++j;
						break;
					case "PEN_SIZE_CHANGE":
						var dw = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_SIZE_CHANGE");
							_this.historyParameters.push(dw);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_SIZE_CHANGE");
							_this.turtleParameters.push(dw);
						} else {
							_this.width += dw;
						}
						++j;
						break;
					case "PEN_SIZE_FACTOR":
						var factor1 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_SIZE_FACTOR");
							_this.historyParameters.push(factor1);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_SIZE_FACTOR");
							_this.turtleParameters.push(factor1);
						} else {
							_this.width *= factor1;
						}
						++j;
						break;
					case "PEN_UP":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_UP");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_UP");
						} else {
							_this.penIsDown = false;
						}
						break;
					case "PLUM":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PLUM");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PLUM");
						} else {
							_this.pen.currentColor = -7310896;
						}
						break;
					case "RED":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("RED");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("RED");
						} else {
							_this.pen.currentColor = -65536;
						}
						break;
					case "RIGHT":
						var degrees3 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("RIGHT");
							_this.historyParameters.push(degrees3);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("RIGHT");
							_this.turtleParameters.push(degrees3);
						} else {
							_this.rotation += degrees3 * Math.PI / 180;
						}
						++j;
						break;
					case "SET_ANGLE":
						var degrees4 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("SET_ANGLE");
							_this.historyParameters.push(degrees4);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("SET_ANGLE");
							_this.turtleParameters.push(degrees4);
						} else {
							_this.rotation = -Math.PI / 2;
							_this.rotation += degrees4 * Math.PI / 180;
						}
						++j;
						break;
					case "SET_POSITION":
						var x2 = v[j];
						var y2 = v[j + 1];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("SET_POSITION");
							_this.historyParameters.push(x2);
							_this.historyParameters.push(y2);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("SET_POSITION");
							_this.turtleParameters.push(x2);
							_this.turtleParameters.push(y2);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = x2;
							_this.y = y2;
							var l19 = _this.points.length;
							_this.points[l19] = [];
							_this.points[l19][0] = x2;
							_this.points[l19][1] = y2;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d13 = _this.dim[_this.dim.length - 1];
							if(x2 < d13.minX) {
								d13.minX = x2;
							}
							if(x2 > d13.maxX) {
								d13.maxX = x2;
							}
							if(y2 < d13.minY) {
								d13.minY = y2;
							}
							if(y2 > d13.maxY) {
								d13.maxY = y2;
							}
							_this.contour.reset();
						}
						j += 2;
						break;
					case "SOUTH":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("SOUTH");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("SOUTH");
						} else {
							_this.rotation = Math.PI / 2;
						}
						break;
					case "TAN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("TAN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("TAN");
						} else {
							_this.pen.currentColor = -27273;
						}
						break;
					case "TRIANGLE_ARCH":
						var distance7 = v[j];
						var distance21 = v[j + 1];
						var radius5 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("TRIANGLE_ARCH");
							_this.historyParameters.push(distance7);
							_this.historyParameters.push(distance21);
							_this.historyParameters.push(radius5);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("TRIANGLE_ARCH");
							_this.turtleParameters.push(distance7);
							_this.turtleParameters.push(distance21);
							_this.turtleParameters.push(radius5);
						} else {
							var nx11 = _this.x + distance7 * Math.cos(_this.rotation);
							var ny11 = _this.y + distance7 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								var thruX1 = _this.x + distance21 * Math.cos(_this.rotation) - radius5 * Math.cos(_this.rotation + Math.PI / 2);
								var thruY1 = _this.y + distance21 * Math.sin(_this.rotation) - radius5 * Math.sin(_this.rotation + Math.PI / 2);
								if(_this.fill) {
									_this.pen.triangle2DFill(_this.x,_this.y,thruX1,thruY1,nx11,ny11);
								}
								_this.lineTo(thruX1,thruY1);
								_this.lineTo(nx11,ny11);
								if(_this.fill) {
									_this.lineTo(_this.x,_this.y);
								}
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx11;
								_this.y = ny11;
								var l20 = _this.points.length;
								_this.points[l20] = [];
								_this.points[l20][0] = nx11;
								_this.points[l20][1] = ny11;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d14 = _this.dim[_this.dim.length - 1];
								if(nx11 < d14.minX) {
									d14.minX = nx11;
								}
								if(nx11 > d14.maxX) {
									d14.maxX = nx11;
								}
								if(ny11 < d14.minY) {
									d14.minY = ny11;
								}
								if(ny11 > d14.maxY) {
									d14.maxY = ny11;
								}
								_this.contour.reset();
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx11;
								_this.y = ny11;
								var l21 = _this.points.length;
								_this.points[l21] = [];
								_this.points[l21][0] = nx11;
								_this.points[l21][1] = ny11;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d15 = _this.dim[_this.dim.length - 1];
								if(nx11 < d15.minX) {
									d15.minX = nx11;
								}
								if(nx11 > d15.maxX) {
									d15.maxX = nx11;
								}
								if(ny11 < d15.minY) {
									d15.minY = ny11;
								}
								if(ny11 > d15.maxY) {
									d15.maxY = ny11;
								}
								_this.contour.reset();
							}
						}
						j += 3;
						break;
					case "WEST":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("WEST");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("WEST");
						} else {
							_this.rotation = 0;
						}
						break;
					case "WHITE":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("WHITE");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("WHITE");
						} else {
							_this.pen.currentColor = -1;
						}
						break;
					case "YELLOW":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("YELLOW");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("YELLOW");
						} else {
							_this.pen.currentColor = -256;
						}
						break;
					}
				}
				j = 0;
			}
			_this.turtleHistoryOn = wasHistoryOn;
			_this.turtleCommands.length = 0;
			_this.turtleParameters.length = 0;
		}
		_this.repeatCount = Math.round(8);
		_this.repeatCommands = true;
		_this.turtleCommands.length = 0;
		_this.turtleParameters.length = 0;
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("ARCH_BEZIER");
			_this1.historyParameters.push(300);
			_this1.historyParameters.push(150);
			_this1.historyParameters.push(30);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("ARCH_BEZIER");
			_this1.turtleParameters.push(300);
			_this1.turtleParameters.push(150);
			_this1.turtleParameters.push(30);
		} else {
			var nx = _this1.x + 300 * Math.cos(_this1.rotation);
			var ny = _this1.y + 300 * Math.sin(_this1.rotation);
			if(_this1.penIsDown) {
				var thruX = _this1.x + 150 * Math.cos(_this1.rotation) - 30 * Math.cos(_this1.rotation + Math.PI / 2);
				var thruY = _this1.y + 150 * Math.sin(_this1.rotation) - 30 * Math.sin(_this1.rotation + Math.PI / 2);
				var newx = 2 * thruX - 0.5 * (_this1.x + nx);
				var newy = 2 * thruY - 0.5 * (_this1.y + ny);
				_this1.tempArr = [];
				var p = _this1.tempArr;
				var ax = _this1.x;
				var ay = _this1.y;
				var x = ax - newx;
				var y = ay - newy;
				var x1 = newx - nx;
				var y1 = newy - ny;
				var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
				if(approxDistance == 0) {
					approxDistance = 0.000001;
				}
				var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
				var l = p.length;
				p[l++] = ax;
				p[l++] = ay;
				var t = step;
				while(t < 1.) {
					var u = 1 - t;
					p[l++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx;
					var u1 = 1 - t;
					p[l++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny;
					t += step;
				}
				p[l++] = nx;
				p[l++] = ny;
				var arr = _this1.tempArr;
				var withMove = false;
				if(withMove == null) {
					withMove = true;
				}
				var l = arr.length;
				var i = 2;
				if(withMove) {
					var x_ = arr[0];
					var y_ = arr[1];
					if(_this1.endLine == 2 || _this1.endLine == 3) {
						_this1.contour.end(_this1.width);
					}
					_this1.x = x_;
					_this1.y = y_;
					var l1 = _this1.points.length;
					_this1.points[l1] = [];
					_this1.points[l1][0] = x_;
					_this1.points[l1][1] = y_;
					_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
					_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
					_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
					var d = _this1.dim[_this1.dim.length - 1];
					if(x_ < d.minX) {
						d.minX = x_;
					}
					if(x_ > d.maxX) {
						d.maxX = x_;
					}
					if(y_ < d.minY) {
						d.minY = y_;
					}
					if(y_ > d.maxY) {
						d.maxY = y_;
					}
					_this1.contour.reset();
				} else {
					_this1.lineTo(arr[0],arr[1]);
				}
				var cx = (arr[0] + arr[l - 2]) / 2;
				var cy = (arr[1] + arr[l - 1]) / 2;
				var ox = _this1.x;
				var oy = _this1.y;
				while(i < l) {
					if(_this1.fill && _this1.penIsDown) {
						if(i > 0 && i < l - 2) {
							_this1.pen.triangle2DFill(arr[i - 2],arr[i - 1],arr[i],arr[i + 1],cx,cy);
						}
					}
					_this1.lineTo(arr[i],arr[i + 1]);
					i += 2;
				}
				if(_this1.fill && _this1.penIsDown) {
					if(_this1.endLine == 2 || _this1.endLine == 3) {
						_this1.contour.end(_this1.width);
					}
					_this1.x = ox;
					_this1.y = oy;
					var l1 = _this1.points.length;
					_this1.points[l1] = [];
					_this1.points[l1][0] = ox;
					_this1.points[l1][1] = oy;
					_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
					_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
					_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
					var d = _this1.dim[_this1.dim.length - 1];
					if(ox < d.minX) {
						d.minX = ox;
					}
					if(ox > d.maxX) {
						d.maxX = ox;
					}
					if(oy < d.minY) {
						d.minY = oy;
					}
					if(oy > d.maxY) {
						d.maxY = oy;
					}
					_this1.contour.reset();
					_this1.lineTo(arr[l - 2],arr[l - 1]);
				}
				_this1.x = nx;
				_this1.y = ny;
			} else {
				if(_this1.endLine == 2 || _this1.endLine == 3) {
					_this1.contour.end(_this1.width);
				}
				_this1.x = nx;
				_this1.y = ny;
				var l = _this1.points.length;
				_this1.points[l] = [];
				_this1.points[l][0] = nx;
				_this1.points[l][1] = ny;
				_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
				_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
				_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this1.dim[_this1.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this1.contour.reset();
			}
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("RIGHT");
			_this.historyParameters.push(154.285714285714278);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("RIGHT");
			_this.turtleParameters.push(154.285714285714278);
		} else {
			_this.rotation += 154.285714285714278 * Math.PI / 180;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("PEN_COLOR_CHANGE");
			_this1.historyParameters.push(0.09);
			_this1.historyParameters.push(0.1);
			_this1.historyParameters.push(-0.09);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("PEN_COLOR_CHANGE");
			_this1.turtleParameters.push(0.09);
			_this1.turtleParameters.push(0.1);
			_this1.turtleParameters.push(-0.09);
		} else {
			var c = _this1.pen.currentColor;
			var r0 = (c >> 16 & 255) / 255;
			var g0 = (c >> 8 & 255) / 255;
			var b0 = (c & 255) / 255;
			_this1.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + 0.09) * 255) << 16 | Math.round((g0 + 0.1) * 255) << 8 | Math.round((b0 + (-0.09)) * 255);
		}
		var _this = _this1;
		_this.repeatCommands = false;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("END_REPEAT");
		}
		var wasHistoryOn = _this.turtleHistoryOn;
		_this.turtleHistoryOn = false;
		var v = _this.turtleParameters;
		var j = 0;
		var _g = 0;
		var _g1 = _this.repeatCount;
		while(_g < _g1) {
			var k = _g++;
			var _g2 = 0;
			var _g3 = _this.turtleCommands.length;
			while(_g2 < _g3) {
				var i = _g2++;
				var command = _this.turtleCommands[i];
				switch(command) {
				case "ARC":
					var radius = v[j];
					var degrees = v[j + 1];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("ARC");
						_this.historyParameters.push(radius);
						_this.historyParameters.push(degrees);
					}
					if(radius != 0) {
						if(_this.repeatCommands) {
							_this.turtleCommands.push("ARC");
							_this.turtleParameters.push(radius);
							_this.turtleParameters.push(degrees);
						} else {
							var beta = degrees * Math.PI / 180 / 24;
							var alpha = (Math.PI - beta) / 2;
							var rotate = -(Math.PI / 2 - alpha);
							var baseLength = 0.5 * radius * Math.sin(beta / 2);
							var ox = _this.x;
							var oy = _this.y;
							var arr = [];
							arr.push(_this.x);
							arr.push(_this.y);
							var _g4 = 0;
							while(_g4 < 48) {
								var i1 = _g4++;
								_this.rotation += rotate;
								var wasHistoryOn1 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength);
								} else {
									var nx = _this.x + baseLength * Math.cos(_this.rotation);
									var ny = _this.y + baseLength * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength;
										_this.lineTo(nx,ny);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx;
										_this.y = ny;
										var l = _this.points.length;
										_this.points[l] = [];
										_this.points[l][0] = nx;
										_this.points[l][1] = ny;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d = _this.dim[_this.dim.length - 1];
										if(nx < d.minX) {
											d.minX = nx;
										}
										if(nx > d.maxX) {
											d.maxX = nx;
										}
										if(ny < d.minY) {
											d.minY = ny;
										}
										if(ny > d.maxY) {
											d.maxY = ny;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn1;
								if(_this.fill) {
									arr.push(_this.x);
									arr.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx = (ox + arr[arr.length - 2]) / 2;
								var cy = (oy + arr[arr.length - 1]) / 2;
								var l1 = arr.length;
								var i2 = 2;
								var lx = 0.;
								var ly = 0.;
								_this.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
								while(i2 < l1) {
									if(i2 > 2) {
										_this.pen.triangle2DFill(lx,ly,arr[i2],arr[i2 + 1],cx,cy);
									}
									lx = arr[i2];
									ly = arr[i2 + 1];
									i2 += 2;
								}
							}
							arr.length = 0;
						}
					}
					j += 2;
					break;
				case "ARCH_BEZIER":
					var distance = v[j];
					var distance2 = v[j + 1];
					var radius1 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("ARCH_BEZIER");
						_this.historyParameters.push(distance);
						_this.historyParameters.push(distance2);
						_this.historyParameters.push(radius1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("ARCH_BEZIER");
						_this.turtleParameters.push(distance);
						_this.turtleParameters.push(distance2);
						_this.turtleParameters.push(radius1);
					} else {
						var nx1 = _this.x + distance * Math.cos(_this.rotation);
						var ny1 = _this.y + distance * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							var thruX = _this.x + distance2 * Math.cos(_this.rotation) - radius1 * Math.cos(_this.rotation + Math.PI / 2);
							var thruY = _this.y + distance2 * Math.sin(_this.rotation) - radius1 * Math.sin(_this.rotation + Math.PI / 2);
							var newx = 2 * thruX - 0.5 * (_this.x + nx1);
							var newy = 2 * thruY - 0.5 * (_this.y + ny1);
							_this.tempArr = [];
							var p = _this.tempArr;
							var ax = _this.x;
							var ay = _this.y;
							var x = ax - newx;
							var y = ay - newy;
							var x1 = newx - nx1;
							var y1 = newy - ny1;
							var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
							if(approxDistance == 0) {
								approxDistance = 0.000001;
							}
							var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
							var l2 = p.length;
							p[l2++] = ax;
							p[l2++] = ay;
							var t = step;
							while(t < 1.) {
								var u = 1 - t;
								p[l2++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx1;
								var u1 = 1 - t;
								p[l2++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny1;
								t += step;
							}
							p[l2++] = nx1;
							p[l2++] = ny1;
							var arr1 = _this.tempArr;
							var withMove = false;
							if(withMove == null) {
								withMove = true;
							}
							var l3 = arr1.length;
							var i3 = 2;
							if(withMove) {
								var x_ = arr1[0];
								var y_ = arr1[1];
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = x_;
								_this.y = y_;
								var l4 = _this.points.length;
								_this.points[l4] = [];
								_this.points[l4][0] = x_;
								_this.points[l4][1] = y_;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d1 = _this.dim[_this.dim.length - 1];
								if(x_ < d1.minX) {
									d1.minX = x_;
								}
								if(x_ > d1.maxX) {
									d1.maxX = x_;
								}
								if(y_ < d1.minY) {
									d1.minY = y_;
								}
								if(y_ > d1.maxY) {
									d1.maxY = y_;
								}
								_this.contour.reset();
							} else {
								_this.lineTo(arr1[0],arr1[1]);
							}
							var cx1 = (arr1[0] + arr1[l3 - 2]) / 2;
							var cy1 = (arr1[1] + arr1[l3 - 1]) / 2;
							var ox1 = _this.x;
							var oy1 = _this.y;
							while(i3 < l3) {
								if(_this.fill && _this.penIsDown) {
									if(i3 > 0 && i3 < l3 - 2) {
										_this.pen.triangle2DFill(arr1[i3 - 2],arr1[i3 - 1],arr1[i3],arr1[i3 + 1],cx1,cy1);
									}
								}
								_this.lineTo(arr1[i3],arr1[i3 + 1]);
								i3 += 2;
							}
							if(_this.fill && _this.penIsDown) {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = ox1;
								_this.y = oy1;
								var l5 = _this.points.length;
								_this.points[l5] = [];
								_this.points[l5][0] = ox1;
								_this.points[l5][1] = oy1;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d2 = _this.dim[_this.dim.length - 1];
								if(ox1 < d2.minX) {
									d2.minX = ox1;
								}
								if(ox1 > d2.maxX) {
									d2.maxX = ox1;
								}
								if(oy1 < d2.minY) {
									d2.minY = oy1;
								}
								if(oy1 > d2.maxY) {
									d2.maxY = oy1;
								}
								_this.contour.reset();
								_this.lineTo(arr1[l3 - 2],arr1[l3 - 1]);
							}
							_this.x = nx1;
							_this.y = ny1;
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx1;
							_this.y = ny1;
							var l6 = _this.points.length;
							_this.points[l6] = [];
							_this.points[l6][0] = nx1;
							_this.points[l6][1] = ny1;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d3 = _this.dim[_this.dim.length - 1];
							if(nx1 < d3.minX) {
								d3.minX = nx1;
							}
							if(nx1 > d3.maxX) {
								d3.maxX = nx1;
							}
							if(ny1 < d3.minY) {
								d3.minY = ny1;
							}
							if(ny1 > d3.maxY) {
								d3.maxY = ny1;
							}
							_this.contour.reset();
						}
					}
					j += 3;
					break;
				case "ARC_SIDES":
					var radius2 = v[j];
					var degrees1 = v[j + 1];
					var sides = v[j + 2];
					if(sides == null) {
						sides = 24;
					}
					if(_this.turtleHistoryOn) {
						if(sides == 24) {
							_this.historyAdd("ARC");
							_this.historyParameters.push(radius2);
							_this.historyParameters.push(degrees1);
						} else {
							_this.historyAdd("ARC_SIDES");
							_this.historyParameters.push(radius2);
							_this.historyParameters.push(degrees1);
							_this.historyParameters.push(sides);
						}
					}
					if(radius2 != 0) {
						if(_this.repeatCommands) {
							if(sides == 24) {
								_this.turtleCommands.push("ARC");
								_this.turtleParameters.push(radius2);
								_this.turtleParameters.push(degrees1);
							} else {
								_this.turtleCommands.push("ARC_SIDES");
								_this.turtleParameters.push(radius2);
								_this.turtleParameters.push(degrees1);
								_this.turtleParameters.push(sides);
							}
						} else {
							var beta1 = degrees1 * Math.PI / 180 / sides;
							var alpha1 = (Math.PI - beta1) / 2;
							var rotate1 = -(Math.PI / 2 - alpha1);
							var baseLength1 = 0.5 * radius2 * Math.sin(beta1 / 2);
							var ox2 = _this.x;
							var oy2 = _this.y;
							var arr2 = [];
							arr2.push(_this.x);
							arr2.push(_this.y);
							var _g5 = 0;
							while(_g5 < 48) {
								var i4 = _g5++;
								_this.rotation += rotate1;
								var wasHistoryOn2 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength1);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength1);
								} else {
									var nx2 = _this.x + baseLength1 * Math.cos(_this.rotation);
									var ny2 = _this.y + baseLength1 * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength1;
										_this.lineTo(nx2,ny2);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx2;
										_this.y = ny2;
										var l7 = _this.points.length;
										_this.points[l7] = [];
										_this.points[l7][0] = nx2;
										_this.points[l7][1] = ny2;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d4 = _this.dim[_this.dim.length - 1];
										if(nx2 < d4.minX) {
											d4.minX = nx2;
										}
										if(nx2 > d4.maxX) {
											d4.maxX = nx2;
										}
										if(ny2 < d4.minY) {
											d4.minY = ny2;
										}
										if(ny2 > d4.maxY) {
											d4.maxY = ny2;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn2;
								if(_this.fill) {
									arr2.push(_this.x);
									arr2.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx2 = (ox2 + arr2[arr2.length - 2]) / 2;
								var cy2 = (oy2 + arr2[arr2.length - 1]) / 2;
								var l8 = arr2.length;
								var i5 = 2;
								var lx1 = 0.;
								var ly1 = 0.;
								_this.pen.triangle2DFill(ox2,oy2,arr2[0],arr2[1],cx2,cy2);
								while(i5 < l8) {
									if(i5 > 2) {
										_this.pen.triangle2DFill(lx1,ly1,arr2[i5],arr2[i5 + 1],cx2,cy2);
									}
									lx1 = arr2[i5];
									ly1 = arr2[i5 + 1];
									i5 += 2;
								}
							}
							arr2.length = 0;
						}
					}
					j += 3;
					break;
				case "BACKWARD":
					var distance1 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BACKWARD");
						_this.historyParameters.push(distance1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BACKWARD");
						_this.turtleParameters.push(distance1);
					} else {
						var nx3 = _this.x + distance1 * Math.cos(_this.rotation + Math.PI);
						var ny3 = _this.y + distance1 * Math.sin(_this.rotation + Math.PI);
						if(_this.penIsDown) {
							_this.lineTo(nx3,ny3);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx3;
							_this.y = ny3;
							var l9 = _this.points.length;
							_this.points[l9] = [];
							_this.points[l9][0] = nx3;
							_this.points[l9][1] = ny3;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d5 = _this.dim[_this.dim.length - 1];
							if(nx3 < d5.minX) {
								d5.minX = nx3;
							}
							if(nx3 > d5.maxX) {
								d5.maxX = nx3;
							}
							if(ny3 < d5.minY) {
								d5.minY = ny3;
							}
							if(ny3 > d5.maxY) {
								d5.maxY = ny3;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "BEGIN_REPEAT":
					break;
				case "BLACK":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BLACK");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BLACK");
					} else {
						_this.pen.currentColor = -16777216;
					}
					break;
				case "BLUE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BLUE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BLUE");
					} else {
						_this.pen.currentColor = -16776961;
					}
					break;
				case "BROWN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BROWN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BROWN");
					} else {
						_this.pen.currentColor = -6594501;
					}
					break;
				case "CIRCLE":
					var radius3 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("CIRCLE");
						_this.historyParameters.push(radius3);
					}
					if(radius3 != 0) {
						if(_this.repeatCommands) {
							_this.turtleCommands.push("CIRCLE");
							_this.turtleParameters.push(radius3);
						} else {
							var beta2 = 2 * Math.PI / 24;
							var alpha2 = (Math.PI - beta2) / 2;
							var rotate2 = -(Math.PI / 2 - alpha2);
							var baseLength2 = 0.5 * radius3 * Math.sin(beta2 / 2);
							var ox3 = _this.x;
							var oy3 = _this.y;
							var arr3 = [];
							var _g6 = 0;
							while(_g6 < 48) {
								var i6 = _g6++;
								_this.rotation += rotate2;
								var wasHistoryOn3 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength2);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength2);
								} else {
									var nx4 = _this.x + baseLength2 * Math.cos(_this.rotation);
									var ny4 = _this.y + baseLength2 * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength2;
										_this.lineTo(nx4,ny4);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx4;
										_this.y = ny4;
										var l10 = _this.points.length;
										_this.points[l10] = [];
										_this.points[l10][0] = nx4;
										_this.points[l10][1] = ny4;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d6 = _this.dim[_this.dim.length - 1];
										if(nx4 < d6.minX) {
											d6.minX = nx4;
										}
										if(nx4 > d6.maxX) {
											d6.maxX = nx4;
										}
										if(ny4 < d6.minY) {
											d6.minY = ny4;
										}
										if(ny4 > d6.maxY) {
											d6.maxY = ny4;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn3;
								if(_this.fill) {
									arr3.push(_this.x);
									arr3.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx3 = (ox3 + arr3[arr3.length - 2]) / 2;
								var cy3 = (oy3 + arr3[arr3.length - 1]) / 2;
								var l11 = arr3.length;
								var i7 = 2;
								var lx2 = 0.;
								var ly2 = 0.;
								while(i7 < l11) {
									if(i7 > 2) {
										_this.pen.triangle2DFill(lx2,ly2,arr3[i7],arr3[i7 + 1],cx3,cy3);
									}
									lx2 = arr3[i7];
									ly2 = arr3[i7 + 1];
									i7 += 2;
								}
							}
							arr3.length = 0;
						}
					}
					++j;
					break;
				case "CIRCLE_SIDES":
					var radius4 = v[j];
					var sides1 = v[j + 1];
					if(sides1 == null) {
						sides1 = 24;
					}
					if(_this.turtleHistoryOn) {
						if(sides1 == 24) {
							_this.historyAdd("CIRCLE");
							_this.historyParameters.push(radius4);
						} else {
							_this.historyAdd("CIRCLE_SIDES");
							_this.historyParameters.push(radius4);
							_this.historyParameters.push(sides1);
						}
					}
					if(radius4 != 0) {
						if(_this.repeatCommands) {
							if(sides1 == 24) {
								_this.turtleCommands.push("CIRCLE");
								_this.turtleParameters.push(radius4);
							} else {
								_this.turtleCommands.push("CIRCLE_SIDES");
								_this.turtleParameters.push(radius4);
								_this.turtleParameters.push(sides1);
							}
						} else {
							var beta3 = 2 * Math.PI / sides1;
							var alpha3 = (Math.PI - beta3) / 2;
							var rotate3 = -(Math.PI / 2 - alpha3);
							var baseLength3 = 0.5 * radius4 * Math.sin(beta3 / 2);
							var ox4 = _this.x;
							var oy4 = _this.y;
							var arr4 = [];
							var _g7 = 0;
							while(_g7 < 48) {
								var i8 = _g7++;
								_this.rotation += rotate3;
								var wasHistoryOn4 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength3);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength3);
								} else {
									var nx5 = _this.x + baseLength3 * Math.cos(_this.rotation);
									var ny5 = _this.y + baseLength3 * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength3;
										_this.lineTo(nx5,ny5);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx5;
										_this.y = ny5;
										var l12 = _this.points.length;
										_this.points[l12] = [];
										_this.points[l12][0] = nx5;
										_this.points[l12][1] = ny5;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d7 = _this.dim[_this.dim.length - 1];
										if(nx5 < d7.minX) {
											d7.minX = nx5;
										}
										if(nx5 > d7.maxX) {
											d7.maxX = nx5;
										}
										if(ny5 < d7.minY) {
											d7.minY = ny5;
										}
										if(ny5 > d7.maxY) {
											d7.maxY = ny5;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn4;
								if(_this.fill) {
									arr4.push(_this.x);
									arr4.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx4 = (ox4 + arr4[arr4.length - 2]) / 2;
								var cy4 = (oy4 + arr4[arr4.length - 1]) / 2;
								var l13 = arr4.length;
								var i9 = 2;
								var lx3 = 0.;
								var ly3 = 0.;
								while(i9 < l13) {
									if(i9 > 2) {
										_this.pen.triangle2DFill(lx3,ly3,arr4[i9],arr4[i9 + 1],cx4,cy4);
									}
									lx3 = arr4[i9];
									ly3 = arr4[i9 + 1];
									i9 += 2;
								}
							}
							arr4.length = 0;
						}
					}
					j += 2;
					break;
				case "CYAN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("CYAN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("CYAN");
					} else {
						_this.pen.currentColor = -16711681;
					}
					break;
				case "DARKISH_BLUE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("DARKISH_BLUE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("DARKISH_BLUE");
					} else {
						_this.pen.currentColor = -8864837;
					}
					break;
				case "DARK_GREEN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("DARK_GREEN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("DARK_GREEN");
					} else {
						_this.pen.currentColor = -10182080;
					}
					break;
				case "EAST":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("WEST");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("EAST");
					} else {
						_this.rotation = Math.PI;
					}
					break;
				case "END_REPEAT":
					break;
				case "FILL_OFF":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FILL_OFF");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FILL_OFF");
					} else {
						_this.fill = false;
					}
					break;
				case "FILL_ON":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FILL_ON");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FILL_ON");
					} else {
						_this.fill = true;
					}
					break;
				case "FORWARD":
					var distance3 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FORWARD");
						_this.historyParameters.push(distance3);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FORWARD");
						_this.turtleParameters.push(distance3);
					} else {
						var nx6 = _this.x + distance3 * Math.cos(_this.rotation);
						var ny6 = _this.y + distance3 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							_this.lastDistance = distance3;
							_this.lineTo(nx6,ny6);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx6;
							_this.y = ny6;
							var l14 = _this.points.length;
							_this.points[l14] = [];
							_this.points[l14][0] = nx6;
							_this.points[l14][1] = ny6;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d8 = _this.dim[_this.dim.length - 1];
							if(nx6 < d8.minX) {
								d8.minX = nx6;
							}
							if(nx6 > d8.maxX) {
								d8.maxX = nx6;
							}
							if(ny6 < d8.minY) {
								d8.minY = ny6;
							}
							if(ny6 > d8.maxY) {
								d8.maxY = ny6;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "FORWARD_CHANGE":
					var deltaDistance = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FORWARD_CHANGE");
						_this.historyParameters.push(deltaDistance);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FORWARD_CHANGE");
						_this.turtleParameters.push(deltaDistance);
					} else {
						var distance4 = _this.lastDistance + deltaDistance;
						var nx7 = _this.x + distance4 * Math.cos(_this.rotation);
						var ny7 = _this.y + distance4 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							_this.lastDistance = distance4 + deltaDistance;
							_this.lineTo(nx7,ny7);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx7;
							_this.y = ny7;
							var l15 = _this.points.length;
							_this.points[l15] = [];
							_this.points[l15][0] = nx7;
							_this.points[l15][1] = ny7;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d9 = _this.dim[_this.dim.length - 1];
							if(nx7 < d9.minX) {
								d9.minX = nx7;
							}
							if(nx7 > d9.maxX) {
								d9.maxX = nx7;
							}
							if(ny7 < d9.minY) {
								d9.minY = ny7;
							}
							if(ny7 > d9.maxY) {
								d9.maxY = ny7;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "FORWARD_FACTOR":
					var factor = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FORWARD_FACTOR");
						_this.historyParameters.push(factor);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FORWARD_FACTOR");
						_this.turtleParameters.push(factor);
					} else {
						var distance5 = _this.lastDistance * factor;
						var nx8 = _this.x + distance5 * Math.cos(_this.rotation);
						var ny8 = _this.y + distance5 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							_this.lastDistance = distance5;
							_this.lineTo(nx8,ny8);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx8;
							_this.y = ny8;
							var l16 = _this.points.length;
							_this.points[l16] = [];
							_this.points[l16][0] = nx8;
							_this.points[l16][1] = ny8;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d10 = _this.dim[_this.dim.length - 1];
							if(nx8 < d10.minX) {
								d10.minX = nx8;
							}
							if(nx8 > d10.maxX) {
								d10.maxX = nx8;
							}
							if(ny8 < d10.minY) {
								d10.minY = ny8;
							}
							if(ny8 > d10.maxY) {
								d10.maxY = ny8;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "GREEN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("GREEN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("GREEN");
					} else {
						_this.pen.currentColor = -16711936;
					}
					break;
				case "GREY":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("GREY");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("GREY");
					} else {
						_this.pen.currentColor = -4737097;
					}
					break;
				case "LEFT":
					var degrees2 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("LEFT");
						_this.historyParameters.push(degrees2);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("LEFT");
						_this.turtleParameters.push(degrees2);
					} else {
						_this.rotation -= degrees2 * Math.PI / 180;
					}
					++j;
					break;
				case "LIGHT_BROWN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("LIGHT_BROWN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("LIGHT_BROWN");
					} else {
						_this.pen.currentColor = -3831790;
					}
					break;
				case "MAGENTA":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("MAGENTA");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("MAGENTA");
					} else {
						_this.pen.currentColor = -65281;
					}
					break;
				case "MOVE_PEN":
					var distance6 = v[j];
					if(_this.repeatCommands) {
						_this.turtleCommands.push("MOVE_PEN");
						_this.turtleParameters.push(distance6);
					} else if(_this.penIsDown) {
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_UP");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_UP");
						} else {
							_this.penIsDown = false;
						}
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD");
							_this.historyParameters.push(distance6);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD");
							_this.turtleParameters.push(distance6);
						} else {
							var nx9 = _this.x + distance6 * Math.cos(_this.rotation);
							var ny9 = _this.y + distance6 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance6;
								_this.lineTo(nx9,ny9);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx9;
								_this.y = ny9;
								var l17 = _this.points.length;
								_this.points[l17] = [];
								_this.points[l17][0] = nx9;
								_this.points[l17][1] = ny9;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d11 = _this.dim[_this.dim.length - 1];
								if(nx9 < d11.minX) {
									d11.minX = nx9;
								}
								if(nx9 > d11.maxX) {
									d11.maxX = nx9;
								}
								if(ny9 < d11.minY) {
									d11.minY = ny9;
								}
								if(ny9 > d11.maxY) {
									d11.maxY = ny9;
								}
								_this.contour.reset();
							}
						}
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_DOWN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_DOWN");
						} else {
							_this.penIsDown = true;
						}
					} else {
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD");
							_this.historyParameters.push(distance6);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD");
							_this.turtleParameters.push(distance6);
						} else {
							var nx10 = _this.x + distance6 * Math.cos(_this.rotation);
							var ny10 = _this.y + distance6 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance6;
								_this.lineTo(nx10,ny10);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx10;
								_this.y = ny10;
								var l18 = _this.points.length;
								_this.points[l18] = [];
								_this.points[l18][0] = nx10;
								_this.points[l18][1] = ny10;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d12 = _this.dim[_this.dim.length - 1];
								if(nx10 < d12.minX) {
									d12.minX = nx10;
								}
								if(nx10 > d12.maxX) {
									d12.maxX = nx10;
								}
								if(ny10 < d12.minY) {
									d12.minY = ny10;
								}
								if(ny10 > d12.maxY) {
									d12.maxY = ny10;
								}
								_this.contour.reset();
							}
						}
					}
					++j;
					break;
				case "NORTH":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("NORTH");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("NORTH");
					} else {
						_this.rotation = -Math.PI / 2;
					}
					break;
				case "ORANGE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("ORANGE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("ORANGE");
					} else {
						_this.pen.currentColor = -23808;
					}
					break;
				case "PEN_COLOR":
					var r = v[j];
					var g = v[j + 1];
					var b = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR");
						_this.historyParameters.push(r);
						_this.historyParameters.push(g);
						_this.historyParameters.push(b);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR");
						_this.turtleParameters.push(r);
						_this.turtleParameters.push(g);
						_this.turtleParameters.push(b);
					} else {
						_this.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_B":
					var r1 = v[j];
					var g1 = v[j + 1];
					var b1 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_B");
						_this.historyParameters.push(r1);
						_this.historyParameters.push(g1);
						_this.historyParameters.push(b1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_B");
						_this.turtleParameters.push(r1);
						_this.turtleParameters.push(g1);
						_this.turtleParameters.push(b1);
					} else {
						_this.pen.colorB = Math.round(255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_C":
					var r2 = v[j];
					var g2 = v[j + 1];
					var b2 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_C");
						_this.historyParameters.push(r2);
						_this.historyParameters.push(g2);
						_this.historyParameters.push(b2);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_C");
						_this.turtleParameters.push(r2);
						_this.turtleParameters.push(g2);
						_this.turtleParameters.push(b2);
					} else {
						_this.pen.colorC = Math.round(255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE":
					var r3 = v[j];
					var g3 = v[j + 1];
					var b3 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_CHANGE");
						_this.historyParameters.push(r3);
						_this.historyParameters.push(g3);
						_this.historyParameters.push(b3);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_CHANGE");
						_this.turtleParameters.push(r3);
						_this.turtleParameters.push(g3);
						_this.turtleParameters.push(b3);
					} else {
						var c = _this.pen.currentColor;
						var r0 = (c >> 16 & 255) / 255;
						var g0 = (c >> 8 & 255) / 255;
						var b0 = (c & 255) / 255;
						_this.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r3) * 255) << 16 | Math.round((g0 + g3) * 255) << 8 | Math.round((b0 + b3) * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE_B":
					var r4 = v[j];
					var g4 = v[j + 1];
					var b4 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_CHANGE_B");
						_this.historyParameters.push(r4);
						_this.historyParameters.push(g4);
						_this.historyParameters.push(b4);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_CHANGE_B");
						_this.turtleParameters.push(r4);
						_this.turtleParameters.push(g4);
						_this.turtleParameters.push(b4);
					} else {
						var c1 = _this.pen.colorB;
						var r01 = (c1 >> 16 & 255) / 255;
						var g01 = (c1 >> 8 & 255) / 255;
						var b01 = (c1 & 255) / 255;
						_this.pen.colorB = Math.round(255) << 24 | Math.round((r01 + r4) * 255) << 16 | Math.round((g01 + g4) * 255) << 8 | Math.round((b01 + b4) * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE_C":
					var r5 = v[j];
					var g5 = v[j + 1];
					var b5 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_CHANGE_C");
						_this.historyParameters.push(r5);
						_this.historyParameters.push(g5);
						_this.historyParameters.push(b5);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_CHANGE_C");
						_this.turtleParameters.push(r5);
						_this.turtleParameters.push(g5);
						_this.turtleParameters.push(b5);
					} else {
						var c2 = _this.pen.colorC;
						var r02 = (c2 >> 16 & 255) / 255;
						var g02 = (c2 >> 8 & 255) / 255;
						var b02 = (c2 & 255) / 255;
						_this.pen.colorC = Math.round(255) << 24 | Math.round((r02 + r5) * 255) << 16 | Math.round((g02 + g5) * 255) << 8 | Math.round((b02 + b5) * 255);
					}
					j += 3;
					break;
				case "PEN_DOWN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_DOWN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_DOWN");
					} else {
						_this.penIsDown = true;
					}
					break;
				case "PEN_SIZE":
					var w = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_SIZE");
						_this.historyParameters.push(w);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_SIZE");
						_this.turtleParameters.push(w);
					} else {
						_this.width = w;
					}
					++j;
					break;
				case "PEN_SIZE_CHANGE":
					var dw = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_SIZE_CHANGE");
						_this.historyParameters.push(dw);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_SIZE_CHANGE");
						_this.turtleParameters.push(dw);
					} else {
						_this.width += dw;
					}
					++j;
					break;
				case "PEN_SIZE_FACTOR":
					var factor1 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_SIZE_FACTOR");
						_this.historyParameters.push(factor1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_SIZE_FACTOR");
						_this.turtleParameters.push(factor1);
					} else {
						_this.width *= factor1;
					}
					++j;
					break;
				case "PEN_UP":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_UP");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_UP");
					} else {
						_this.penIsDown = false;
					}
					break;
				case "PLUM":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PLUM");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PLUM");
					} else {
						_this.pen.currentColor = -7310896;
					}
					break;
				case "RED":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("RED");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("RED");
					} else {
						_this.pen.currentColor = -65536;
					}
					break;
				case "RIGHT":
					var degrees3 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("RIGHT");
						_this.historyParameters.push(degrees3);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("RIGHT");
						_this.turtleParameters.push(degrees3);
					} else {
						_this.rotation += degrees3 * Math.PI / 180;
					}
					++j;
					break;
				case "SET_ANGLE":
					var degrees4 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("SET_ANGLE");
						_this.historyParameters.push(degrees4);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("SET_ANGLE");
						_this.turtleParameters.push(degrees4);
					} else {
						_this.rotation = -Math.PI / 2;
						_this.rotation += degrees4 * Math.PI / 180;
					}
					++j;
					break;
				case "SET_POSITION":
					var x2 = v[j];
					var y2 = v[j + 1];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("SET_POSITION");
						_this.historyParameters.push(x2);
						_this.historyParameters.push(y2);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("SET_POSITION");
						_this.turtleParameters.push(x2);
						_this.turtleParameters.push(y2);
					} else {
						if(_this.endLine == 2 || _this.endLine == 3) {
							_this.contour.end(_this.width);
						}
						_this.x = x2;
						_this.y = y2;
						var l19 = _this.points.length;
						_this.points[l19] = [];
						_this.points[l19][0] = x2;
						_this.points[l19][1] = y2;
						_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
						_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
						_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d13 = _this.dim[_this.dim.length - 1];
						if(x2 < d13.minX) {
							d13.minX = x2;
						}
						if(x2 > d13.maxX) {
							d13.maxX = x2;
						}
						if(y2 < d13.minY) {
							d13.minY = y2;
						}
						if(y2 > d13.maxY) {
							d13.maxY = y2;
						}
						_this.contour.reset();
					}
					j += 2;
					break;
				case "SOUTH":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("SOUTH");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("SOUTH");
					} else {
						_this.rotation = Math.PI / 2;
					}
					break;
				case "TAN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("TAN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("TAN");
					} else {
						_this.pen.currentColor = -27273;
					}
					break;
				case "TRIANGLE_ARCH":
					var distance7 = v[j];
					var distance21 = v[j + 1];
					var radius5 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("TRIANGLE_ARCH");
						_this.historyParameters.push(distance7);
						_this.historyParameters.push(distance21);
						_this.historyParameters.push(radius5);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("TRIANGLE_ARCH");
						_this.turtleParameters.push(distance7);
						_this.turtleParameters.push(distance21);
						_this.turtleParameters.push(radius5);
					} else {
						var nx11 = _this.x + distance7 * Math.cos(_this.rotation);
						var ny11 = _this.y + distance7 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							var thruX1 = _this.x + distance21 * Math.cos(_this.rotation) - radius5 * Math.cos(_this.rotation + Math.PI / 2);
							var thruY1 = _this.y + distance21 * Math.sin(_this.rotation) - radius5 * Math.sin(_this.rotation + Math.PI / 2);
							if(_this.fill) {
								_this.pen.triangle2DFill(_this.x,_this.y,thruX1,thruY1,nx11,ny11);
							}
							_this.lineTo(thruX1,thruY1);
							_this.lineTo(nx11,ny11);
							if(_this.fill) {
								_this.lineTo(_this.x,_this.y);
							}
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx11;
							_this.y = ny11;
							var l20 = _this.points.length;
							_this.points[l20] = [];
							_this.points[l20][0] = nx11;
							_this.points[l20][1] = ny11;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d14 = _this.dim[_this.dim.length - 1];
							if(nx11 < d14.minX) {
								d14.minX = nx11;
							}
							if(nx11 > d14.maxX) {
								d14.maxX = nx11;
							}
							if(ny11 < d14.minY) {
								d14.minY = ny11;
							}
							if(ny11 > d14.maxY) {
								d14.maxY = ny11;
							}
							_this.contour.reset();
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx11;
							_this.y = ny11;
							var l21 = _this.points.length;
							_this.points[l21] = [];
							_this.points[l21][0] = nx11;
							_this.points[l21][1] = ny11;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d15 = _this.dim[_this.dim.length - 1];
							if(nx11 < d15.minX) {
								d15.minX = nx11;
							}
							if(nx11 > d15.maxX) {
								d15.maxX = nx11;
							}
							if(ny11 < d15.minY) {
								d15.minY = ny11;
							}
							if(ny11 > d15.maxY) {
								d15.maxY = ny11;
							}
							_this.contour.reset();
						}
					}
					j += 3;
					break;
				case "WEST":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("WEST");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("WEST");
					} else {
						_this.rotation = 0;
					}
					break;
				case "WHITE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("WHITE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("WHITE");
					} else {
						_this.pen.currentColor = -1;
					}
					break;
				case "YELLOW":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("YELLOW");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("YELLOW");
					} else {
						_this.pen.currentColor = -256;
					}
					break;
				}
			}
			j = 0;
		}
		_this.turtleHistoryOn = wasHistoryOn;
		_this.turtleCommands.length = 0;
		_this.turtleParameters.length = 0;
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("BLUE");
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("BLUE");
		} else {
			_this1.pen.currentColor = -16776961;
		}
	}
	,turtleStar: function() {
		var sketcher = new cornerContour_Sketcher(this.pen2D,4,0);
		if(sketcher.turtleHistoryOn) {
			sketcher.historyAdd("SET_POSITION");
			sketcher.historyParameters.push(50);
			sketcher.historyParameters.push(150);
		}
		if(sketcher.repeatCommands) {
			sketcher.turtleCommands.push("SET_POSITION");
			sketcher.turtleParameters.push(50);
			sketcher.turtleParameters.push(150);
		} else {
			if(sketcher.endLine == 2 || sketcher.endLine == 3) {
				sketcher.contour.end(sketcher.width);
			}
			sketcher.x = 50;
			sketcher.y = 150;
			var l = sketcher.points.length;
			sketcher.points[l] = [];
			sketcher.points[l][0] = 50;
			sketcher.points[l][1] = 150;
			sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
			sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
			sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = sketcher.dim[sketcher.dim.length - 1];
			if(50 < d.minX) {
				d.minX = 50;
			}
			if(50 > d.maxX) {
				d.maxX = 50;
			}
			if(150 < d.minY) {
				d.minY = 150;
			}
			if(150 > d.maxY) {
				d.maxY = 150;
			}
			sketcher.contour.reset();
		}
		var _this = sketcher;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("PEN_SIZE");
			_this.historyParameters.push(10);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("PEN_SIZE");
			_this.turtleParameters.push(10);
		} else {
			_this.width = 10;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("BLUE");
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("BLUE");
		} else {
			_this1.pen.currentColor = -16776961;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("WEST");
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("WEST");
		} else {
			_this.rotation = 0;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("FILL_OFF");
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("FILL_OFF");
		} else {
			_this1.fill = false;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("BEGIN_REPEAT");
			_this.historyParameters.push(Math.round(6));
		}
		if(_this.repeatCommands == true) {
			_this.repeatCommands = false;
			if(_this.turtleHistoryOn) {
				_this.historyAdd("END_REPEAT");
			}
			var wasHistoryOn = _this.turtleHistoryOn;
			_this.turtleHistoryOn = false;
			var v = _this.turtleParameters;
			var j = 0;
			var _g = 0;
			var _g1 = _this.repeatCount;
			while(_g < _g1) {
				var k = _g++;
				var _g2 = 0;
				var _g3 = _this.turtleCommands.length;
				while(_g2 < _g3) {
					var i = _g2++;
					var command = _this.turtleCommands[i];
					switch(command) {
					case "ARC":
						var radius = v[j];
						var degrees = v[j + 1];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("ARC");
							_this.historyParameters.push(radius);
							_this.historyParameters.push(degrees);
						}
						if(radius != 0) {
							if(_this.repeatCommands) {
								_this.turtleCommands.push("ARC");
								_this.turtleParameters.push(radius);
								_this.turtleParameters.push(degrees);
							} else {
								var beta = degrees * Math.PI / 180 / 24;
								var alpha = (Math.PI - beta) / 2;
								var rotate = -(Math.PI / 2 - alpha);
								var baseLength = 0.5 * radius * Math.sin(beta / 2);
								var ox = _this.x;
								var oy = _this.y;
								var arr = [];
								arr.push(_this.x);
								arr.push(_this.y);
								var _g4 = 0;
								while(_g4 < 48) {
									var i1 = _g4++;
									_this.rotation += rotate;
									var wasHistoryOn1 = _this.turtleHistoryOn;
									_this.turtleHistoryOn = false;
									if(_this.turtleHistoryOn) {
										_this.historyAdd("FORWARD");
										_this.historyParameters.push(baseLength);
									}
									if(_this.repeatCommands) {
										_this.turtleCommands.push("FORWARD");
										_this.turtleParameters.push(baseLength);
									} else {
										var nx = _this.x + baseLength * Math.cos(_this.rotation);
										var ny = _this.y + baseLength * Math.sin(_this.rotation);
										if(_this.penIsDown) {
											_this.lastDistance = baseLength;
											_this.lineTo(nx,ny);
										} else {
											if(_this.endLine == 2 || _this.endLine == 3) {
												_this.contour.end(_this.width);
											}
											_this.x = nx;
											_this.y = ny;
											var l = _this.points.length;
											_this.points[l] = [];
											_this.points[l][0] = nx;
											_this.points[l][1] = ny;
											_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
											_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
											_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d = _this.dim[_this.dim.length - 1];
											if(nx < d.minX) {
												d.minX = nx;
											}
											if(nx > d.maxX) {
												d.maxX = nx;
											}
											if(ny < d.minY) {
												d.minY = ny;
											}
											if(ny > d.maxY) {
												d.maxY = ny;
											}
											_this.contour.reset();
										}
									}
									_this.turtleHistoryOn = wasHistoryOn1;
									if(_this.fill) {
										arr.push(_this.x);
										arr.push(_this.y);
									}
								}
								if(_this.fill) {
									var cx = (ox + arr[arr.length - 2]) / 2;
									var cy = (oy + arr[arr.length - 1]) / 2;
									var l1 = arr.length;
									var i2 = 2;
									var lx = 0.;
									var ly = 0.;
									_this.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
									while(i2 < l1) {
										if(i2 > 2) {
											_this.pen.triangle2DFill(lx,ly,arr[i2],arr[i2 + 1],cx,cy);
										}
										lx = arr[i2];
										ly = arr[i2 + 1];
										i2 += 2;
									}
								}
								arr.length = 0;
							}
						}
						j += 2;
						break;
					case "ARCH_BEZIER":
						var distance = v[j];
						var distance2 = v[j + 1];
						var radius1 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("ARCH_BEZIER");
							_this.historyParameters.push(distance);
							_this.historyParameters.push(distance2);
							_this.historyParameters.push(radius1);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("ARCH_BEZIER");
							_this.turtleParameters.push(distance);
							_this.turtleParameters.push(distance2);
							_this.turtleParameters.push(radius1);
						} else {
							var nx1 = _this.x + distance * Math.cos(_this.rotation);
							var ny1 = _this.y + distance * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								var thruX = _this.x + distance2 * Math.cos(_this.rotation) - radius1 * Math.cos(_this.rotation + Math.PI / 2);
								var thruY = _this.y + distance2 * Math.sin(_this.rotation) - radius1 * Math.sin(_this.rotation + Math.PI / 2);
								var newx = 2 * thruX - 0.5 * (_this.x + nx1);
								var newy = 2 * thruY - 0.5 * (_this.y + ny1);
								_this.tempArr = [];
								var p = _this.tempArr;
								var ax = _this.x;
								var ay = _this.y;
								var x = ax - newx;
								var y = ay - newy;
								var x1 = newx - nx1;
								var y1 = newy - ny1;
								var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
								if(approxDistance == 0) {
									approxDistance = 0.000001;
								}
								var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
								var l2 = p.length;
								p[l2++] = ax;
								p[l2++] = ay;
								var t = step;
								while(t < 1.) {
									var u = 1 - t;
									p[l2++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx1;
									var u1 = 1 - t;
									p[l2++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny1;
									t += step;
								}
								p[l2++] = nx1;
								p[l2++] = ny1;
								var arr1 = _this.tempArr;
								var withMove = false;
								if(withMove == null) {
									withMove = true;
								}
								var l3 = arr1.length;
								var i3 = 2;
								if(withMove) {
									var x_ = arr1[0];
									var y_ = arr1[1];
									if(_this.endLine == 2 || _this.endLine == 3) {
										_this.contour.end(_this.width);
									}
									_this.x = x_;
									_this.y = y_;
									var l4 = _this.points.length;
									_this.points[l4] = [];
									_this.points[l4][0] = x_;
									_this.points[l4][1] = y_;
									_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
									_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
									_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d1 = _this.dim[_this.dim.length - 1];
									if(x_ < d1.minX) {
										d1.minX = x_;
									}
									if(x_ > d1.maxX) {
										d1.maxX = x_;
									}
									if(y_ < d1.minY) {
										d1.minY = y_;
									}
									if(y_ > d1.maxY) {
										d1.maxY = y_;
									}
									_this.contour.reset();
								} else {
									_this.lineTo(arr1[0],arr1[1]);
								}
								var cx1 = (arr1[0] + arr1[l3 - 2]) / 2;
								var cy1 = (arr1[1] + arr1[l3 - 1]) / 2;
								var ox1 = _this.x;
								var oy1 = _this.y;
								while(i3 < l3) {
									if(_this.fill && _this.penIsDown) {
										if(i3 > 0 && i3 < l3 - 2) {
											_this.pen.triangle2DFill(arr1[i3 - 2],arr1[i3 - 1],arr1[i3],arr1[i3 + 1],cx1,cy1);
										}
									}
									_this.lineTo(arr1[i3],arr1[i3 + 1]);
									i3 += 2;
								}
								if(_this.fill && _this.penIsDown) {
									if(_this.endLine == 2 || _this.endLine == 3) {
										_this.contour.end(_this.width);
									}
									_this.x = ox1;
									_this.y = oy1;
									var l5 = _this.points.length;
									_this.points[l5] = [];
									_this.points[l5][0] = ox1;
									_this.points[l5][1] = oy1;
									_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
									_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
									_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d2 = _this.dim[_this.dim.length - 1];
									if(ox1 < d2.minX) {
										d2.minX = ox1;
									}
									if(ox1 > d2.maxX) {
										d2.maxX = ox1;
									}
									if(oy1 < d2.minY) {
										d2.minY = oy1;
									}
									if(oy1 > d2.maxY) {
										d2.maxY = oy1;
									}
									_this.contour.reset();
									_this.lineTo(arr1[l3 - 2],arr1[l3 - 1]);
								}
								_this.x = nx1;
								_this.y = ny1;
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx1;
								_this.y = ny1;
								var l6 = _this.points.length;
								_this.points[l6] = [];
								_this.points[l6][0] = nx1;
								_this.points[l6][1] = ny1;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d3 = _this.dim[_this.dim.length - 1];
								if(nx1 < d3.minX) {
									d3.minX = nx1;
								}
								if(nx1 > d3.maxX) {
									d3.maxX = nx1;
								}
								if(ny1 < d3.minY) {
									d3.minY = ny1;
								}
								if(ny1 > d3.maxY) {
									d3.maxY = ny1;
								}
								_this.contour.reset();
							}
						}
						j += 3;
						break;
					case "ARC_SIDES":
						var radius2 = v[j];
						var degrees1 = v[j + 1];
						var sides = v[j + 2];
						if(sides == null) {
							sides = 24;
						}
						if(_this.turtleHistoryOn) {
							if(sides == 24) {
								_this.historyAdd("ARC");
								_this.historyParameters.push(radius2);
								_this.historyParameters.push(degrees1);
							} else {
								_this.historyAdd("ARC_SIDES");
								_this.historyParameters.push(radius2);
								_this.historyParameters.push(degrees1);
								_this.historyParameters.push(sides);
							}
						}
						if(radius2 != 0) {
							if(_this.repeatCommands) {
								if(sides == 24) {
									_this.turtleCommands.push("ARC");
									_this.turtleParameters.push(radius2);
									_this.turtleParameters.push(degrees1);
								} else {
									_this.turtleCommands.push("ARC_SIDES");
									_this.turtleParameters.push(radius2);
									_this.turtleParameters.push(degrees1);
									_this.turtleParameters.push(sides);
								}
							} else {
								var beta1 = degrees1 * Math.PI / 180 / sides;
								var alpha1 = (Math.PI - beta1) / 2;
								var rotate1 = -(Math.PI / 2 - alpha1);
								var baseLength1 = 0.5 * radius2 * Math.sin(beta1 / 2);
								var ox2 = _this.x;
								var oy2 = _this.y;
								var arr2 = [];
								arr2.push(_this.x);
								arr2.push(_this.y);
								var _g5 = 0;
								while(_g5 < 48) {
									var i4 = _g5++;
									_this.rotation += rotate1;
									var wasHistoryOn2 = _this.turtleHistoryOn;
									_this.turtleHistoryOn = false;
									if(_this.turtleHistoryOn) {
										_this.historyAdd("FORWARD");
										_this.historyParameters.push(baseLength1);
									}
									if(_this.repeatCommands) {
										_this.turtleCommands.push("FORWARD");
										_this.turtleParameters.push(baseLength1);
									} else {
										var nx2 = _this.x + baseLength1 * Math.cos(_this.rotation);
										var ny2 = _this.y + baseLength1 * Math.sin(_this.rotation);
										if(_this.penIsDown) {
											_this.lastDistance = baseLength1;
											_this.lineTo(nx2,ny2);
										} else {
											if(_this.endLine == 2 || _this.endLine == 3) {
												_this.contour.end(_this.width);
											}
											_this.x = nx2;
											_this.y = ny2;
											var l7 = _this.points.length;
											_this.points[l7] = [];
											_this.points[l7][0] = nx2;
											_this.points[l7][1] = ny2;
											_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
											_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
											_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d4 = _this.dim[_this.dim.length - 1];
											if(nx2 < d4.minX) {
												d4.minX = nx2;
											}
											if(nx2 > d4.maxX) {
												d4.maxX = nx2;
											}
											if(ny2 < d4.minY) {
												d4.minY = ny2;
											}
											if(ny2 > d4.maxY) {
												d4.maxY = ny2;
											}
											_this.contour.reset();
										}
									}
									_this.turtleHistoryOn = wasHistoryOn2;
									if(_this.fill) {
										arr2.push(_this.x);
										arr2.push(_this.y);
									}
								}
								if(_this.fill) {
									var cx2 = (ox2 + arr2[arr2.length - 2]) / 2;
									var cy2 = (oy2 + arr2[arr2.length - 1]) / 2;
									var l8 = arr2.length;
									var i5 = 2;
									var lx1 = 0.;
									var ly1 = 0.;
									_this.pen.triangle2DFill(ox2,oy2,arr2[0],arr2[1],cx2,cy2);
									while(i5 < l8) {
										if(i5 > 2) {
											_this.pen.triangle2DFill(lx1,ly1,arr2[i5],arr2[i5 + 1],cx2,cy2);
										}
										lx1 = arr2[i5];
										ly1 = arr2[i5 + 1];
										i5 += 2;
									}
								}
								arr2.length = 0;
							}
						}
						j += 3;
						break;
					case "BACKWARD":
						var distance1 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("BACKWARD");
							_this.historyParameters.push(distance1);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("BACKWARD");
							_this.turtleParameters.push(distance1);
						} else {
							var nx3 = _this.x + distance1 * Math.cos(_this.rotation + Math.PI);
							var ny3 = _this.y + distance1 * Math.sin(_this.rotation + Math.PI);
							if(_this.penIsDown) {
								_this.lineTo(nx3,ny3);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx3;
								_this.y = ny3;
								var l9 = _this.points.length;
								_this.points[l9] = [];
								_this.points[l9][0] = nx3;
								_this.points[l9][1] = ny3;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d5 = _this.dim[_this.dim.length - 1];
								if(nx3 < d5.minX) {
									d5.minX = nx3;
								}
								if(nx3 > d5.maxX) {
									d5.maxX = nx3;
								}
								if(ny3 < d5.minY) {
									d5.minY = ny3;
								}
								if(ny3 > d5.maxY) {
									d5.maxY = ny3;
								}
								_this.contour.reset();
							}
						}
						++j;
						break;
					case "BEGIN_REPEAT":
						break;
					case "BLACK":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("BLACK");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("BLACK");
						} else {
							_this.pen.currentColor = -16777216;
						}
						break;
					case "BLUE":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("BLUE");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("BLUE");
						} else {
							_this.pen.currentColor = -16776961;
						}
						break;
					case "BROWN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("BROWN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("BROWN");
						} else {
							_this.pen.currentColor = -6594501;
						}
						break;
					case "CIRCLE":
						var radius3 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("CIRCLE");
							_this.historyParameters.push(radius3);
						}
						if(radius3 != 0) {
							if(_this.repeatCommands) {
								_this.turtleCommands.push("CIRCLE");
								_this.turtleParameters.push(radius3);
							} else {
								var beta2 = 2 * Math.PI / 24;
								var alpha2 = (Math.PI - beta2) / 2;
								var rotate2 = -(Math.PI / 2 - alpha2);
								var baseLength2 = 0.5 * radius3 * Math.sin(beta2 / 2);
								var ox3 = _this.x;
								var oy3 = _this.y;
								var arr3 = [];
								var _g6 = 0;
								while(_g6 < 48) {
									var i6 = _g6++;
									_this.rotation += rotate2;
									var wasHistoryOn3 = _this.turtleHistoryOn;
									_this.turtleHistoryOn = false;
									if(_this.turtleHistoryOn) {
										_this.historyAdd("FORWARD");
										_this.historyParameters.push(baseLength2);
									}
									if(_this.repeatCommands) {
										_this.turtleCommands.push("FORWARD");
										_this.turtleParameters.push(baseLength2);
									} else {
										var nx4 = _this.x + baseLength2 * Math.cos(_this.rotation);
										var ny4 = _this.y + baseLength2 * Math.sin(_this.rotation);
										if(_this.penIsDown) {
											_this.lastDistance = baseLength2;
											_this.lineTo(nx4,ny4);
										} else {
											if(_this.endLine == 2 || _this.endLine == 3) {
												_this.contour.end(_this.width);
											}
											_this.x = nx4;
											_this.y = ny4;
											var l10 = _this.points.length;
											_this.points[l10] = [];
											_this.points[l10][0] = nx4;
											_this.points[l10][1] = ny4;
											_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
											_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
											_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d6 = _this.dim[_this.dim.length - 1];
											if(nx4 < d6.minX) {
												d6.minX = nx4;
											}
											if(nx4 > d6.maxX) {
												d6.maxX = nx4;
											}
											if(ny4 < d6.minY) {
												d6.minY = ny4;
											}
											if(ny4 > d6.maxY) {
												d6.maxY = ny4;
											}
											_this.contour.reset();
										}
									}
									_this.turtleHistoryOn = wasHistoryOn3;
									if(_this.fill) {
										arr3.push(_this.x);
										arr3.push(_this.y);
									}
								}
								if(_this.fill) {
									var cx3 = (ox3 + arr3[arr3.length - 2]) / 2;
									var cy3 = (oy3 + arr3[arr3.length - 1]) / 2;
									var l11 = arr3.length;
									var i7 = 2;
									var lx2 = 0.;
									var ly2 = 0.;
									while(i7 < l11) {
										if(i7 > 2) {
											_this.pen.triangle2DFill(lx2,ly2,arr3[i7],arr3[i7 + 1],cx3,cy3);
										}
										lx2 = arr3[i7];
										ly2 = arr3[i7 + 1];
										i7 += 2;
									}
								}
								arr3.length = 0;
							}
						}
						++j;
						break;
					case "CIRCLE_SIDES":
						var radius4 = v[j];
						var sides1 = v[j + 1];
						if(sides1 == null) {
							sides1 = 24;
						}
						if(_this.turtleHistoryOn) {
							if(sides1 == 24) {
								_this.historyAdd("CIRCLE");
								_this.historyParameters.push(radius4);
							} else {
								_this.historyAdd("CIRCLE_SIDES");
								_this.historyParameters.push(radius4);
								_this.historyParameters.push(sides1);
							}
						}
						if(radius4 != 0) {
							if(_this.repeatCommands) {
								if(sides1 == 24) {
									_this.turtleCommands.push("CIRCLE");
									_this.turtleParameters.push(radius4);
								} else {
									_this.turtleCommands.push("CIRCLE_SIDES");
									_this.turtleParameters.push(radius4);
									_this.turtleParameters.push(sides1);
								}
							} else {
								var beta3 = 2 * Math.PI / sides1;
								var alpha3 = (Math.PI - beta3) / 2;
								var rotate3 = -(Math.PI / 2 - alpha3);
								var baseLength3 = 0.5 * radius4 * Math.sin(beta3 / 2);
								var ox4 = _this.x;
								var oy4 = _this.y;
								var arr4 = [];
								var _g7 = 0;
								while(_g7 < 48) {
									var i8 = _g7++;
									_this.rotation += rotate3;
									var wasHistoryOn4 = _this.turtleHistoryOn;
									_this.turtleHistoryOn = false;
									if(_this.turtleHistoryOn) {
										_this.historyAdd("FORWARD");
										_this.historyParameters.push(baseLength3);
									}
									if(_this.repeatCommands) {
										_this.turtleCommands.push("FORWARD");
										_this.turtleParameters.push(baseLength3);
									} else {
										var nx5 = _this.x + baseLength3 * Math.cos(_this.rotation);
										var ny5 = _this.y + baseLength3 * Math.sin(_this.rotation);
										if(_this.penIsDown) {
											_this.lastDistance = baseLength3;
											_this.lineTo(nx5,ny5);
										} else {
											if(_this.endLine == 2 || _this.endLine == 3) {
												_this.contour.end(_this.width);
											}
											_this.x = nx5;
											_this.y = ny5;
											var l12 = _this.points.length;
											_this.points[l12] = [];
											_this.points[l12][0] = nx5;
											_this.points[l12][1] = ny5;
											_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
											_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
											_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d7 = _this.dim[_this.dim.length - 1];
											if(nx5 < d7.minX) {
												d7.minX = nx5;
											}
											if(nx5 > d7.maxX) {
												d7.maxX = nx5;
											}
											if(ny5 < d7.minY) {
												d7.minY = ny5;
											}
											if(ny5 > d7.maxY) {
												d7.maxY = ny5;
											}
											_this.contour.reset();
										}
									}
									_this.turtleHistoryOn = wasHistoryOn4;
									if(_this.fill) {
										arr4.push(_this.x);
										arr4.push(_this.y);
									}
								}
								if(_this.fill) {
									var cx4 = (ox4 + arr4[arr4.length - 2]) / 2;
									var cy4 = (oy4 + arr4[arr4.length - 1]) / 2;
									var l13 = arr4.length;
									var i9 = 2;
									var lx3 = 0.;
									var ly3 = 0.;
									while(i9 < l13) {
										if(i9 > 2) {
											_this.pen.triangle2DFill(lx3,ly3,arr4[i9],arr4[i9 + 1],cx4,cy4);
										}
										lx3 = arr4[i9];
										ly3 = arr4[i9 + 1];
										i9 += 2;
									}
								}
								arr4.length = 0;
							}
						}
						j += 2;
						break;
					case "CYAN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("CYAN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("CYAN");
						} else {
							_this.pen.currentColor = -16711681;
						}
						break;
					case "DARKISH_BLUE":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("DARKISH_BLUE");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("DARKISH_BLUE");
						} else {
							_this.pen.currentColor = -8864837;
						}
						break;
					case "DARK_GREEN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("DARK_GREEN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("DARK_GREEN");
						} else {
							_this.pen.currentColor = -10182080;
						}
						break;
					case "EAST":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("WEST");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("EAST");
						} else {
							_this.rotation = Math.PI;
						}
						break;
					case "END_REPEAT":
						break;
					case "FILL_OFF":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FILL_OFF");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FILL_OFF");
						} else {
							_this.fill = false;
						}
						break;
					case "FILL_ON":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FILL_ON");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FILL_ON");
						} else {
							_this.fill = true;
						}
						break;
					case "FORWARD":
						var distance3 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD");
							_this.historyParameters.push(distance3);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD");
							_this.turtleParameters.push(distance3);
						} else {
							var nx6 = _this.x + distance3 * Math.cos(_this.rotation);
							var ny6 = _this.y + distance3 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance3;
								_this.lineTo(nx6,ny6);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx6;
								_this.y = ny6;
								var l14 = _this.points.length;
								_this.points[l14] = [];
								_this.points[l14][0] = nx6;
								_this.points[l14][1] = ny6;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d8 = _this.dim[_this.dim.length - 1];
								if(nx6 < d8.minX) {
									d8.minX = nx6;
								}
								if(nx6 > d8.maxX) {
									d8.maxX = nx6;
								}
								if(ny6 < d8.minY) {
									d8.minY = ny6;
								}
								if(ny6 > d8.maxY) {
									d8.maxY = ny6;
								}
								_this.contour.reset();
							}
						}
						++j;
						break;
					case "FORWARD_CHANGE":
						var deltaDistance = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD_CHANGE");
							_this.historyParameters.push(deltaDistance);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD_CHANGE");
							_this.turtleParameters.push(deltaDistance);
						} else {
							var distance4 = _this.lastDistance + deltaDistance;
							var nx7 = _this.x + distance4 * Math.cos(_this.rotation);
							var ny7 = _this.y + distance4 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance4 + deltaDistance;
								_this.lineTo(nx7,ny7);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx7;
								_this.y = ny7;
								var l15 = _this.points.length;
								_this.points[l15] = [];
								_this.points[l15][0] = nx7;
								_this.points[l15][1] = ny7;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d9 = _this.dim[_this.dim.length - 1];
								if(nx7 < d9.minX) {
									d9.minX = nx7;
								}
								if(nx7 > d9.maxX) {
									d9.maxX = nx7;
								}
								if(ny7 < d9.minY) {
									d9.minY = ny7;
								}
								if(ny7 > d9.maxY) {
									d9.maxY = ny7;
								}
								_this.contour.reset();
							}
						}
						++j;
						break;
					case "FORWARD_FACTOR":
						var factor = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD_FACTOR");
							_this.historyParameters.push(factor);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD_FACTOR");
							_this.turtleParameters.push(factor);
						} else {
							var distance5 = _this.lastDistance * factor;
							var nx8 = _this.x + distance5 * Math.cos(_this.rotation);
							var ny8 = _this.y + distance5 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance5;
								_this.lineTo(nx8,ny8);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx8;
								_this.y = ny8;
								var l16 = _this.points.length;
								_this.points[l16] = [];
								_this.points[l16][0] = nx8;
								_this.points[l16][1] = ny8;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d10 = _this.dim[_this.dim.length - 1];
								if(nx8 < d10.minX) {
									d10.minX = nx8;
								}
								if(nx8 > d10.maxX) {
									d10.maxX = nx8;
								}
								if(ny8 < d10.minY) {
									d10.minY = ny8;
								}
								if(ny8 > d10.maxY) {
									d10.maxY = ny8;
								}
								_this.contour.reset();
							}
						}
						++j;
						break;
					case "GREEN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("GREEN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("GREEN");
						} else {
							_this.pen.currentColor = -16711936;
						}
						break;
					case "GREY":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("GREY");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("GREY");
						} else {
							_this.pen.currentColor = -4737097;
						}
						break;
					case "LEFT":
						var degrees2 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("LEFT");
							_this.historyParameters.push(degrees2);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("LEFT");
							_this.turtleParameters.push(degrees2);
						} else {
							_this.rotation -= degrees2 * Math.PI / 180;
						}
						++j;
						break;
					case "LIGHT_BROWN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("LIGHT_BROWN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("LIGHT_BROWN");
						} else {
							_this.pen.currentColor = -3831790;
						}
						break;
					case "MAGENTA":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("MAGENTA");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("MAGENTA");
						} else {
							_this.pen.currentColor = -65281;
						}
						break;
					case "MOVE_PEN":
						var distance6 = v[j];
						if(_this.repeatCommands) {
							_this.turtleCommands.push("MOVE_PEN");
							_this.turtleParameters.push(distance6);
						} else if(_this.penIsDown) {
							if(_this.turtleHistoryOn) {
								_this.historyAdd("PEN_UP");
							}
							if(_this.repeatCommands) {
								_this.turtleCommands.push("PEN_UP");
							} else {
								_this.penIsDown = false;
							}
							if(_this.turtleHistoryOn) {
								_this.historyAdd("FORWARD");
								_this.historyParameters.push(distance6);
							}
							if(_this.repeatCommands) {
								_this.turtleCommands.push("FORWARD");
								_this.turtleParameters.push(distance6);
							} else {
								var nx9 = _this.x + distance6 * Math.cos(_this.rotation);
								var ny9 = _this.y + distance6 * Math.sin(_this.rotation);
								if(_this.penIsDown) {
									_this.lastDistance = distance6;
									_this.lineTo(nx9,ny9);
								} else {
									if(_this.endLine == 2 || _this.endLine == 3) {
										_this.contour.end(_this.width);
									}
									_this.x = nx9;
									_this.y = ny9;
									var l17 = _this.points.length;
									_this.points[l17] = [];
									_this.points[l17][0] = nx9;
									_this.points[l17][1] = ny9;
									_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
									_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
									_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d11 = _this.dim[_this.dim.length - 1];
									if(nx9 < d11.minX) {
										d11.minX = nx9;
									}
									if(nx9 > d11.maxX) {
										d11.maxX = nx9;
									}
									if(ny9 < d11.minY) {
										d11.minY = ny9;
									}
									if(ny9 > d11.maxY) {
										d11.maxY = ny9;
									}
									_this.contour.reset();
								}
							}
							if(_this.turtleHistoryOn) {
								_this.historyAdd("PEN_DOWN");
							}
							if(_this.repeatCommands) {
								_this.turtleCommands.push("PEN_DOWN");
							} else {
								_this.penIsDown = true;
							}
						} else {
							if(_this.turtleHistoryOn) {
								_this.historyAdd("FORWARD");
								_this.historyParameters.push(distance6);
							}
							if(_this.repeatCommands) {
								_this.turtleCommands.push("FORWARD");
								_this.turtleParameters.push(distance6);
							} else {
								var nx10 = _this.x + distance6 * Math.cos(_this.rotation);
								var ny10 = _this.y + distance6 * Math.sin(_this.rotation);
								if(_this.penIsDown) {
									_this.lastDistance = distance6;
									_this.lineTo(nx10,ny10);
								} else {
									if(_this.endLine == 2 || _this.endLine == 3) {
										_this.contour.end(_this.width);
									}
									_this.x = nx10;
									_this.y = ny10;
									var l18 = _this.points.length;
									_this.points[l18] = [];
									_this.points[l18][0] = nx10;
									_this.points[l18][1] = ny10;
									_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
									_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
									_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d12 = _this.dim[_this.dim.length - 1];
									if(nx10 < d12.minX) {
										d12.minX = nx10;
									}
									if(nx10 > d12.maxX) {
										d12.maxX = nx10;
									}
									if(ny10 < d12.minY) {
										d12.minY = ny10;
									}
									if(ny10 > d12.maxY) {
										d12.maxY = ny10;
									}
									_this.contour.reset();
								}
							}
						}
						++j;
						break;
					case "NORTH":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("NORTH");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("NORTH");
						} else {
							_this.rotation = -Math.PI / 2;
						}
						break;
					case "ORANGE":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("ORANGE");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("ORANGE");
						} else {
							_this.pen.currentColor = -23808;
						}
						break;
					case "PEN_COLOR":
						var r = v[j];
						var g = v[j + 1];
						var b = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR");
							_this.historyParameters.push(r);
							_this.historyParameters.push(g);
							_this.historyParameters.push(b);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR");
							_this.turtleParameters.push(r);
							_this.turtleParameters.push(g);
							_this.turtleParameters.push(b);
						} else {
							_this.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_B":
						var r1 = v[j];
						var g1 = v[j + 1];
						var b1 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_B");
							_this.historyParameters.push(r1);
							_this.historyParameters.push(g1);
							_this.historyParameters.push(b1);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_B");
							_this.turtleParameters.push(r1);
							_this.turtleParameters.push(g1);
							_this.turtleParameters.push(b1);
						} else {
							_this.pen.colorB = Math.round(255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_C":
						var r2 = v[j];
						var g2 = v[j + 1];
						var b2 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_C");
							_this.historyParameters.push(r2);
							_this.historyParameters.push(g2);
							_this.historyParameters.push(b2);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_C");
							_this.turtleParameters.push(r2);
							_this.turtleParameters.push(g2);
							_this.turtleParameters.push(b2);
						} else {
							_this.pen.colorC = Math.round(255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE":
						var r3 = v[j];
						var g3 = v[j + 1];
						var b3 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_CHANGE");
							_this.historyParameters.push(r3);
							_this.historyParameters.push(g3);
							_this.historyParameters.push(b3);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_CHANGE");
							_this.turtleParameters.push(r3);
							_this.turtleParameters.push(g3);
							_this.turtleParameters.push(b3);
						} else {
							var c = _this.pen.currentColor;
							var r0 = (c >> 16 & 255) / 255;
							var g0 = (c >> 8 & 255) / 255;
							var b0 = (c & 255) / 255;
							_this.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r3) * 255) << 16 | Math.round((g0 + g3) * 255) << 8 | Math.round((b0 + b3) * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE_B":
						var r4 = v[j];
						var g4 = v[j + 1];
						var b4 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_CHANGE_B");
							_this.historyParameters.push(r4);
							_this.historyParameters.push(g4);
							_this.historyParameters.push(b4);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_CHANGE_B");
							_this.turtleParameters.push(r4);
							_this.turtleParameters.push(g4);
							_this.turtleParameters.push(b4);
						} else {
							var c1 = _this.pen.colorB;
							var r01 = (c1 >> 16 & 255) / 255;
							var g01 = (c1 >> 8 & 255) / 255;
							var b01 = (c1 & 255) / 255;
							_this.pen.colorB = Math.round(255) << 24 | Math.round((r01 + r4) * 255) << 16 | Math.round((g01 + g4) * 255) << 8 | Math.round((b01 + b4) * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE_C":
						var r5 = v[j];
						var g5 = v[j + 1];
						var b5 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_CHANGE_C");
							_this.historyParameters.push(r5);
							_this.historyParameters.push(g5);
							_this.historyParameters.push(b5);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_CHANGE_C");
							_this.turtleParameters.push(r5);
							_this.turtleParameters.push(g5);
							_this.turtleParameters.push(b5);
						} else {
							var c2 = _this.pen.colorC;
							var r02 = (c2 >> 16 & 255) / 255;
							var g02 = (c2 >> 8 & 255) / 255;
							var b02 = (c2 & 255) / 255;
							_this.pen.colorC = Math.round(255) << 24 | Math.round((r02 + r5) * 255) << 16 | Math.round((g02 + g5) * 255) << 8 | Math.round((b02 + b5) * 255);
						}
						j += 3;
						break;
					case "PEN_DOWN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_DOWN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_DOWN");
						} else {
							_this.penIsDown = true;
						}
						break;
					case "PEN_SIZE":
						var w = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_SIZE");
							_this.historyParameters.push(w);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_SIZE");
							_this.turtleParameters.push(w);
						} else {
							_this.width = w;
						}
						++j;
						break;
					case "PEN_SIZE_CHANGE":
						var dw = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_SIZE_CHANGE");
							_this.historyParameters.push(dw);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_SIZE_CHANGE");
							_this.turtleParameters.push(dw);
						} else {
							_this.width += dw;
						}
						++j;
						break;
					case "PEN_SIZE_FACTOR":
						var factor1 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_SIZE_FACTOR");
							_this.historyParameters.push(factor1);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_SIZE_FACTOR");
							_this.turtleParameters.push(factor1);
						} else {
							_this.width *= factor1;
						}
						++j;
						break;
					case "PEN_UP":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_UP");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_UP");
						} else {
							_this.penIsDown = false;
						}
						break;
					case "PLUM":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PLUM");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PLUM");
						} else {
							_this.pen.currentColor = -7310896;
						}
						break;
					case "RED":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("RED");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("RED");
						} else {
							_this.pen.currentColor = -65536;
						}
						break;
					case "RIGHT":
						var degrees3 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("RIGHT");
							_this.historyParameters.push(degrees3);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("RIGHT");
							_this.turtleParameters.push(degrees3);
						} else {
							_this.rotation += degrees3 * Math.PI / 180;
						}
						++j;
						break;
					case "SET_ANGLE":
						var degrees4 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("SET_ANGLE");
							_this.historyParameters.push(degrees4);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("SET_ANGLE");
							_this.turtleParameters.push(degrees4);
						} else {
							_this.rotation = -Math.PI / 2;
							_this.rotation += degrees4 * Math.PI / 180;
						}
						++j;
						break;
					case "SET_POSITION":
						var x2 = v[j];
						var y2 = v[j + 1];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("SET_POSITION");
							_this.historyParameters.push(x2);
							_this.historyParameters.push(y2);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("SET_POSITION");
							_this.turtleParameters.push(x2);
							_this.turtleParameters.push(y2);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = x2;
							_this.y = y2;
							var l19 = _this.points.length;
							_this.points[l19] = [];
							_this.points[l19][0] = x2;
							_this.points[l19][1] = y2;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d13 = _this.dim[_this.dim.length - 1];
							if(x2 < d13.minX) {
								d13.minX = x2;
							}
							if(x2 > d13.maxX) {
								d13.maxX = x2;
							}
							if(y2 < d13.minY) {
								d13.minY = y2;
							}
							if(y2 > d13.maxY) {
								d13.maxY = y2;
							}
							_this.contour.reset();
						}
						j += 2;
						break;
					case "SOUTH":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("SOUTH");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("SOUTH");
						} else {
							_this.rotation = Math.PI / 2;
						}
						break;
					case "TAN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("TAN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("TAN");
						} else {
							_this.pen.currentColor = -27273;
						}
						break;
					case "TRIANGLE_ARCH":
						var distance7 = v[j];
						var distance21 = v[j + 1];
						var radius5 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("TRIANGLE_ARCH");
							_this.historyParameters.push(distance7);
							_this.historyParameters.push(distance21);
							_this.historyParameters.push(radius5);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("TRIANGLE_ARCH");
							_this.turtleParameters.push(distance7);
							_this.turtleParameters.push(distance21);
							_this.turtleParameters.push(radius5);
						} else {
							var nx11 = _this.x + distance7 * Math.cos(_this.rotation);
							var ny11 = _this.y + distance7 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								var thruX1 = _this.x + distance21 * Math.cos(_this.rotation) - radius5 * Math.cos(_this.rotation + Math.PI / 2);
								var thruY1 = _this.y + distance21 * Math.sin(_this.rotation) - radius5 * Math.sin(_this.rotation + Math.PI / 2);
								if(_this.fill) {
									_this.pen.triangle2DFill(_this.x,_this.y,thruX1,thruY1,nx11,ny11);
								}
								_this.lineTo(thruX1,thruY1);
								_this.lineTo(nx11,ny11);
								if(_this.fill) {
									_this.lineTo(_this.x,_this.y);
								}
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx11;
								_this.y = ny11;
								var l20 = _this.points.length;
								_this.points[l20] = [];
								_this.points[l20][0] = nx11;
								_this.points[l20][1] = ny11;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d14 = _this.dim[_this.dim.length - 1];
								if(nx11 < d14.minX) {
									d14.minX = nx11;
								}
								if(nx11 > d14.maxX) {
									d14.maxX = nx11;
								}
								if(ny11 < d14.minY) {
									d14.minY = ny11;
								}
								if(ny11 > d14.maxY) {
									d14.maxY = ny11;
								}
								_this.contour.reset();
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx11;
								_this.y = ny11;
								var l21 = _this.points.length;
								_this.points[l21] = [];
								_this.points[l21][0] = nx11;
								_this.points[l21][1] = ny11;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d15 = _this.dim[_this.dim.length - 1];
								if(nx11 < d15.minX) {
									d15.minX = nx11;
								}
								if(nx11 > d15.maxX) {
									d15.maxX = nx11;
								}
								if(ny11 < d15.minY) {
									d15.minY = ny11;
								}
								if(ny11 > d15.maxY) {
									d15.maxY = ny11;
								}
								_this.contour.reset();
							}
						}
						j += 3;
						break;
					case "WEST":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("WEST");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("WEST");
						} else {
							_this.rotation = 0;
						}
						break;
					case "WHITE":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("WHITE");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("WHITE");
						} else {
							_this.pen.currentColor = -1;
						}
						break;
					case "YELLOW":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("YELLOW");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("YELLOW");
						} else {
							_this.pen.currentColor = -256;
						}
						break;
					}
				}
				j = 0;
			}
			_this.turtleHistoryOn = wasHistoryOn;
			_this.turtleCommands.length = 0;
			_this.turtleParameters.length = 0;
		}
		_this.repeatCount = Math.round(6);
		_this.repeatCommands = true;
		_this.turtleCommands.length = 0;
		_this.turtleParameters.length = 0;
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("ARCH_BEZIER");
			_this1.historyParameters.push(300);
			_this1.historyParameters.push(150);
			_this1.historyParameters.push(30);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("ARCH_BEZIER");
			_this1.turtleParameters.push(300);
			_this1.turtleParameters.push(150);
			_this1.turtleParameters.push(30);
		} else {
			var nx = _this1.x + 300 * Math.cos(_this1.rotation);
			var ny = _this1.y + 300 * Math.sin(_this1.rotation);
			if(_this1.penIsDown) {
				var thruX = _this1.x + 150 * Math.cos(_this1.rotation) - 30 * Math.cos(_this1.rotation + Math.PI / 2);
				var thruY = _this1.y + 150 * Math.sin(_this1.rotation) - 30 * Math.sin(_this1.rotation + Math.PI / 2);
				var newx = 2 * thruX - 0.5 * (_this1.x + nx);
				var newy = 2 * thruY - 0.5 * (_this1.y + ny);
				_this1.tempArr = [];
				var p = _this1.tempArr;
				var ax = _this1.x;
				var ay = _this1.y;
				var x = ax - newx;
				var y = ay - newy;
				var x1 = newx - nx;
				var y1 = newy - ny;
				var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
				if(approxDistance == 0) {
					approxDistance = 0.000001;
				}
				var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
				var l = p.length;
				p[l++] = ax;
				p[l++] = ay;
				var t = step;
				while(t < 1.) {
					var u = 1 - t;
					p[l++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx;
					var u1 = 1 - t;
					p[l++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny;
					t += step;
				}
				p[l++] = nx;
				p[l++] = ny;
				var arr = _this1.tempArr;
				var withMove = false;
				if(withMove == null) {
					withMove = true;
				}
				var l = arr.length;
				var i = 2;
				if(withMove) {
					var x_ = arr[0];
					var y_ = arr[1];
					if(_this1.endLine == 2 || _this1.endLine == 3) {
						_this1.contour.end(_this1.width);
					}
					_this1.x = x_;
					_this1.y = y_;
					var l1 = _this1.points.length;
					_this1.points[l1] = [];
					_this1.points[l1][0] = x_;
					_this1.points[l1][1] = y_;
					_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
					_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
					_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
					var d = _this1.dim[_this1.dim.length - 1];
					if(x_ < d.minX) {
						d.minX = x_;
					}
					if(x_ > d.maxX) {
						d.maxX = x_;
					}
					if(y_ < d.minY) {
						d.minY = y_;
					}
					if(y_ > d.maxY) {
						d.maxY = y_;
					}
					_this1.contour.reset();
				} else {
					_this1.lineTo(arr[0],arr[1]);
				}
				var cx = (arr[0] + arr[l - 2]) / 2;
				var cy = (arr[1] + arr[l - 1]) / 2;
				var ox = _this1.x;
				var oy = _this1.y;
				while(i < l) {
					if(_this1.fill && _this1.penIsDown) {
						if(i > 0 && i < l - 2) {
							_this1.pen.triangle2DFill(arr[i - 2],arr[i - 1],arr[i],arr[i + 1],cx,cy);
						}
					}
					_this1.lineTo(arr[i],arr[i + 1]);
					i += 2;
				}
				if(_this1.fill && _this1.penIsDown) {
					if(_this1.endLine == 2 || _this1.endLine == 3) {
						_this1.contour.end(_this1.width);
					}
					_this1.x = ox;
					_this1.y = oy;
					var l1 = _this1.points.length;
					_this1.points[l1] = [];
					_this1.points[l1][0] = ox;
					_this1.points[l1][1] = oy;
					_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
					_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
					_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
					var d = _this1.dim[_this1.dim.length - 1];
					if(ox < d.minX) {
						d.minX = ox;
					}
					if(ox > d.maxX) {
						d.maxX = ox;
					}
					if(oy < d.minY) {
						d.minY = oy;
					}
					if(oy > d.maxY) {
						d.maxY = oy;
					}
					_this1.contour.reset();
					_this1.lineTo(arr[l - 2],arr[l - 1]);
				}
				_this1.x = nx;
				_this1.y = ny;
			} else {
				if(_this1.endLine == 2 || _this1.endLine == 3) {
					_this1.contour.end(_this1.width);
				}
				_this1.x = nx;
				_this1.y = ny;
				var l = _this1.points.length;
				_this1.points[l] = [];
				_this1.points[l][0] = nx;
				_this1.points[l][1] = ny;
				_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
				_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
				_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this1.dim[_this1.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this1.contour.reset();
			}
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("RIGHT");
			_this.historyParameters.push(144);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("RIGHT");
			_this.turtleParameters.push(144);
		} else {
			_this.rotation += 144 * Math.PI / 180;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("PEN_COLOR_CHANGE");
			_this1.historyParameters.push(0.09);
			_this1.historyParameters.push(0.1);
			_this1.historyParameters.push(-0.09);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("PEN_COLOR_CHANGE");
			_this1.turtleParameters.push(0.09);
			_this1.turtleParameters.push(0.1);
			_this1.turtleParameters.push(-0.09);
		} else {
			var c = _this1.pen.currentColor;
			var r0 = (c >> 16 & 255) / 255;
			var g0 = (c >> 8 & 255) / 255;
			var b0 = (c & 255) / 255;
			_this1.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + 0.09) * 255) << 16 | Math.round((g0 + 0.1) * 255) << 8 | Math.round((b0 + (-0.09)) * 255);
		}
		var _this = _this1;
		_this.repeatCommands = false;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("END_REPEAT");
		}
		var wasHistoryOn = _this.turtleHistoryOn;
		_this.turtleHistoryOn = false;
		var v = _this.turtleParameters;
		var j = 0;
		var _g = 0;
		var _g1 = _this.repeatCount;
		while(_g < _g1) {
			var k = _g++;
			var _g2 = 0;
			var _g3 = _this.turtleCommands.length;
			while(_g2 < _g3) {
				var i = _g2++;
				var command = _this.turtleCommands[i];
				switch(command) {
				case "ARC":
					var radius = v[j];
					var degrees = v[j + 1];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("ARC");
						_this.historyParameters.push(radius);
						_this.historyParameters.push(degrees);
					}
					if(radius != 0) {
						if(_this.repeatCommands) {
							_this.turtleCommands.push("ARC");
							_this.turtleParameters.push(radius);
							_this.turtleParameters.push(degrees);
						} else {
							var beta = degrees * Math.PI / 180 / 24;
							var alpha = (Math.PI - beta) / 2;
							var rotate = -(Math.PI / 2 - alpha);
							var baseLength = 0.5 * radius * Math.sin(beta / 2);
							var ox = _this.x;
							var oy = _this.y;
							var arr = [];
							arr.push(_this.x);
							arr.push(_this.y);
							var _g4 = 0;
							while(_g4 < 48) {
								var i1 = _g4++;
								_this.rotation += rotate;
								var wasHistoryOn1 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength);
								} else {
									var nx = _this.x + baseLength * Math.cos(_this.rotation);
									var ny = _this.y + baseLength * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength;
										_this.lineTo(nx,ny);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx;
										_this.y = ny;
										var l = _this.points.length;
										_this.points[l] = [];
										_this.points[l][0] = nx;
										_this.points[l][1] = ny;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d = _this.dim[_this.dim.length - 1];
										if(nx < d.minX) {
											d.minX = nx;
										}
										if(nx > d.maxX) {
											d.maxX = nx;
										}
										if(ny < d.minY) {
											d.minY = ny;
										}
										if(ny > d.maxY) {
											d.maxY = ny;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn1;
								if(_this.fill) {
									arr.push(_this.x);
									arr.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx = (ox + arr[arr.length - 2]) / 2;
								var cy = (oy + arr[arr.length - 1]) / 2;
								var l1 = arr.length;
								var i2 = 2;
								var lx = 0.;
								var ly = 0.;
								_this.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
								while(i2 < l1) {
									if(i2 > 2) {
										_this.pen.triangle2DFill(lx,ly,arr[i2],arr[i2 + 1],cx,cy);
									}
									lx = arr[i2];
									ly = arr[i2 + 1];
									i2 += 2;
								}
							}
							arr.length = 0;
						}
					}
					j += 2;
					break;
				case "ARCH_BEZIER":
					var distance = v[j];
					var distance2 = v[j + 1];
					var radius1 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("ARCH_BEZIER");
						_this.historyParameters.push(distance);
						_this.historyParameters.push(distance2);
						_this.historyParameters.push(radius1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("ARCH_BEZIER");
						_this.turtleParameters.push(distance);
						_this.turtleParameters.push(distance2);
						_this.turtleParameters.push(radius1);
					} else {
						var nx1 = _this.x + distance * Math.cos(_this.rotation);
						var ny1 = _this.y + distance * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							var thruX = _this.x + distance2 * Math.cos(_this.rotation) - radius1 * Math.cos(_this.rotation + Math.PI / 2);
							var thruY = _this.y + distance2 * Math.sin(_this.rotation) - radius1 * Math.sin(_this.rotation + Math.PI / 2);
							var newx = 2 * thruX - 0.5 * (_this.x + nx1);
							var newy = 2 * thruY - 0.5 * (_this.y + ny1);
							_this.tempArr = [];
							var p = _this.tempArr;
							var ax = _this.x;
							var ay = _this.y;
							var x = ax - newx;
							var y = ay - newy;
							var x1 = newx - nx1;
							var y1 = newy - ny1;
							var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
							if(approxDistance == 0) {
								approxDistance = 0.000001;
							}
							var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
							var l2 = p.length;
							p[l2++] = ax;
							p[l2++] = ay;
							var t = step;
							while(t < 1.) {
								var u = 1 - t;
								p[l2++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx1;
								var u1 = 1 - t;
								p[l2++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny1;
								t += step;
							}
							p[l2++] = nx1;
							p[l2++] = ny1;
							var arr1 = _this.tempArr;
							var withMove = false;
							if(withMove == null) {
								withMove = true;
							}
							var l3 = arr1.length;
							var i3 = 2;
							if(withMove) {
								var x_ = arr1[0];
								var y_ = arr1[1];
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = x_;
								_this.y = y_;
								var l4 = _this.points.length;
								_this.points[l4] = [];
								_this.points[l4][0] = x_;
								_this.points[l4][1] = y_;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d1 = _this.dim[_this.dim.length - 1];
								if(x_ < d1.minX) {
									d1.minX = x_;
								}
								if(x_ > d1.maxX) {
									d1.maxX = x_;
								}
								if(y_ < d1.minY) {
									d1.minY = y_;
								}
								if(y_ > d1.maxY) {
									d1.maxY = y_;
								}
								_this.contour.reset();
							} else {
								_this.lineTo(arr1[0],arr1[1]);
							}
							var cx1 = (arr1[0] + arr1[l3 - 2]) / 2;
							var cy1 = (arr1[1] + arr1[l3 - 1]) / 2;
							var ox1 = _this.x;
							var oy1 = _this.y;
							while(i3 < l3) {
								if(_this.fill && _this.penIsDown) {
									if(i3 > 0 && i3 < l3 - 2) {
										_this.pen.triangle2DFill(arr1[i3 - 2],arr1[i3 - 1],arr1[i3],arr1[i3 + 1],cx1,cy1);
									}
								}
								_this.lineTo(arr1[i3],arr1[i3 + 1]);
								i3 += 2;
							}
							if(_this.fill && _this.penIsDown) {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = ox1;
								_this.y = oy1;
								var l5 = _this.points.length;
								_this.points[l5] = [];
								_this.points[l5][0] = ox1;
								_this.points[l5][1] = oy1;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d2 = _this.dim[_this.dim.length - 1];
								if(ox1 < d2.minX) {
									d2.minX = ox1;
								}
								if(ox1 > d2.maxX) {
									d2.maxX = ox1;
								}
								if(oy1 < d2.minY) {
									d2.minY = oy1;
								}
								if(oy1 > d2.maxY) {
									d2.maxY = oy1;
								}
								_this.contour.reset();
								_this.lineTo(arr1[l3 - 2],arr1[l3 - 1]);
							}
							_this.x = nx1;
							_this.y = ny1;
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx1;
							_this.y = ny1;
							var l6 = _this.points.length;
							_this.points[l6] = [];
							_this.points[l6][0] = nx1;
							_this.points[l6][1] = ny1;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d3 = _this.dim[_this.dim.length - 1];
							if(nx1 < d3.minX) {
								d3.minX = nx1;
							}
							if(nx1 > d3.maxX) {
								d3.maxX = nx1;
							}
							if(ny1 < d3.minY) {
								d3.minY = ny1;
							}
							if(ny1 > d3.maxY) {
								d3.maxY = ny1;
							}
							_this.contour.reset();
						}
					}
					j += 3;
					break;
				case "ARC_SIDES":
					var radius2 = v[j];
					var degrees1 = v[j + 1];
					var sides = v[j + 2];
					if(sides == null) {
						sides = 24;
					}
					if(_this.turtleHistoryOn) {
						if(sides == 24) {
							_this.historyAdd("ARC");
							_this.historyParameters.push(radius2);
							_this.historyParameters.push(degrees1);
						} else {
							_this.historyAdd("ARC_SIDES");
							_this.historyParameters.push(radius2);
							_this.historyParameters.push(degrees1);
							_this.historyParameters.push(sides);
						}
					}
					if(radius2 != 0) {
						if(_this.repeatCommands) {
							if(sides == 24) {
								_this.turtleCommands.push("ARC");
								_this.turtleParameters.push(radius2);
								_this.turtleParameters.push(degrees1);
							} else {
								_this.turtleCommands.push("ARC_SIDES");
								_this.turtleParameters.push(radius2);
								_this.turtleParameters.push(degrees1);
								_this.turtleParameters.push(sides);
							}
						} else {
							var beta1 = degrees1 * Math.PI / 180 / sides;
							var alpha1 = (Math.PI - beta1) / 2;
							var rotate1 = -(Math.PI / 2 - alpha1);
							var baseLength1 = 0.5 * radius2 * Math.sin(beta1 / 2);
							var ox2 = _this.x;
							var oy2 = _this.y;
							var arr2 = [];
							arr2.push(_this.x);
							arr2.push(_this.y);
							var _g5 = 0;
							while(_g5 < 48) {
								var i4 = _g5++;
								_this.rotation += rotate1;
								var wasHistoryOn2 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength1);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength1);
								} else {
									var nx2 = _this.x + baseLength1 * Math.cos(_this.rotation);
									var ny2 = _this.y + baseLength1 * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength1;
										_this.lineTo(nx2,ny2);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx2;
										_this.y = ny2;
										var l7 = _this.points.length;
										_this.points[l7] = [];
										_this.points[l7][0] = nx2;
										_this.points[l7][1] = ny2;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d4 = _this.dim[_this.dim.length - 1];
										if(nx2 < d4.minX) {
											d4.minX = nx2;
										}
										if(nx2 > d4.maxX) {
											d4.maxX = nx2;
										}
										if(ny2 < d4.minY) {
											d4.minY = ny2;
										}
										if(ny2 > d4.maxY) {
											d4.maxY = ny2;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn2;
								if(_this.fill) {
									arr2.push(_this.x);
									arr2.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx2 = (ox2 + arr2[arr2.length - 2]) / 2;
								var cy2 = (oy2 + arr2[arr2.length - 1]) / 2;
								var l8 = arr2.length;
								var i5 = 2;
								var lx1 = 0.;
								var ly1 = 0.;
								_this.pen.triangle2DFill(ox2,oy2,arr2[0],arr2[1],cx2,cy2);
								while(i5 < l8) {
									if(i5 > 2) {
										_this.pen.triangle2DFill(lx1,ly1,arr2[i5],arr2[i5 + 1],cx2,cy2);
									}
									lx1 = arr2[i5];
									ly1 = arr2[i5 + 1];
									i5 += 2;
								}
							}
							arr2.length = 0;
						}
					}
					j += 3;
					break;
				case "BACKWARD":
					var distance1 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BACKWARD");
						_this.historyParameters.push(distance1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BACKWARD");
						_this.turtleParameters.push(distance1);
					} else {
						var nx3 = _this.x + distance1 * Math.cos(_this.rotation + Math.PI);
						var ny3 = _this.y + distance1 * Math.sin(_this.rotation + Math.PI);
						if(_this.penIsDown) {
							_this.lineTo(nx3,ny3);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx3;
							_this.y = ny3;
							var l9 = _this.points.length;
							_this.points[l9] = [];
							_this.points[l9][0] = nx3;
							_this.points[l9][1] = ny3;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d5 = _this.dim[_this.dim.length - 1];
							if(nx3 < d5.minX) {
								d5.minX = nx3;
							}
							if(nx3 > d5.maxX) {
								d5.maxX = nx3;
							}
							if(ny3 < d5.minY) {
								d5.minY = ny3;
							}
							if(ny3 > d5.maxY) {
								d5.maxY = ny3;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "BEGIN_REPEAT":
					break;
				case "BLACK":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BLACK");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BLACK");
					} else {
						_this.pen.currentColor = -16777216;
					}
					break;
				case "BLUE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BLUE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BLUE");
					} else {
						_this.pen.currentColor = -16776961;
					}
					break;
				case "BROWN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BROWN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BROWN");
					} else {
						_this.pen.currentColor = -6594501;
					}
					break;
				case "CIRCLE":
					var radius3 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("CIRCLE");
						_this.historyParameters.push(radius3);
					}
					if(radius3 != 0) {
						if(_this.repeatCommands) {
							_this.turtleCommands.push("CIRCLE");
							_this.turtleParameters.push(radius3);
						} else {
							var beta2 = 2 * Math.PI / 24;
							var alpha2 = (Math.PI - beta2) / 2;
							var rotate2 = -(Math.PI / 2 - alpha2);
							var baseLength2 = 0.5 * radius3 * Math.sin(beta2 / 2);
							var ox3 = _this.x;
							var oy3 = _this.y;
							var arr3 = [];
							var _g6 = 0;
							while(_g6 < 48) {
								var i6 = _g6++;
								_this.rotation += rotate2;
								var wasHistoryOn3 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength2);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength2);
								} else {
									var nx4 = _this.x + baseLength2 * Math.cos(_this.rotation);
									var ny4 = _this.y + baseLength2 * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength2;
										_this.lineTo(nx4,ny4);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx4;
										_this.y = ny4;
										var l10 = _this.points.length;
										_this.points[l10] = [];
										_this.points[l10][0] = nx4;
										_this.points[l10][1] = ny4;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d6 = _this.dim[_this.dim.length - 1];
										if(nx4 < d6.minX) {
											d6.minX = nx4;
										}
										if(nx4 > d6.maxX) {
											d6.maxX = nx4;
										}
										if(ny4 < d6.minY) {
											d6.minY = ny4;
										}
										if(ny4 > d6.maxY) {
											d6.maxY = ny4;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn3;
								if(_this.fill) {
									arr3.push(_this.x);
									arr3.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx3 = (ox3 + arr3[arr3.length - 2]) / 2;
								var cy3 = (oy3 + arr3[arr3.length - 1]) / 2;
								var l11 = arr3.length;
								var i7 = 2;
								var lx2 = 0.;
								var ly2 = 0.;
								while(i7 < l11) {
									if(i7 > 2) {
										_this.pen.triangle2DFill(lx2,ly2,arr3[i7],arr3[i7 + 1],cx3,cy3);
									}
									lx2 = arr3[i7];
									ly2 = arr3[i7 + 1];
									i7 += 2;
								}
							}
							arr3.length = 0;
						}
					}
					++j;
					break;
				case "CIRCLE_SIDES":
					var radius4 = v[j];
					var sides1 = v[j + 1];
					if(sides1 == null) {
						sides1 = 24;
					}
					if(_this.turtleHistoryOn) {
						if(sides1 == 24) {
							_this.historyAdd("CIRCLE");
							_this.historyParameters.push(radius4);
						} else {
							_this.historyAdd("CIRCLE_SIDES");
							_this.historyParameters.push(radius4);
							_this.historyParameters.push(sides1);
						}
					}
					if(radius4 != 0) {
						if(_this.repeatCommands) {
							if(sides1 == 24) {
								_this.turtleCommands.push("CIRCLE");
								_this.turtleParameters.push(radius4);
							} else {
								_this.turtleCommands.push("CIRCLE_SIDES");
								_this.turtleParameters.push(radius4);
								_this.turtleParameters.push(sides1);
							}
						} else {
							var beta3 = 2 * Math.PI / sides1;
							var alpha3 = (Math.PI - beta3) / 2;
							var rotate3 = -(Math.PI / 2 - alpha3);
							var baseLength3 = 0.5 * radius4 * Math.sin(beta3 / 2);
							var ox4 = _this.x;
							var oy4 = _this.y;
							var arr4 = [];
							var _g7 = 0;
							while(_g7 < 48) {
								var i8 = _g7++;
								_this.rotation += rotate3;
								var wasHistoryOn4 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength3);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength3);
								} else {
									var nx5 = _this.x + baseLength3 * Math.cos(_this.rotation);
									var ny5 = _this.y + baseLength3 * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength3;
										_this.lineTo(nx5,ny5);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx5;
										_this.y = ny5;
										var l12 = _this.points.length;
										_this.points[l12] = [];
										_this.points[l12][0] = nx5;
										_this.points[l12][1] = ny5;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d7 = _this.dim[_this.dim.length - 1];
										if(nx5 < d7.minX) {
											d7.minX = nx5;
										}
										if(nx5 > d7.maxX) {
											d7.maxX = nx5;
										}
										if(ny5 < d7.minY) {
											d7.minY = ny5;
										}
										if(ny5 > d7.maxY) {
											d7.maxY = ny5;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn4;
								if(_this.fill) {
									arr4.push(_this.x);
									arr4.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx4 = (ox4 + arr4[arr4.length - 2]) / 2;
								var cy4 = (oy4 + arr4[arr4.length - 1]) / 2;
								var l13 = arr4.length;
								var i9 = 2;
								var lx3 = 0.;
								var ly3 = 0.;
								while(i9 < l13) {
									if(i9 > 2) {
										_this.pen.triangle2DFill(lx3,ly3,arr4[i9],arr4[i9 + 1],cx4,cy4);
									}
									lx3 = arr4[i9];
									ly3 = arr4[i9 + 1];
									i9 += 2;
								}
							}
							arr4.length = 0;
						}
					}
					j += 2;
					break;
				case "CYAN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("CYAN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("CYAN");
					} else {
						_this.pen.currentColor = -16711681;
					}
					break;
				case "DARKISH_BLUE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("DARKISH_BLUE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("DARKISH_BLUE");
					} else {
						_this.pen.currentColor = -8864837;
					}
					break;
				case "DARK_GREEN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("DARK_GREEN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("DARK_GREEN");
					} else {
						_this.pen.currentColor = -10182080;
					}
					break;
				case "EAST":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("WEST");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("EAST");
					} else {
						_this.rotation = Math.PI;
					}
					break;
				case "END_REPEAT":
					break;
				case "FILL_OFF":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FILL_OFF");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FILL_OFF");
					} else {
						_this.fill = false;
					}
					break;
				case "FILL_ON":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FILL_ON");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FILL_ON");
					} else {
						_this.fill = true;
					}
					break;
				case "FORWARD":
					var distance3 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FORWARD");
						_this.historyParameters.push(distance3);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FORWARD");
						_this.turtleParameters.push(distance3);
					} else {
						var nx6 = _this.x + distance3 * Math.cos(_this.rotation);
						var ny6 = _this.y + distance3 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							_this.lastDistance = distance3;
							_this.lineTo(nx6,ny6);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx6;
							_this.y = ny6;
							var l14 = _this.points.length;
							_this.points[l14] = [];
							_this.points[l14][0] = nx6;
							_this.points[l14][1] = ny6;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d8 = _this.dim[_this.dim.length - 1];
							if(nx6 < d8.minX) {
								d8.minX = nx6;
							}
							if(nx6 > d8.maxX) {
								d8.maxX = nx6;
							}
							if(ny6 < d8.minY) {
								d8.minY = ny6;
							}
							if(ny6 > d8.maxY) {
								d8.maxY = ny6;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "FORWARD_CHANGE":
					var deltaDistance = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FORWARD_CHANGE");
						_this.historyParameters.push(deltaDistance);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FORWARD_CHANGE");
						_this.turtleParameters.push(deltaDistance);
					} else {
						var distance4 = _this.lastDistance + deltaDistance;
						var nx7 = _this.x + distance4 * Math.cos(_this.rotation);
						var ny7 = _this.y + distance4 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							_this.lastDistance = distance4 + deltaDistance;
							_this.lineTo(nx7,ny7);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx7;
							_this.y = ny7;
							var l15 = _this.points.length;
							_this.points[l15] = [];
							_this.points[l15][0] = nx7;
							_this.points[l15][1] = ny7;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d9 = _this.dim[_this.dim.length - 1];
							if(nx7 < d9.minX) {
								d9.minX = nx7;
							}
							if(nx7 > d9.maxX) {
								d9.maxX = nx7;
							}
							if(ny7 < d9.minY) {
								d9.minY = ny7;
							}
							if(ny7 > d9.maxY) {
								d9.maxY = ny7;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "FORWARD_FACTOR":
					var factor = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FORWARD_FACTOR");
						_this.historyParameters.push(factor);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FORWARD_FACTOR");
						_this.turtleParameters.push(factor);
					} else {
						var distance5 = _this.lastDistance * factor;
						var nx8 = _this.x + distance5 * Math.cos(_this.rotation);
						var ny8 = _this.y + distance5 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							_this.lastDistance = distance5;
							_this.lineTo(nx8,ny8);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx8;
							_this.y = ny8;
							var l16 = _this.points.length;
							_this.points[l16] = [];
							_this.points[l16][0] = nx8;
							_this.points[l16][1] = ny8;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d10 = _this.dim[_this.dim.length - 1];
							if(nx8 < d10.minX) {
								d10.minX = nx8;
							}
							if(nx8 > d10.maxX) {
								d10.maxX = nx8;
							}
							if(ny8 < d10.minY) {
								d10.minY = ny8;
							}
							if(ny8 > d10.maxY) {
								d10.maxY = ny8;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "GREEN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("GREEN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("GREEN");
					} else {
						_this.pen.currentColor = -16711936;
					}
					break;
				case "GREY":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("GREY");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("GREY");
					} else {
						_this.pen.currentColor = -4737097;
					}
					break;
				case "LEFT":
					var degrees2 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("LEFT");
						_this.historyParameters.push(degrees2);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("LEFT");
						_this.turtleParameters.push(degrees2);
					} else {
						_this.rotation -= degrees2 * Math.PI / 180;
					}
					++j;
					break;
				case "LIGHT_BROWN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("LIGHT_BROWN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("LIGHT_BROWN");
					} else {
						_this.pen.currentColor = -3831790;
					}
					break;
				case "MAGENTA":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("MAGENTA");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("MAGENTA");
					} else {
						_this.pen.currentColor = -65281;
					}
					break;
				case "MOVE_PEN":
					var distance6 = v[j];
					if(_this.repeatCommands) {
						_this.turtleCommands.push("MOVE_PEN");
						_this.turtleParameters.push(distance6);
					} else if(_this.penIsDown) {
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_UP");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_UP");
						} else {
							_this.penIsDown = false;
						}
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD");
							_this.historyParameters.push(distance6);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD");
							_this.turtleParameters.push(distance6);
						} else {
							var nx9 = _this.x + distance6 * Math.cos(_this.rotation);
							var ny9 = _this.y + distance6 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance6;
								_this.lineTo(nx9,ny9);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx9;
								_this.y = ny9;
								var l17 = _this.points.length;
								_this.points[l17] = [];
								_this.points[l17][0] = nx9;
								_this.points[l17][1] = ny9;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d11 = _this.dim[_this.dim.length - 1];
								if(nx9 < d11.minX) {
									d11.minX = nx9;
								}
								if(nx9 > d11.maxX) {
									d11.maxX = nx9;
								}
								if(ny9 < d11.minY) {
									d11.minY = ny9;
								}
								if(ny9 > d11.maxY) {
									d11.maxY = ny9;
								}
								_this.contour.reset();
							}
						}
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_DOWN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_DOWN");
						} else {
							_this.penIsDown = true;
						}
					} else {
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD");
							_this.historyParameters.push(distance6);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD");
							_this.turtleParameters.push(distance6);
						} else {
							var nx10 = _this.x + distance6 * Math.cos(_this.rotation);
							var ny10 = _this.y + distance6 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance6;
								_this.lineTo(nx10,ny10);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx10;
								_this.y = ny10;
								var l18 = _this.points.length;
								_this.points[l18] = [];
								_this.points[l18][0] = nx10;
								_this.points[l18][1] = ny10;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d12 = _this.dim[_this.dim.length - 1];
								if(nx10 < d12.minX) {
									d12.minX = nx10;
								}
								if(nx10 > d12.maxX) {
									d12.maxX = nx10;
								}
								if(ny10 < d12.minY) {
									d12.minY = ny10;
								}
								if(ny10 > d12.maxY) {
									d12.maxY = ny10;
								}
								_this.contour.reset();
							}
						}
					}
					++j;
					break;
				case "NORTH":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("NORTH");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("NORTH");
					} else {
						_this.rotation = -Math.PI / 2;
					}
					break;
				case "ORANGE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("ORANGE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("ORANGE");
					} else {
						_this.pen.currentColor = -23808;
					}
					break;
				case "PEN_COLOR":
					var r = v[j];
					var g = v[j + 1];
					var b = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR");
						_this.historyParameters.push(r);
						_this.historyParameters.push(g);
						_this.historyParameters.push(b);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR");
						_this.turtleParameters.push(r);
						_this.turtleParameters.push(g);
						_this.turtleParameters.push(b);
					} else {
						_this.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_B":
					var r1 = v[j];
					var g1 = v[j + 1];
					var b1 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_B");
						_this.historyParameters.push(r1);
						_this.historyParameters.push(g1);
						_this.historyParameters.push(b1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_B");
						_this.turtleParameters.push(r1);
						_this.turtleParameters.push(g1);
						_this.turtleParameters.push(b1);
					} else {
						_this.pen.colorB = Math.round(255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_C":
					var r2 = v[j];
					var g2 = v[j + 1];
					var b2 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_C");
						_this.historyParameters.push(r2);
						_this.historyParameters.push(g2);
						_this.historyParameters.push(b2);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_C");
						_this.turtleParameters.push(r2);
						_this.turtleParameters.push(g2);
						_this.turtleParameters.push(b2);
					} else {
						_this.pen.colorC = Math.round(255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE":
					var r3 = v[j];
					var g3 = v[j + 1];
					var b3 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_CHANGE");
						_this.historyParameters.push(r3);
						_this.historyParameters.push(g3);
						_this.historyParameters.push(b3);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_CHANGE");
						_this.turtleParameters.push(r3);
						_this.turtleParameters.push(g3);
						_this.turtleParameters.push(b3);
					} else {
						var c = _this.pen.currentColor;
						var r0 = (c >> 16 & 255) / 255;
						var g0 = (c >> 8 & 255) / 255;
						var b0 = (c & 255) / 255;
						_this.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r3) * 255) << 16 | Math.round((g0 + g3) * 255) << 8 | Math.round((b0 + b3) * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE_B":
					var r4 = v[j];
					var g4 = v[j + 1];
					var b4 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_CHANGE_B");
						_this.historyParameters.push(r4);
						_this.historyParameters.push(g4);
						_this.historyParameters.push(b4);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_CHANGE_B");
						_this.turtleParameters.push(r4);
						_this.turtleParameters.push(g4);
						_this.turtleParameters.push(b4);
					} else {
						var c1 = _this.pen.colorB;
						var r01 = (c1 >> 16 & 255) / 255;
						var g01 = (c1 >> 8 & 255) / 255;
						var b01 = (c1 & 255) / 255;
						_this.pen.colorB = Math.round(255) << 24 | Math.round((r01 + r4) * 255) << 16 | Math.round((g01 + g4) * 255) << 8 | Math.round((b01 + b4) * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE_C":
					var r5 = v[j];
					var g5 = v[j + 1];
					var b5 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_CHANGE_C");
						_this.historyParameters.push(r5);
						_this.historyParameters.push(g5);
						_this.historyParameters.push(b5);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_CHANGE_C");
						_this.turtleParameters.push(r5);
						_this.turtleParameters.push(g5);
						_this.turtleParameters.push(b5);
					} else {
						var c2 = _this.pen.colorC;
						var r02 = (c2 >> 16 & 255) / 255;
						var g02 = (c2 >> 8 & 255) / 255;
						var b02 = (c2 & 255) / 255;
						_this.pen.colorC = Math.round(255) << 24 | Math.round((r02 + r5) * 255) << 16 | Math.round((g02 + g5) * 255) << 8 | Math.round((b02 + b5) * 255);
					}
					j += 3;
					break;
				case "PEN_DOWN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_DOWN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_DOWN");
					} else {
						_this.penIsDown = true;
					}
					break;
				case "PEN_SIZE":
					var w = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_SIZE");
						_this.historyParameters.push(w);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_SIZE");
						_this.turtleParameters.push(w);
					} else {
						_this.width = w;
					}
					++j;
					break;
				case "PEN_SIZE_CHANGE":
					var dw = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_SIZE_CHANGE");
						_this.historyParameters.push(dw);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_SIZE_CHANGE");
						_this.turtleParameters.push(dw);
					} else {
						_this.width += dw;
					}
					++j;
					break;
				case "PEN_SIZE_FACTOR":
					var factor1 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_SIZE_FACTOR");
						_this.historyParameters.push(factor1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_SIZE_FACTOR");
						_this.turtleParameters.push(factor1);
					} else {
						_this.width *= factor1;
					}
					++j;
					break;
				case "PEN_UP":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_UP");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_UP");
					} else {
						_this.penIsDown = false;
					}
					break;
				case "PLUM":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PLUM");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PLUM");
					} else {
						_this.pen.currentColor = -7310896;
					}
					break;
				case "RED":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("RED");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("RED");
					} else {
						_this.pen.currentColor = -65536;
					}
					break;
				case "RIGHT":
					var degrees3 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("RIGHT");
						_this.historyParameters.push(degrees3);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("RIGHT");
						_this.turtleParameters.push(degrees3);
					} else {
						_this.rotation += degrees3 * Math.PI / 180;
					}
					++j;
					break;
				case "SET_ANGLE":
					var degrees4 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("SET_ANGLE");
						_this.historyParameters.push(degrees4);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("SET_ANGLE");
						_this.turtleParameters.push(degrees4);
					} else {
						_this.rotation = -Math.PI / 2;
						_this.rotation += degrees4 * Math.PI / 180;
					}
					++j;
					break;
				case "SET_POSITION":
					var x2 = v[j];
					var y2 = v[j + 1];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("SET_POSITION");
						_this.historyParameters.push(x2);
						_this.historyParameters.push(y2);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("SET_POSITION");
						_this.turtleParameters.push(x2);
						_this.turtleParameters.push(y2);
					} else {
						if(_this.endLine == 2 || _this.endLine == 3) {
							_this.contour.end(_this.width);
						}
						_this.x = x2;
						_this.y = y2;
						var l19 = _this.points.length;
						_this.points[l19] = [];
						_this.points[l19][0] = x2;
						_this.points[l19][1] = y2;
						_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
						_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
						_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d13 = _this.dim[_this.dim.length - 1];
						if(x2 < d13.minX) {
							d13.minX = x2;
						}
						if(x2 > d13.maxX) {
							d13.maxX = x2;
						}
						if(y2 < d13.minY) {
							d13.minY = y2;
						}
						if(y2 > d13.maxY) {
							d13.maxY = y2;
						}
						_this.contour.reset();
					}
					j += 2;
					break;
				case "SOUTH":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("SOUTH");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("SOUTH");
					} else {
						_this.rotation = Math.PI / 2;
					}
					break;
				case "TAN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("TAN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("TAN");
					} else {
						_this.pen.currentColor = -27273;
					}
					break;
				case "TRIANGLE_ARCH":
					var distance7 = v[j];
					var distance21 = v[j + 1];
					var radius5 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("TRIANGLE_ARCH");
						_this.historyParameters.push(distance7);
						_this.historyParameters.push(distance21);
						_this.historyParameters.push(radius5);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("TRIANGLE_ARCH");
						_this.turtleParameters.push(distance7);
						_this.turtleParameters.push(distance21);
						_this.turtleParameters.push(radius5);
					} else {
						var nx11 = _this.x + distance7 * Math.cos(_this.rotation);
						var ny11 = _this.y + distance7 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							var thruX1 = _this.x + distance21 * Math.cos(_this.rotation) - radius5 * Math.cos(_this.rotation + Math.PI / 2);
							var thruY1 = _this.y + distance21 * Math.sin(_this.rotation) - radius5 * Math.sin(_this.rotation + Math.PI / 2);
							if(_this.fill) {
								_this.pen.triangle2DFill(_this.x,_this.y,thruX1,thruY1,nx11,ny11);
							}
							_this.lineTo(thruX1,thruY1);
							_this.lineTo(nx11,ny11);
							if(_this.fill) {
								_this.lineTo(_this.x,_this.y);
							}
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx11;
							_this.y = ny11;
							var l20 = _this.points.length;
							_this.points[l20] = [];
							_this.points[l20][0] = nx11;
							_this.points[l20][1] = ny11;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d14 = _this.dim[_this.dim.length - 1];
							if(nx11 < d14.minX) {
								d14.minX = nx11;
							}
							if(nx11 > d14.maxX) {
								d14.maxX = nx11;
							}
							if(ny11 < d14.minY) {
								d14.minY = ny11;
							}
							if(ny11 > d14.maxY) {
								d14.maxY = ny11;
							}
							_this.contour.reset();
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx11;
							_this.y = ny11;
							var l21 = _this.points.length;
							_this.points[l21] = [];
							_this.points[l21][0] = nx11;
							_this.points[l21][1] = ny11;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d15 = _this.dim[_this.dim.length - 1];
							if(nx11 < d15.minX) {
								d15.minX = nx11;
							}
							if(nx11 > d15.maxX) {
								d15.maxX = nx11;
							}
							if(ny11 < d15.minY) {
								d15.minY = ny11;
							}
							if(ny11 > d15.maxY) {
								d15.maxY = ny11;
							}
							_this.contour.reset();
						}
					}
					j += 3;
					break;
				case "WEST":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("WEST");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("WEST");
					} else {
						_this.rotation = 0;
					}
					break;
				case "WHITE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("WHITE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("WHITE");
					} else {
						_this.pen.currentColor = -1;
					}
					break;
				case "YELLOW":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("YELLOW");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("YELLOW");
					} else {
						_this.pen.currentColor = -256;
					}
					break;
				}
			}
			j = 0;
		}
		_this.turtleHistoryOn = wasHistoryOn;
		_this.turtleCommands.length = 0;
		_this.turtleParameters.length = 0;
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("BLUE");
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("BLUE");
		} else {
			_this1.pen.currentColor = -16776961;
		}
	}
};
function cornerContourWebGLTest_CornerContourWebGLTurtle_main() {
	new cornerContourWebGLTest_CornerContourWebGLTurtle();
}
var cornerContourWebGLTest_DivertTrace = function(left_) {
	if(left_ == null) {
		left_ = 610;
	}
	this.textStyle1 = "<span style=\"font-size:14px; color:Grey\">";
	this.textStyle0 = "<span style=\"font-size:12px; color:Silver\">";
	this.traceString = "";
	var doc = window.document;
	this.traceDiv = doc.createElement("div");
	doc.body.appendChild(this.traceDiv);
	var dom = this.traceDiv;
	var style = dom.style;
	style.position = "absolute";
	style.top = Std.string(0 + "px");
	style.left = Std.string(left_ + "px");
	style.height = Std.string(500 + "px");
	style.width = Std.string(500 + "px");
	style.zIndex = "99";
	style.overflow = "auto";
	haxe_Log.trace = $bind(this,this.myTrace);
	window.onerror = $bind(this,this.myError);
};
cornerContourWebGLTest_DivertTrace.__name__ = true;
cornerContourWebGLTest_DivertTrace.prototype = {
	myError: function(msg,url,lineNo,columnNo,errorObj) {
		var arr = url.split("/");
		var file = arr[arr.length - 2] + " " + arr[arr.length - 1];
		var str = this.textStyle0;
		str += "ERROR: " + file + " ( " + (lineNo == null ? "null" : "" + lineNo) + ": " + (columnNo == null ? "null" : "" + columnNo) + " )";
		str += "</span>";
		str += "<br> - ";
		str += this.textStyle1;
		str += Std.string(msg);
		str += "</span>";
		str += "<br>";
		this.traceString += str;
		this.traceDiv.innerHTML = this.traceString;
		return false;
	}
	,myTrace: function(v,inf) {
		if(Std.string(v) == "") {
			return;
		}
		this.traceString += this.textStyle0 + inf.className + "." + inf.methodName + " ( " + (inf.lineNumber == null ? "null" : "" + inf.lineNumber) + " )" + "</span>" + "<br> - " + this.textStyle1 + Std.string(v) + "</span>" + "<br>";
		this.traceDiv.innerHTML = this.traceString;
	}
};
var cornerContourWebGLTest_Sheet = function() {
};
cornerContourWebGLTest_Sheet.__name__ = true;
cornerContourWebGLTest_Sheet.prototype = {
	create: function(width_,height_,autoChild) {
		if(autoChild == null) {
			autoChild = false;
		}
		if(height_ == null) {
			height_ = 600;
		}
		if(width_ == null) {
			width_ = 600;
		}
		this.width = width_;
		this.height = height_;
		this.canvasGL = window.document.createElement("canvas");
		this.canvasGL.width = this.width;
		this.canvasGL.height = this.height;
		var body = window.document.body;
		body.style.overflow = "hidden";
		body.style.position = "fixed";
		this.pixelRatio = window.devicePixelRatio;
		if(this.pixelRatio == null) {
			this.pixelRatio = 1.;
		}
		var bodyEL = window.document.body;
		var style = bodyEL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		this.domGL = this.canvasGL;
		var style = this.domGL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		if(autoChild) {
			body.appendChild(this.canvasGL);
		}
		this.canvas2D = window.document.createElement("canvas");
		this.canvas2D.width = this.width;
		this.canvas2D.height = this.height;
		this.domGL2D = this.canvasGL;
		var style = this.domGL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		if(autoChild) {
			body.appendChild(this.canvas2D);
		}
		this.gl = this.canvasGL.getContext("webgl",{ premultipliedAlpha : false});
		this.cx = this.canvas2D.getContext("2d");
	}
};
var fracs_DifferencePreference = $hxEnums["fracs.DifferencePreference"] = { __ename__:true,__constructs__:null
	,CLOCKWISE: {_hx_name:"CLOCKWISE",_hx_index:0,__enum__:"fracs.DifferencePreference",toString:$estr}
	,ANTICLOCKWISE: {_hx_name:"ANTICLOCKWISE",_hx_index:1,__enum__:"fracs.DifferencePreference",toString:$estr}
	,SMALL: {_hx_name:"SMALL",_hx_index:2,__enum__:"fracs.DifferencePreference",toString:$estr}
	,LARGE: {_hx_name:"LARGE",_hx_index:3,__enum__:"fracs.DifferencePreference",toString:$estr}
};
fracs_DifferencePreference.__constructs__ = [fracs_DifferencePreference.CLOCKWISE,fracs_DifferencePreference.ANTICLOCKWISE,fracs_DifferencePreference.SMALL,fracs_DifferencePreference.LARGE];
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = true;
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	get_native: function() {
		return this.__nativeException;
	}
});
var haxe_Log = function() { };
haxe_Log.__name__ = true;
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
});
var haxe_ds_Either = $hxEnums["haxe.ds.Either"] = { __ename__:true,__constructs__:null
	,Left: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.ds.Either",toString:$estr}; },$_._hx_name="Left",$_.__params__ = ["v"],$_)
	,Right: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"haxe.ds.Either",toString:$estr}; },$_._hx_name="Right",$_.__params__ = ["v"],$_)
};
haxe_ds_Either.__constructs__ = [haxe_ds_Either.Left,haxe_ds_Either.Right];
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
String.__name__ = true;
Array.__name__ = true;
js_Boot.__toStr = ({ }).toString;
var cornerContour_CurveMath_quadStep = 0.03;
cornerContourWebGLTest_CornerContourWebGLTurtle_main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
